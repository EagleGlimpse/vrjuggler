<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="../../../../../../../../../home/users/patrick/src/Juggler/docs/stylesheet/docbook_ab.css" type="text/css"?>
<?morphon-document-settings
  morphon.document.settings.whitespaces.amount="3"
  morphon.document.settings.print.fixed.attributes="true"
  morphon.document.settings.stylesheetpi.autoupdate="true"
  morphon.document.settings.print.defaultvalues.attributes="false"
  morphon.document.settings.relative.systemids="0"
  morphon.document.settings.endofline.type="2"
  morphon.document.settings.whitespaces.type="indent"
?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>VR Juggler</title>
      <subtitle>The Build System</subtitle>
      <author>
         <firstname>Patrick</firstname>
         <surname>Hartling</surname>
      </author>
      <releaseinfo>2.0.0</releaseinfo>
      <pubdate>$Date$</pubdate>
   </bookinfo>
   <preface>
      <title>Software Choreography</title>
      <para>Within this book, we present the fundamentals of the VR Juggler 2.0 build system, a complex piece of software in its own right that manages the compilation of the various modules that make up VR Juggler 2.0 (and beyond, I suspect). Those few readers who may be familiar with the VR Juggler 1.0 build system may recognize a few similarities, but truly, the Doozer++-based build is quite different than what was originally intended to be backwards compatible with an IRIX-only build written for the first version of VR Juggler (then called VRLib).</para>
      <para>Since 1998, the Autoconf-based VR Juggler build system has grown more and more complex. Originally, the build made use of Autoconf, GNU make, and a few small Perl scripts to simplify installations. Now, in mid-2002, the build system still makes use of all those tools, but it has many, many custom m4 macros (most of which come from Doozer++), makefile stubs, Autoconf-like scripts written in Perl, and custom CVS utilities. It may yet evolve to include Java- and Python-based tools.</para>
      <para>With all this (growing) complexity, the VR Juggler 2.0 build system is a colossal effort in software choreography wherein all the pieces have to come together in such a way as to exude a Broadway-calibre performance. In this book, I strive to lay out the steps like one of Arthur Miller's finest teachers.</para>
   </preface>
   <part id="introduction.part">
      <title>Introduction</title>
      <partintro>
         <epigraph>
            <attribution>William Shakespeare, The Merchant of Venice, Act 1, Scene 1</attribution>
            <para>In sooth, I know not why I am so sad:</para>
            <para>It wearies me; you say it wearies you;</para>
            <para>But how I caught it, found it, or came by it,</para>
            <para>What stuff 'tis made of, whereof it is born,</para>
            <para>I am to learn;</para>
            <para>And such a want-wit sadness makes of me,</para>
            <para>That I have much ado to know myself.</para>
         </epigraph>
         <para>In this first part, we explain the basics of the VR Juggler build system. We will begin with the goals of the Doozer++<indexterm>
               <primary>Doozer++</primary>
            </indexterm> software package which forms the basis for the entire build. We move on to the specific goals of the VR Juggler build system. The scope of the VR Juggler build, while broad, is narrower than that of Doozer++, and hence, it will be useful to understand first why Doozer++ exists and what purpose it serves.</para>
      </partintro>
      <chapter id="philosophy.chapter">
         <title>The Philosophy</title>
         <para>Nearly everything has a philosophy, and the VR Juggler build system is no different. The build system philosophy has evolved from the following observation: programmers think more about writing their code than about compiling it. Compiling takes time that could be spent writing code, so compiling must be fast. Command-line arguments have little to do with code, and thus they are easily forgotten. Paths to external dependencies are esoteric file system thingies that are never referenced in code. Because of these points, the basic philosophy of the VR Juggler build system and of Doozer++<indexterm>
               <primary>Doozer++</primary>
            </indexterm> in general is simple: automate everything.</para>
         <para>Automation in a build system means doing as much as possible to avoid requiring programmers to type anything beyond the following familiar command:</para>
         <screen>configure ; make ; make install</screen>
         <para>Whether this is always possible is highly debatable, but either way, it should always be the goal. If the above cannot be achieved, some mechanism must exist so that programmers feel as though that is all they ever have to type.</para>
         <para>There is much more to the philosophy of the VR Juggler build system than just automation, but someone looking at the code would see that steps to automate configuration and compliation make up a sizeable percentage of the total line count. Beyond simplifying the process of building, we also have the goal of simplifying extensions to the build system.</para>
         <para>Unfortunately, repeated experience has shown that no amount of simplification is enough to satisfy even the most patient of users. This harkens back to the original point stating that programmers focus more on writing their code than on compiling it. A build system is always going to be foreign to the majority of the people on any given team, and taking the time to learn and understand a build system takes up valuable coding time. Despite these bleak statements, it is possible to put together a build system that requires little effort to extend when a new file must be compiled or a new source directory is added. Those who hope for more than this are likely to be let down.</para>
         <para>More details on the goals of Doozer++ and the VR Juggler build system are provided in the next chapter. All of these goals are founded by the philosophy discussed above.</para>
      </chapter>
      <chapter id="goals.dpp.chapter">
         <title>Goals of Doozer++</title>
         <indexterm>
            <primary>Doozer++</primary>
            <secondary>goals of</secondary>
         </indexterm>
         <para>When the first <glossterm linkend="gloss.autoconf">Autoconf</glossterm>-based VR Juggler build system was started in mid-1998, we had to make a decision: should we use <glossterm linkend="gloss.automake">Automake</glossterm> in addition to Autoconf? At the time, we felt that there were several problems with Automake<indexterm>
               <primary>Automake</primary>
               <secondary>problems with</secondary>
            </indexterm>, including the following:</para>
         <orderedlist>
            <listitem>
               <para>The generated makefiles were too complex to debug</para>
            </listitem>
            <listitem>
               <para>Use of compilers other than GCC was too difficult</para>
            </listitem>
            <listitem>
               <para>Restrictions on the structure and contents of the source tree were undesirable</para>
            </listitem>
         </orderedlist>
         <para>In four years, we have only been proven wrong on point #3. In our experience, Automake still generates extremely complex makefiles (though it does it very nicely from extremely simple input), and use of compilers such as the MIPSpro Compilers or Microsoft Visual C++ is still very hard.</para>
         <para>Based on our needs for VR Juggler (and many other projects that have been developed at Iowa State University's Virtual Reality Applications Center), we identified the following as key goals for Doozer++:</para>
         <itemizedlist>
            <listitem>
               <para>Simplify the use of Autoconf</para>
            </listitem>
            <listitem>
               <para>Allow the use of any operating system</para>
            </listitem>
            <listitem>
               <para>Allow the use of any compiler</para>
            </listitem>
            <listitem>
               <para>Allow code to be written in any language</para>
            </listitem>
            <listitem>
               <para>Use the best tool for a given task</para>
            </listitem>
         </itemizedlist>
         <para>Each of these goals will be addressed in the following sections.</para>
         <section>
            <title>Ease of Use</title>
            <para>Time and time again, we have seen a resistance to the use of Autoconf because of its (seemingly) arcane language constructs. While macro languages are difficult to use and <command>sh</command>(1) syntax is not immediately intuitive, neither tool can be considered arcane. Indeed, <command>sh</command>(1) is a much more powerful language than most other shell scripting languages, but because of its unique syntax, people tend to shy away from its use.</para>
            <para>Further complicating the issue is the complexity of Autoconf in general. It contains many, many macros, and it defines rules for the order of executing those macros. In order to use Autoconf effectively, build system developers must read a fair amount of documentation (all of which is readily available). In our experience, however, many people feel that development build system software should be immediately obvious<footnote>
                  <para>Of course, little, if anything, is <quote>immediately obvious</quote> in reality. Users tend to want something that is similar to existing tools or something that allows them to make use of existing knowledge.</para>
               </footnote> and should not require much effort to learn.</para>
            <para>As a result of these issues, we have attempted to make Doozer++ easier to use than <quote>raw</quote> Autoconf-based <glossterm linkend="gloss.configure-script"><email></email>configure scripts</glossterm>. Doozer++ macros hide some common details that often trip up configure script authors. Many utility macros are provided to reduce code duplication between <filename>configure.in</filename> files. For example, code for verifying that an existing installation of a software package meets a version requirement is provided. The code for performing the check is modularized to separate the common tasks involved with this. Namely, Doozer++ provides macros comparing two version numbers, acting on the results of the comparison, and caching the results to speed up future tasks. Each macro is used as the basis for the next so that users have the freedom to choose how they want their code to behave. We feel that this offers a level of flexibility not available with Autoconf 2.13.</para>
         </section>
         <section>
            <title>Platform Independence</title>
            <para>Because VR Juggler has always been a cross-platform tool, we have had the need for a cross-platform way to build it. The VR Juggler 1.0 build system achieved this to a limited degree, and Doozer++ goes a step further towards true platform independence. At this time, Doozer++ makes use of software utilities found on all modern operating systems. The list of utilities includes <command>m4</command>(1), <command>sh</command>(1), Perl, Autoconf, and GNU make. We have avoided the use of platform-specific tools because it is all too easy for the platform-specific parts of a build system to get out of sync with each other. Furthermore, we have tried to avoid the use of platform-specific code whenever possible. This is a more difficult goal to achieve, but later sections will address the extent to which platform-specific code can be reduced.</para>
         </section>
         <section>
            <title>Compiler Freedom</title>
            <para>As a cross-platform C++ library, VR Juggler must be compatible with the prevailing C++ compiler on a given platform. In the case of IRIX, that is SGI's MIPSpro Compilers. Similarly, the use of Microsoft Visual C++ is crucial on Win32 platforms. Open source operating systems such as FreeBSD and Linux use GCC, so we have not ignored that compiler whatsoever. Due to our limited needs, however, we have focused on compilers for the C, C++, Java, and IDL languages<indexterm>
                  <primary>languages</primary>
                  <secondary>supported</secondary>
               </indexterm>. Nothing prevents Doozer++ from being extended to allow compiling of code written in FORTRAN, Ada, Pascal, etc<indexterm>
                  <primary>languages</primary>
                  <secondary>unsupported (currently)</secondary>
               </indexterm>.</para>
            <para>In Doozer++, an m4 macro sets up the basic platform-specific pieces. User-level code (in an Autoconf <filename>configure.in</filename> file) then uses that information to execute other macros that pick the appropriate compiler. This builds upon the foundation provided by Autoconf for detecting installed programs, but it goes further by allowing users to associate one or more compilers with a given platform. The end result is a <quote>fallback</quote> system wherein users specify the preferred compiler and zero or more alternatives if the preferred compiler is not available. To achieve this flexibility, the Doozer++ m4 macros must have no compiler-specific bits.</para>
         </section>
         <section>
            <title>Language Freedom</title>
            <para>Language freedom is slightly more complicated than compiler freedom. As will be discussed more fully in the following section, Doozer++ separates its work into two pieces: configuration and compilation. During configuration, the tools for compilation are chosen; during compilation, the chosen tools are put to use.</para>
            <para>The primary project building tool is GNU make. We chose GNU make initially because of its portability and because it offered useful features over most basic <command>make</command>(1) implementations. Other implementations, such as BSD make, offer even more features, but they are not as portable as GNU make.</para>
            <para>Because Doozer++ uses GNU make, users must write makefiles. Doozer++ provides a number of modular makefile <quote>stubs</quote> that collect common functionality. In particular, these stubs provide support for compiling code written in Java, C, C++, and IDL. Adding support for other langauges can be done within Doozer++ or within user-level makefiles.</para>
         </section>
         <section>
            <title>Separation of Tools and Tasks</title>
            <para>The design of Doozer++ involves a distinct separation between the tools used and the tasks performed. As a result of this separation, there exists the possibility to extend Doozer++ to use tools other than Autoconf and GNU make. Moreover, different combinations are allowed. For example, we have found that <command>make</command>(1) does not deal well with compiling Java code in general. A more appropriate tool for this task has come out of <ulink url="http://jakarta.apache.org/">the Apache Jakarta Project</ulink> called <ulink url="http://jakarta.apache.org/ant/">Ant</ulink><indexterm>
                  <primary>Ant</primary>
               </indexterm>. Within Doozer++, we could make use of Ant instead of or in addition to GNU make to compile Java software. Nothing restricts users to Autoconf and/or GNU make.</para>
            <para>The basic idea behind the separation is the following: detect and configure the static information needed to execute tools that compile a (potentially complex) software system. This leads to a two-step process: configuration and compliation. These steps are described in the following subsections.</para>
            <section>
               <title>Configuration</title>
               <para>During the configuration stage, we determine what tools are available that meet a given set of needs. Typically, this means finding suitable compilers and determining what options the compilers support. Of course, most projects have more complicated needs than this. For example, VR Juggler can be compiled with several different versions of GCC (2.95.3 through 3.1 as of this writing). When moving between platforms, the GCC C++ compiler will almost always be called <command>g++</command>, but it may not always be the same version<footnote>
                     <para>On a platform with multiple GCC installations, the executable names typically vary based on the version. For example, a FreeBSD 4.x installation with multiple GCC builds may have the executables <command>g++</command>, <command>g++30</command>, <command>g++31</command>, and <command>g++32</command> for versions 2.95.4, 3.0, 3.1, and 3.2 respectively. On RedHat Linux 7.2, <command>g++</command> is GCC 2.96 while <command>g++3</command> is GCC 3.0.4.</para>
                  </footnote>. For that reason, it may be necessary to perform several version-specific detection steps, including, but not limited to, the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Whether a given option is required or even supported (for example, <option>-fexceptions</option> or <option>-LANG:&lt;arg&gt;</option>)</para>
                  </listitem>
                  <listitem>
                     <para>What header files are available (<filename>hash_map.h</filename>, <filename>hash_map</filename>, <filename>ext/hash_map</filename>, or none of the preceding, for example)</para>
                  </listitem>
                  <listitem>
                     <para>What libraries are needed for linking shared libraries or executables (<filename>libdl</filename>, <filename>libposix4</filename>, or <filename>ws2_32.lib</filename>, for example)</para>
                  </listitem>
               </itemizedlist>
               <para>Moving beyond compiler-specific issues, it may be necessary to detect the installation of third-party libraries or programs. Often times, simply finding an installation is not sufficient. The version of the installation must also be checked to ensure compatibility with the user's project.</para>
               <para>This all boils down to one thing: automation. The job of the configuration step is to automate as much as possible. In so doing, the code used to write the compilation can be simplified. In effect, the compilation step becomes a very generic process that is configured based on many platform-, compiler-, and site-specific details that cannot be detected easily by a tool designed for compiling.</para>
            </section>
            <section>
               <title>Compilation</title>
               <para>As we just described in the preceding section, the compilation step should be a very generic process. Compiling software tends to be a very serialized or step-by-step process. Subsequent steps depending on proper completion of preceding steps. Nothing in particular about compiling software (or code generation in general) has to be tied to a specific set of tools. The process should depend more on the source code and what steps are necessary to generate the desired outcome.</para>
               <para>While it is possible to construct build system software that does everything in the compilation step (a la Doozer<indexterm>
                     <primary>Doozer</primary>
                  </indexterm> proper), such systems tend to be very inflexible. Everything that could provided more generically through the configuration phase must be defined statically in makefiles (or whatever specification file is being used to direct the build process) and in the code. For example, consider the following C++ code:</para>
               <programlisting>#if defined(HAVE_HASH_MAP)
#include &lt;hash_map&gt;
#elif defined(HAVE_EXT_HASH_MAP)
#include &lt;ext/hash_map&gt;
#elif defined(HAVE_HASH_MAP_H)
#include &lt;hash_map.h&gt;
#else
#error "std::hash_map is not available with this compiler"
#endif</programlisting>
               <para>The code above is not tied to any specific compiler or any specific compiler version. Now, consider the following code that achieves the same result:</para>
               <programlisting>#if defined(__GNUC__)
#  if __GNUC__ &lt; 3 &amp;&amp; __GNUC__ &gt;= 2 &amp;&amp; __GNUC_MINOR__ &gt;= 95
#     include &lt;hash_map&gt;
#  elif __GNUC__ &gt;= 3
#     include &lt;ext/hash_map&gt;
#  else
#     include &lt;hash_map.h&gt;
#  endif
#elif defined(__MSVC_VER__)
#  if __MSVC_VER__ &gt;= 7
#     include &lt;hash_map&gt;
#  else
#     error "std::hash_map is not available with this compiler"
#  endif
#elif defined(__sgi__)
#  include &lt;hash_map&gt;
#else
#  error "std::hash_map is not available with this compiler"
#endif</programlisting>
               <para>The former is much shorter and hides all the platform- and compiler-specific details in the definition of the various <symbol>HAVE_*</symbol> symbols. The latter code is clearly much more complicated and only supports three compilers: GCC, Visual C++, and MIPSpro. (The latter example may also have inaccuracies. Think of it more as pseudo-code than something taken from real C++ code.) Certainly, the latter could be simplified by adding command-line options defined in platform- and compiler-specific makefile stubs (<option>-DHAVE_HASH_MAP</option> and so on), but such options would have to be provided for all possible cases. That method has obvious scalability problems, however.</para>
               <para>Many other projects provide a variety of platform- and tool-specific makefile stubs that set up a build environment at the time of compilation. This inevitably leads to an ever growing number of stubs as the software becomes more portable or as external tools (especially compilers) evolve. For example, omniORB 3.0 (an excellent, freely available ORB implementation) has forty makefile stubs, four of which are for use on varying configurations Linux/i386. The upcoming omniORB 4.0, on the other hand, uses Autoconf to separate the platform-specific pieces from the generic, platform-independent compilation work.</para>
            </section>
         </section>
         <section>
            <title>Further Developments</title>
            <para>There are many long-term goals for Doozer++ that are beyond the scope of this document. As should be evidenced from the previous sections, however, some near-term goals include the use of project builder tools besides <command>make</command>(1).</para>
         </section>
      </chapter>
      <chapter id="goals.vrj.chapter">
         <title>Goals of the VR Juggler Build System</title>
         <para>The VR Juggler 2.0 build system is based on Doozer++<indexterm>
               <primary>Doozer++</primary>
            </indexterm>, and thus the goals of Doozer++ extend into the VR Juggler build system. The VR Juggler build system has a much narrower scope than Doozer++, so it has some unique goals, and they are as follows:</para>
         <itemizedlist>
            <listitem>
               <para>Centralize the complexity of the build code</para>
            </listitem>
            <listitem>
               <para>Minimize what users must remember to configure and compile the source</para>
            </listitem>
            <listitem>
               <para>Port quickly to new platforms</para>
            </listitem>
         </itemizedlist>
         <para>In the following sections, we discuss each of the above goals in more detail.</para>
         <section>
            <title>Centralize Complexity</title>
            <para>Due to the size of the VR Juggler 2.0 source base (nearly 500,000 lines of C++ and Java by one estimate), it is important that the complexity of compiling be centralized rather than spread out over the entire source tree. Centralizing the complexity allows most of the work to be done once, the results of which can then be reused by the rest of the build code. This is the key tenet for the other goals.</para>
            <para>Centralization of complexity allows the VR Juggler build to follow the goal of Doozer++<indexterm>
                  <primary>Doozer++</primary>
               </indexterm> wherein tools and tasks are separated based on what they do. The result is that each of the module's has an Autoconf- and Doozer++-based configure script that bears the brunt of the work needed to hide complexity. Then, each module has one or more <glossterm linkend="gloss.glue-makefile"><quote>glue</quote> makefiles</glossterm> that pull everything together. These glue makefiles typically direct a given module's build process so that steps occur in the correct order. Because they oversee the whole compilation process, they are often large files with many targets, each of which is responsible for a specific task. With a configure script and a glue makefile, all that remains is a listing of source files that must be compiled. The makefiles that list source files are often very, very short and easy for anyone to extend.</para>
            <para>With this foundation, the complexity is separated thusly:</para>
            <itemizedlist>
               <listitem>
                  <para>Platform-specific work happens in a configure script where a flexible programming language is readily available</para>
               </listitem>
               <listitem>
                  <para>Flow of execution during compilation is directed by a single, often long, glue makefile</para>
               </listitem>
               <listitem>
                  <para>Source listings (for any language) are placed in short makefiles that are called by the glue makefile</para>
               </listitem>
            </itemizedlist>
            <para>Other steps have been taken to offload complexity or repeated tasks into centralized components. For example, the directory <filename>juggler/macros</filename> contains Autoconf/m4 macros that can be used in configure scripts. Most of the macros are used to detect and provide information about the various modules that comprise VR Juggler. There are a few helper macros that build on top of Doozer++ and common idioms we have used to simplify configure scripts further.</para>
         </section>
         <section>
            <title>Minimize Special Steps</title>
            <para>As has been discussed at great length previously, it is important that users of the build system be freed from remembering many commnad-line arguments or special steps that must be taken to build a given piece of software. With several modules to configure and build, there is a lot to know about compiling VR Juggler. Most modules have external dependencies, the paths to which must be specified using command-line arguments. Furthermore, some modules may be compiled differently based on configuration-time settings. The so-called <quote>global build</quote> manages all of this, and so it has the responsibility of reducing the amount of information users must remember.</para>
            <para>To that end, the global build offers some features for remembering command-line arguments so that users do not have to. Many of the configure scripts for the individual modules are written such that the default values for arguments are reasonable enough that users rarely have to pass them. The combination of these two features usually allows the typical developer to run the global configure script with no arguments. While this is not always the case (for example, on Win32, the path to NSPR must be specified unless the user has done something special in his or her environment), it happens often enough to keep people reasonably happy.</para>
         </section>
         <section>
            <title>Port Quickly to New Platforms</title>
            <para>VR Juggler as a whole is a cross-platform software system. Porting to new operating systems is a non-trivial task, and spending time porting the build system to new platforms is time that could be spent more effectively. Speaking less abstractly, before the source code can be ported to a new platform, the build system has to be capable of compiling the source code on the new platform. For that reason, it is important that the entire build system can be put to use right away so that the attention can be devoted to the more difficult task of porting C++ code.</para>
            <para>The VR Juggler build system is limited in its portability by the portability of Doozer++<indexterm>
                  <primary>Doozer++</primary>
               </indexterm>. To its credit, Doozer++ is more portable than VR Juggler at this time, so the VR Juggler team still has some room to move. Even so, the VR Juggler build has its own quirks, and thus, people writing the code to build VR Juggler must always have portability in mind. For example, <quote>BASH-isms</quote> must never appear in VR Juggler configure scripts or makefiles. Most Linux distributions may use BASH<indexterm>
                  <primary>BASH</primary>
                  <secondary>in makefiles</secondary>
               </indexterm> for <filename>/bin/sh</filename>, but that certainly does not meant hat all operating systems vendors follow that unfortunate trend.</para>
            <para>In keeping with the Doozer++ goal of separating tools and tasks, the VR Juggler build system offers good portability by putting all of the platform- and software-specific pieces in Autoconf configure scripts. In so doing, the makefiles rarely, if ever, have to be modified when a new platform is added to the list. Furthermore, makefiles for GNU make lack sufficient programmatic constructs to provide developers with the ability to write tests that provide more than limited portability. While the Doozer software is relatively portable through its use of GNU make and platform-specific makefiles, it is missing the expressiveness of something based on Autoconf (or a similar tool). As discussed in the previous chapter, the use of <command>make</command>(1) alone for portability requires much effort to make hard-coded, platform- and site-specific makefiles.</para>
         </section>
      </chapter>
   </part>
   <part id="design.part">
      <title>Design</title>
      <partintro>
         <epigraph>
            <attribution>J.R.R. Tolkien, The Lord of the Rings, Volume 1, page 81</attribution>
            <para><quote>Three Rings for the Elven Kings under the sky, Seven for the Dwarf Lords in their halls of stone, Nine for Mortal Men doomed to die, One for the Dark Lord on his dark throne, In the Land of Mordor, Where the Shadows lie. One Ring to rule them all, One Ring to find them, One Ring to bring them all, And in the darkness bind them, In the Land of Mordor, Where the Shadows lie.</quote></para>
         </epigraph>
         <para></para>
      </partintro>
      <chapter id="global.build.chapter">
         <title>The <quote>Global</quote> Build</title>
         <para>In this chapter, we present the design of the so-called <quote>global</quote> build. We cover the high-level aspects of the build system that ties together all the other build systems. In a sense, this is the one build system to rule them all.</para>
         <section id="global.build.rules.section">
            <title>Follow the Rules</title>
            <para>In order for the global build to work, the modules it wraps must follow certain rules. If a module does not comply with all the rules, there is no guarantee that it will be able to compile under all circumstances. In other words, <quote>rogue</quote> modules that only implement a few pieces of the puzzle quickly become the weak link in the chain, and module build system authors who want to live outside the rule set complicate matters for everyone else.</para>
            <para>Because the VR Juggler build system is a complicated dance, there are many rules that must be followed. For example, certain targets must be defined so that recursive <command>make</command>(1) calls can proceed through the entire source tree. These targets include '<literal>release</literal>', '<literal>install-debug</literal>', '<literal>links</literal>', and '<literal>buildworld</literal>'. Other rules include restrictions on the names of files or directories, use of platform-specific conventions, the presence of a working <filename>-config</filename> script (see <xref linkend="config.scripts.section"/>), and provisions for the detection of a usable installation. The full list of rules are provided in the following subsections.</para>
            <section id="global.build.req.targets.section">
               <title>Required Targets</title>
               <indexterm>
                  <primary>required targets</primary>
               </indexterm>
               <para>There are a number of targets required by the global build. Some of these were listed above. The following sub-subsections give a complete list of all targets that must be implemented by a module's glue makefile. The targets are grouped by the task they perform.</para>
               <section id="global.build.build.targets.section">
                  <title>Build Targets</title>
                  <indexterm>
                     <primary>required targets</primary>
                     <secondary>build</secondary>
                  </indexterm>
                  <para>The build targets have the job of building source code. What this means is up to the individual module. It may, for example, include the generation of source code using tools such as an <glossterm linkend="gloss.idl-compiler">IDL compiler</glossterm>, an <glossterm linkend="gloss.xslt">XSLT</glossterm> processor, or a Java compiler. The targets need not do anything if, for whatever reason, the generic concept of building source code does not apply.</para>
                  <variablelist>
                     <varlistentry>
                        <term>build</term>
                        <listitem>
                           <para>This target builds everything. It executes the first phase of the '<literal>world</literal>' target (i.e., only the build phase, not the install phase). Since it builds both debugging and optimized versions of a module without installing, it is useful for testing changes to the library code to ensure that it works in both the debugging and optimized cases. A profiled version of the module may also be built if the module build system supports that and the compiler can build such a version.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>buildworld</term>
                        <listitem>
                           <para>This target is the same as '<literal>build</literal>'.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>debug</term>
                        <listitem>
                           <para>Build only the debugging version of the module. If the target platform supports both types, static and dynamic versions are compiled. In other words, the module is built so that debugging symbols are turned on. It is the combination of '<literal>dbg</literal>' and '<literal>dbg-dso</literal>' (see below). <emphasis>This is the default target and is what gets built if running <command>make</command>(1) with no arguments.</emphasis></para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>optim</term>
                        <listitem>
                           <para>Build only the optimized version of the library binaries (both static and dynamic). This is built with no debugging symbols at all. It is the combination of '<literal>opt</literal>' and '<literal>opt-dso</literal>'.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>profiled</term>
                        <listitem>
                           <para>Build only the profiled version of the library binaries (both static and dynamic). This capability is dependent on the compiler being used. Not all compilers support the process of generating profiled code, so this target may have no effect. Profiled libares are built with debugging symbols. This target is the combination of '<literal>prof</literal>' and '<literal>prof-dso</literal>'.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>dbg</term>
                        <listitem>
                           <para>Build only the <emphasis>static</emphasis> debugging version of the libraries. This does the same thing as '<literal>debug</literal>' but does not compile the dynamic libraries.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>dbg-dso</term>
                        <listitem>
                           <para>Build only the <emphasis>dynamic</emphasis> debugging version of the libraries. This does the same thing as '<literal>debug</literal>' but does not compile the static libraries.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>opt</term>
                        <listitem>
                           <para>Build only the <emphasis>static</emphasis> optimized version of the libraries. This does the same thing as '<literal>optim</literal>' but does not compile the dynamic libraries.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>opt-dso</term>
                        <listitem>
                           <para>Build only the <emphasis>dynamic</emphasis> optimized version of the libraries. This does the same thing as '<literal>optim</literal>' but does not compile the static libraries.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>prof</term>
                        <listitem>
                           <para>Build only the <emphasis>static</emphasis> profiled version of the libraries. This does the same thing as '<literal>profiled</literal>' but does not compile the dynamic libraries.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>prof-dso</term>
                        <listitem>
                           <para>Build only the <emphasis>dynamic</emphasis> profiled version of the libraries. This does the same thing as '<literal>profiled</literal>' but does not compile the static libraries.</para>
                        </listitem>
                     </varlistentry>
                  </variablelist>
               </section>
               <section id="global.build.install.targets.section">
                  <title>Installation Targets</title>
                  <indexterm>
                     <primary>required targets</primary>
                     <secondary>installation</secondary>
                  </indexterm>
                  <para>The installation targets set in motion the process of installing a module. As with build targets, what this means may vary from module to module. Each module is responsible for ensuring that its installation hierarchy exists before trying to copy files.</para>
                  <variablelist>
                     <varlistentry>
                        <term>install</term>
                        <listitem>
                           <para>This is the complement to '<literal>build</literal>' (described in <xref linkend="global.build.build.targets.section"/>), and in most cases, it is assumed that the build was performed before an installation is attempted. This target executes the second phase of the '<literal>world</literal>' target. It performs a complete installation of debugging and optimized versions of a module. Installation of a profiled build will be performed if a profiled version was generated. Further, both the dynamic and static versions of a module will be installed if the target platform supports both. (This is of course assuming that the module builds one or more libraries.)</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>installworld</term>
                        <listitem>
                           <para>This target is the same as '<literal>install</literal>'.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>install-debug</term>
                        <listitem>
                           <para>Install only the debugging version of the module. If the module includes one or more libraries, both static and dynamic versions of the libraries are installed.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>install-optim</term>
                        <listitem>
                           <para>Install only the optimized version of the module. If the module includes one or more libraries, both static and dynamic versions of the libraries are installed.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>install-profiled</term>
                        <listitem>
                           <para>Install only the profiled version of the module. This may have no effect if the module build system does not support building profiled code or if the compiler cannot generate profiled code. If the module includes one or more libraries, both static and dynamic versions of the libraries are installed.</para>
                        </listitem>
                     </varlistentry>
                  </variablelist>
               </section>
               <section>
                  <title>Multi-Step Targets</title>
                  <indexterm>
                     <primary>required targets</primary>
                     <secondary>multi-step</secondary>
                  </indexterm>
                  <para>There are a few multi-step targets required by the global build. Essentially, these targets perform builds and installations, though they do not necessarily build and installed exactly the same thing. They are intended to be used for making releases or for users who simply want a one-step build/install of a module.</para>
                  <variablelist>
                     <varlistentry>
                        <term>world</term>
                        <listitem>
                           <para>Clean up the build environment and then build and install everything using the default ABI and ISA. This is a simple target for those who just want to build and install the module as simply as possible. <quote>Everything</quote> in this case is the following:</para>
                           <itemizedlist>
                              <listitem>
                                 <para>Debugging, optimized, and profiled versions of the library binaries</para>
                              </listitem>
                              <listitem>
                                 <para>Shared and static versions of the library binaries (if both are supported on the target platform)</para>
                              </listitem>
                              <listitem>
                                 <para>Header files</para>
                              </listitem>
                              <listitem>
                                 <para>Sample applications, test code, user tools, etc.</para>
                              </listitem>
                              <listitem>
                                 <para>Data files (sample config files, model files, whatever)</para>
                              </listitem>
                           </itemizedlist>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>world-all-abi</term>
                        <listitem>
                           <para>This is the same as the '<literal>world</literal>' target except that it builds and installs <emphasis>all possible</emphasis> ABI and ISA combinations for the target platform. On IRIX, for example, this means that all combinations of N32, 64, mips3, and mips4 (debugging and optimized versions) are built and installed. Most platforms currently support only one ABI/ISA combination thus making this target the same as '<literal>world</literal>'.</para>
                           <note>
                              <para>As of this writing, the global build does not have this target. Some modules in the Juggler Project still do not support building multiple ABIs.</para>
                           </note>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>release</term>
                        <listitem>
                           <para>This target is similar to '<literal>world</literal>' except that the installation tree is suitable for redistribution. Extra files such as the change logs, the release notes, and the license files are installed. In addition, the tree is stamped with a build time to help track possible differences between two releases of the same version. (This has only occurred for one VR Juggler beta release, but it seems like a good idea to have the build time included with a distribution.)</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>release-all-abi</term>
                        <listitem>
                           <para>This is the same as the '<literal>release</literal>' target except that it builds and installs <emphasis>all possible</emphasis> ABI and ISA combinations for the target platform. On IRIX, for example, this means that all combinations of N32, 64, mips3, and mips4 (debugging and optimized versions) are built and installed. Most platforms currently support only one ABI/ISA combination thus making this target the same as '<literal>release</literal>'.</para>
                           <note>
                              <para>As of this writing, the global build does not have this target. Some modules in the Juggler Project still do not support building multiple ABIs.</para>
                           </note>
                        </listitem>
                     </varlistentry>
                  </variablelist>
               </section>
               <section>
                  <title>Clean-Up Targets</title>
                  <indexterm>
                     <primary>required targets</primary>
                     <secondary>clean-up</secondary>
                  </indexterm>
                  <para>There are three targets used to clean up the build environment. Each cleans the tree to a different degree. Of the following three, '<literal>clean</literal>' and '<literal>cleandepend</literal>' remove disjoint sets of files. The '<literal>clobber</literal>' target performs at least the tasks of '<literal>clean</literal>' and '<literal>cleandepend</literal>'.</para>
                  <variablelist>
                     <varlistentry>
                        <term>clean</term>
                        <listitem>
                           <para>Clean up everything in the build environment. This uses the '<literal>clean</literal>' target defined by Doozer++<indexterm>
                                 <primary>Doozer++</primary>
                              </indexterm> that is automatically included by all makefiles. The cleaning process is recursive just as the build process is. Each makefile may define which files are safe for cleaning, but generally core files, compiler-generated files, and object files are the only things removed during this process.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>cleandepend</term>
                        <listitem>
                           <para>Clean up the automatically generated dependency files (the <filename>.d</filename> files in each directory). This method for cleaning up deletes only these files and nothing else--ever.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>clobber</term>
                        <listitem>
                           <para>Clean up (clobber) the entire build environment except what was generated by <command>configure</command>. This runs the above clean-up targets and removes the object directory(ies) and <filename>lib</filename> directory(ies). Its purpose is to reset the build environment to its state just prior to running <command>configure</command>.</para>
                        </listitem>
                     </varlistentry>
                  </variablelist>
               </section>
               <section>
                  <title>Developer Targets</title>
                  <indexterm>
                     <primary>required targets</primary>
                     <secondary>developer</secondary>
                  </indexterm>
                  <para>Finally, there are two targets that are relevant only to developers. These relate to the developer installation (see <xref linkend="instlinks.section"/>). One creates the developer installation, and the other removes it.</para>
                  <variablelist>
                     <varlistentry>
                        <term>links</term>
                        <listitem>
                           <para>Set up the developer pseudo-installation environment.</para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term>clean-links</term>
                        <listitem>
                           <para>Remove the developer pseudo-installation environment.</para>
                        </listitem>
                     </varlistentry>
                  </variablelist>
               </section>
            </section>
            <section>
               <title>File and Directory Names</title>
               <para>There are certain naming conventions for files and directories that must be followed in order to ensure consistency among all the modules in the Juggler Project. Not all of these relate directly to the build system, but the names may be influenced by the way the build system works.</para>
               <section>
                  <title>Autoconf-Generated Header File</title>
                  <para>All the modules (save one) make use of an Autoconf-generated header file that sets up <symbol>#define</symbol>s based on tests performed by the module's configure script. To avoid overlap or confusion, these files are named based on the module's C++ namespace. Furthermore, the header files must be generated within the module's unique header directory. For example, in Gadgeteer, the C++ namespace is <literal>gadget</literal>. Hence, the header file is <filename>gadgetDefines.h</filename>, and it is generated to the <filename>gadget</filename> directory.</para>
                  <para>The reason for the redundancy is to prevent user errors by avoiding ambiguities. Consider the following bit of code:</para>
                  <programlisting>#include &lt;defines.h&gt;
#include &lt;vpr/Sync/Mutex.h&gt;
#include &lt;vrj/Kernel/Kernel.h&gt;</programlisting>
                  <para>Now, for the sake of this example, assume that a user had both -I$VJ_BASE_DIR/include/vpr and -I$VJ_BASE_DIR/include/vrj on his or her command line. If both VPR and VR Juggler had a <filename>defines.h</filename> file, there would be no way to distinguish which is which. While this is a textbook case of operator error, the naming convention we use avoids this case entirely.</para>
                  <para>The problem arises because the generated header files do not include any other headers in the project. As a result, the generated headers are not tied as tightly to the directory structure as are the static headers. Hence, the above case is not so far-fetched. It could happen very easily with an inexperienced user.</para>
               </section>
               <section>
                  <title>Module Configuration Header</title>
                  <para>Each module has a single header that includes the header file generated by running configure. The idea here is to have a single point where common actions are taken based on what comes in through the generated header. For example, based on platform settings, symbol export macros are defined in the module configuration header. This single header is then included by all the other files in the project.</para>
                  <para>The naming convention for the module configuration header is the same as that of the generated header except that the word <quote>Config</quote> is used instead of <quote>Defines</quote>. The reasoning for this convention is similar to that of the generated header, but in this case, at least one other file fromthe project is being included. Namely, the generated header file is always included on the first (non-comment) line of this header file. We decided long ago that the name <filename>Config.h</filename> was too common and needed an extra bit of uniqueness. Again, this is done to prevent user errors.</para>
               </section>
               <section>
                  <title>Data Directory</title>
                  <para>In VR Juggler 2.0, the installation of multiple modules must be managed so that one module's (optional) extra data does not conflict with that of another module. All data must be installed into the directory <filename>$(prefix)/share</filename> (to use some <command>make</command>(1) notation). To prevent conflicts with other modules (and with other software that may already exist on the target machine), each module must name a project data directory (the variable <varname>$(projdatadir)</varname> is used to store this in the makefiles). In most cases, the unique directory should be the name of the project in lowercase letters with no spaces. For example, the directory for JCCL would be <filename>$(prefix)/share/jccl</filename>, and the directory for VR Juggler would be <filename>$(prefix)/share/vrjuggler</filename>.</para>
               </section>
            </section>
            <section>
               <title>Installation Hierarchy</title>
               <para></para>
            </section>
         </section>
         <section id="configure.pl.section">
            <title><filename>configure.pl</filename></title>
            <indexterm zone="configure.pl.section">
               <primary>configure.pl</primary>
            </indexterm>
            <indexterm zone="configure.pl.section">
               <primary>configure.pl</primary>
               <secondary>design of</secondary>
            </indexterm>
            <para>The script <filename>configure.pl</filename> is a Perl script written to act as part of a build wrapper around an arbitrary collection of software modules. The modules are linked through some sort of (conceptual) <glossterm linkend="gloss.dependency-graph">dependency graph</glossterm>, in this case specified by a simple configuration file (see <xref linkend="build.cfg.file.section"/>). <filename>configure.pl</filename> reads the configuration file and proceeds to configure the individual modules in an order that satisifies the dependencies. Along the way, environment variables are set or extended so that each subsequent module is configured with the correct settings. The processes of managing the dependencies and performing the configuration are the topics of this section.</para>
            <section id="build.cfg.file.section">
               <title>Build Configuration File</title>
               <indexterm zone="configure.pl.section">
                  <primary>configure.pl</primary>
                  <secondary>configuration file</secondary>
               </indexterm>
               <indexterm>
                  <primary>juggler.cfg</primary>
               </indexterm>
               <para>Before explaining how <filename>configure.pl</filename> manages its dependencies, it will be helpful to understand the role played by the configuration file from which the dependencies are read. In the VR Juggler build system, the file is called <filename>juggler.cfg</filename>, and it is located in the top-level source directory. At a very high level, the configuration file defines one or more modules that must be configured and compiled. The modules may be independent of each other, or they may form a dependency graph. In the latter case, one module states that it depends on one or more other modules. The following code block shows an example of this:</para>
               <indexterm zone="build.cfg.basic.example">
                  <primary>juggler.cfg</primary>
                  <secondary>basic format</secondary>
                  <tertiary>example of</tertiary>
               </indexterm>
               <programlistingco id="build.cfg.basic.example">
                  <areaspec>
                     <areaset coords=" " id="build.cfg.module.lines">
                        <area coords="1 60" id="build.cfg.module.line.VPR"/>
                        <area coords="7 60" id="build.cfg.module.line.Tweek"/>
                     </areaset>
                     <areaset coords=" " id="build.cfg.dirs">
                        <area coords="3 60" id="build.cfg.dir0"/>
                        <area coords="4 60" id="build.cfg.dir1"/>
                        <area coords="10 60" id="build.cfg.dir3"/>
                     </areaset>
                     <area coords="9 60" id="build.cfg.depend.Tweek-VPR"/>
                  </areaspec>
                  <programlisting>module VPR
{
   external;
   modules/vapor;
}

module Tweek
{
   depend VPR;
   modules/tweek;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="build.cfg.module.lines">
                        <para>These lines declare two modules named <quote>VPR</quote> and <quote>Tweek</quote> respectively.</para>
                     </callout>
                     <callout arearefs="build.cfg.dirs">
                        <para>These lines list directories upon which the containing module depends. Each of these directories must contain a script called <filename>configure</filename> that can be executed. This method of listing dependencies requires explicit paths, and it helps greatly if those dependencies exist within the local source tree.</para>
                     </callout>
                     <callout arearefs="build.cfg.depend.Tweek-VPR">
                        <para>This line indicates that the Tweek module depends on the VPR module. Here, note that <symbol>depend</symbol> is a keyword with special significance. In effect, the VPR module is included inside the Tweek module definition so that it picks up all of VPR's dependencies.</para>
                     </callout>
                  </calloutlist>
               </programlistingco>
               <para>Going deeper into the module definition, we find that environment variables can be set with each directory listing using a comma-separated list. These variables provide extra information about the configuration environment after the configure script has completed successfully. To illustrate this, we extend the above example as follows:</para>
               <indexterm zone="build.cfg.envvars.example">
                  <primary>juggler.cfg</primary>
                  <secondary>with environment variables</secondary>
                  <tertiary>example of</tertiary>
               </indexterm>
               <programlistingco id="build.cfg.envvars.example">
                  <areaspec>
                     <areaset coords=" " id="build.cfg-env.dirs">
                        <area coords="4 75" id="build.cfg-env.dir1"/>
                        <area coords="10 75" id="build.cfg-env.dir3"/>
                     </areaset>
                  </areaspec>
                  <programlisting>module VPR
{
   external;
   modules/vapor: VPR_CONFIG=vpr-config, VPR_BASE_DIR=instlinks;
}

module Tweek
{
   depend VPR;
   modules/tweek: TWEEK_CONFIG=tweek-config, TWEEK_BASE_DIR=instlinks;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="build.cfg-env.dirs">
                        <para>As before, these lines list directories upon which the containing module depends. This time, we have added environment variable settings for the variables <varname>$VPR_CONFIG</varname>, <varname>$VPR_BASE_DIR</varname>, <varname>$TWEEK_CONFIG</varname>, and <varname>$TWEEK_BASE_DIR</varname>.</para>
                     </callout>
                  </calloutlist>
               </programlistingco>
               <para>While any environment variable can be set in the configuration file, those shown above have special significance<footnote>
                     <para>The fact that any variable can be set but that some are treated as special cases is a deficiency in the design of <filename>configure.pl</filename>. The current use was put together out of necessity to provide the script with extra information needed for proper execution of each module's Autoconf-generated configure script.</para>
                  </footnote>. Those variables ending in <symbol>_CONFIG</symbol> set the corresponding environment variable to include the full path to the named file (despite the fact that the full path is not given in the assignment). The path is constructed using the associated directory dependency. This directory is also added to the script's execution path. This extra little bit is needed so that a given <filename>-config</filename> script can be executed by another <filename>-config</filename> script if necessary. (The details about why all of this is necessary are discussed in <xref linkend="config.scripts.section"/>.)</para>
               <para>Those variables ending in <symbol>_BASE_DIR</symbol> define the installation directory for the given module. In the VR Juggler build system, this is necessary for dependent modules to find the headers and libraries they need to compile. (Again, more information about this is given in <xref linkend="config.scripts.section"/>.) Once again, the value being assigned has special significance. If the value is the token <token>instlinks</token>, it is taken to mean that the <emphasis>full path</emphasis> to the installed module is in a directory relative to the current directory called <filename>instlinks</filename><indexterm>
                     <primary>instlinks</primary>
                  </indexterm>. Any other value is used verbatim as the value of the environment variable.</para>
            </section>
            <section>
               <title>Dependency Management</title>
               <para>Dependencies within modules are maintained using a simple Perl data structure in the <classname>JugglerModule</classname> class. Parsing the configuration file results in instantiation of this data structure. There is one such instance for each module defined. Each instance contains an array of <classname>ModuleDependecy</classname> objects. Steps are taken to ensure that there is no duplication of dependencies within a single <classname>JugglerModule</classname> instance.</para>
            </section>
         </section>
         <section id="config.scripts.section">
            <title>The <filename>*-config</filename> Scripts and the <filename>*.m4</filename> Macro Files</title>
            <para>The various <filename>*-config</filename> scripts (<filename>vpr-config</filename>, <filename>tweek-config</filename>, <filename>vrjuggler-config</filename>, etc.) play a vital role in the design of the global build. Unfortunately, this is also where the global build gets complex. Here, code that is intended for use by users of VR Juggler and associated modules is put to use by the code that compiles everything. It makes use of a strict set of behaviors wherein various environment settings and command-line options form a hierarchy of preferences and fallbacks. If anything goes wrong with a user's configuration process, it is almost always related to a <filename>.m4</filename> file or a <filename>-config</filename> script giving unexpected results because of a misused command-line option or a <quote>dirty</quote> environment.</para>
            <section>
               <title>A Typical <filename>-config</filename> Script</title>
               <indexterm>
                  <primary>-config script</primary>
                  <secondary>design of</secondary>
               </indexterm>
               <para>We will now examine a typical <filename>-config</filename> script. We will not focus on any script in particular, but instead, we will describe the fundamental concepts and requirements shared by all implementations. Readers interested in implementations to use as references should consider the following:</para>
               <itemizedlist>
                  <listitem>
                     <para><filename>vpr-config</filename><indexterm>
                           <primary>vpr-config</primary>
                        </indexterm>: This is the most basic <filename>-config</filename> script. It has no external dependencies, and it only deals with one library.</para>
                  </listitem>
                  <listitem>
                     <para><filename>tweek-config</filename><indexterm>
                           <primary>tweek-config</primary>
                        </indexterm>: This script depends on <filename>vpr-config</filename> for proper execution, and it deals with some interesting special cases. Namely, it must be able to inform callers about information relating to C++, Java, and IDL. This script deals with one C++ library and multiple Java libraries distributed as <glossterm linkend="gloss.jar-file">JAR files</glossterm>.</para>
                  </listitem>
                  <listitem>
                     <para><filename>vrjuggler-config</filename><indexterm>
                           <primary>vrjuggler-config</primary>
                        </indexterm>: This script is interesting because it has the most dependencies (it depends on <filename>vpr-config</filename>, <filename>tweek-config</filename>, <filename>jccl-config</filename><indexterm>
                           <primary>jccl-config</primary>
                        </indexterm>, <filename>gadgeteer-config</filename><indexterm>
                           <primary>gadgeteer-config</primary>
                        </indexterm>, and <filename>sonix-config</filename><indexterm>
                           <primary>sonix-config</primary>
                        </indexterm>) and because it deals with multiple libraries (<filename>libJuggler</filename>, <filename>libJuggler_ogl</filename>, and <filename>libJuggler_pf</filename>).</para>
                  </listitem>
               </itemizedlist>
               <para>To proceed with the abstract discussion, we will now describe the job that must be performed by all <filename>-config</filename> scripts. We then explain how external dependencies are managed. We conclude with a discussion of how a <filename>-config</filename> script is generated as part of the configuration process.</para>
               <section>
                  <title>The Job</title>
                  <indexterm>
                     <primary>-config script</primary>
                     <secondary>job of</secondary>
                  </indexterm>
                  <para>The job of any <filename>-config</filename> script is simple: provide the information needed to compile against the associated library. This information can work in the context of building a higher level library or an application. The basic information that must be provided is as follows:</para>
                  <itemizedlist>
                     <listitem>
                        <para>Module version number</para>
                     </listitem>
                     <listitem>
                        <para>C++ compiler flags including header paths and compiler-specific options such as <option>-fexceptions</option> or <option>-LANG:std</option></para>
                     </listitem>
                     <listitem>
                        <para>C++ linker flags separated into two categories:</para>
                        <orderedlist>
                           <listitem>
                              <para>The basic list of libraries that are distributed with the module in question</para>
                           </listitem>
                           <listitem>
                              <para>The complete list of external dependencies needed to link an application</para>
                           </listitem>
                        </orderedlist>
                     </listitem>
                     <listitem>
                        <para>Static linking options</para>
                     </listitem>
                     <listitem>
                        <para>Profiled library linking options (if profiled libraries are available)</para>
                     </listitem>
                  </itemizedlist>
                  <para>Other information may be provided as necessary (see <filename>tweek-config</filename><indexterm>
                        <primary>tweek-config</primary>
                     </indexterm> and <filename>jccl-config</filename><indexterm>
                        <primary>jccl-config</primary>
                     </indexterm>, for example).</para>
               </section>
               <section>
                  <title>External Dependencies</title>
                  <indexterm>
                     <primary>-config script</primary>
                     <secondary>dependency management</secondary>
                  </indexterm>
                  <para>In the Juggler Project, we use the <filename>-config</filename> scripts in an interesting manner. A given script, say <filename>gadgeteer-config</filename><indexterm>
                        <primary>gadgeteer-config</primary>
                     </indexterm>, will call all the <filename>-config</filename> scripts of the modules on which it depends. The collected output is compressed and returned to the user. In this way, we avoid trying to manage all the dependency information in every module. Instead, we rely on each module to report its information correctly. Then, the highest level module only has to collect it and print it out.</para>
                  <para>The key to this functionality is that all the <filename>-config</filename> scripts can be found in the user's path. Furthermore, because our <filename>-config</filename> scripts are written in Perl, we have easy access to the path used to invoke each script. (This is actually a side effect of the scripts being in the user's path, and the path information would be available regardless of the scripting language. Perl just makes it easy to extract and operate on the given information.)</para>
                  <para>The dependencies only come into play for certain information requests. Those requests are the following:</para>
                  <itemizedlist>
                     <listitem>
                        <para>C++ flags (<option>--cxxflags</option>)</para>
                     </listitem>
                     <listitem>
                        <para>Include paths (<option>--include</option>)</para>
                     </listitem>
                     <listitem>
                        <para>Basic libraries (<option>--libs</option>)</para>
                     </listitem>
                     <listitem>
                        <para>External dependency libraries (<option>--extra-libs</option>)</para>
                     </listitem>
                  </itemizedlist>
                  <para>Each of the above iteratively calls the <filename>-config</filename> script(s) from the depdency module(s) using at least a subset of the arguments specified by the user on the command line. One additional argument is given that reduces the amount of output: <option>--min</option>. This causes each script to print out only the minimal information needed for compiling. The motivation for doing this is to keep the compile lines short whenever possible.</para>
               </section>
               <section>
                  <title>Script Generation</title>
                  <indexterm>
                     <primary>-config script</primary>
                     <secondary>generation of</secondary>
                  </indexterm>
                  <para>Finally, we explain the last detail relating to all <filename>-config</filename> scripts used in the Juggler Project: script generation. As part of the global build, all these scripts must be generated at configuration time. This is necessary for each subsequent module to be configured correctly. That means that each module's configure script is making use of <quote>external</quote> <filename>-config</filename> scripts to get command-line arguments and version information. This allows the use of pre-existing installations of dependencies. For example, Gadgeteer depends on JCCL and VPR. Normally, it would satisfy those dependencies using source from the same tree, but a user may already have JCCL and VPR built and installed. By setting up his or her path correctly, <filename>vpr-config</filename><indexterm>
                        <primary>vpr-config</primary>
                     </indexterm> and <filename>jccl-config</filename><indexterm>
                        <primary>jccl-config</primary>
                     </indexterm> can be found, and Gadgeteer can be built using the existing installations.</para>
                  <para>As of this writing, there are no hard and fast rules regarding script generation other than the fact that they must be generated as part of module configuration. The prevailing convention within a given <filename>configure.in</filename> is to make separate <glossterm linkend="gloss.substitution-variable">substitution variables</glossterm> used only in the <filename>-config.in</filename> template file. That is to say that these variables are separate from those used in template makefiles and other <filename>.in</filename> templates. The separation is done through syntax alone. Those variables that are substituted in the generation of a <filename>-config</filename> script are spelled using lowercase letters exclusively. Other substitution variables are spelled using all uppercase letters.</para>
                  <para>Again, this is not a hard and fast rule. Indeed, some variables are shared between all files (for example, <varname>$USE_GCC</varname> or <varname>$MAJOR_VERSION</varname>). In general, such exceptions are allowed because there is no difference in usage between a <filename>-config</filename> script and a generated makefile. The important distinctions arise with compiler and linker flags. In particular, there are some flags that should only be used in the process of building a given module but should not be exposed to users. An example is the MIPSpro <option>-Woff</option> flag that is used to disable compile-time warnings. Exporting this option would force users to disable the same warnings whether they want to or not. Essentially, it is up to the module build system author to use good judgement when deciding what to export and what to use internally.</para>
                  <para>To summarize, the separation of the substitution variables is done for two reasons:</para>
                  <orderedlist>
                     <listitem>
                        <para>To manage potential differences in semantics between module compilation and module use.</para>
                     </listitem>
                     <listitem>
                        <para>To make it clear to readers of the relevant files which variables are used for which purpose.</para>
                     </listitem>
                  </orderedlist>
                  <para>To date, this mechanism has worked well (at least for those few who know about it). In one case, failure to follow this convention caused compilation of a module to break because a linker variable was serving double duty. This variable was setting internal linker options and forcing the use of those same options for external code.</para>
               </section>
            </section>
            <section>
               <title>A Typical <filename>.m4</filename> File</title>
               <indexterm>
                  <primary>.m4 file</primary>
                  <secondary>design of</secondary>
               </indexterm>
               <para>With an understanding of what information a <filename>-config</filename> file provides, we can move on to the m4 macros that make use of those files at configuration time. Each module in the Juggler Project has a corresponding m4 macro suitable for use within an Autoconf <filename>configure.in</filename> file. For example, Gadgeteer has a macro called <function>GADGETEER_PATH</function>. This macro is used in VR Juggler's <filename>configure.in</filename> to find a usable Gadgeteer installation.</para>
               <para>The basic concept behind all these macros is the same: provide a way for a configure script to detect a usable installation. The way this is done is fairly straightforward. The basic step-by-step process is as follows:</para>
               <orderedlist>
                  <listitem>
                     <para>Find the module's <filename>-config</filename> script. If the script cannot be found, execute the user-specified failure steps and <quote>return</quote><footnote>
                           <para>Actually, these macros do not return because the code is inlined. Moreover, the user-specified failure steps may include halting the configure script and exiting with failure status.</para>
                        </footnote>.</para>
                  </listitem>
                  <listitem>
                     <para>Using the <filename>-config</filename> script, get the version of the installation and compare it against the user-specified minimum required version.</para>
                  </listitem>
                  <listitem>
                     <para>If the version is sufficient, execute the user-specified success steps and set variables for compiler and linker arguments using the <filename>-config</filename> script. If the version comparison fails, execute the user-specified failure steps and <quote>return</quote>.</para>
                  </listitem>
               </orderedlist>
               <para>We now proceed into the details of a typical <filename>.m4</filename> file. First, we will cover the mechanism used to deal with paths to installations. Then, we explain what variables must be set by a module's m4 macro.</para>
               <section>
                  <title>Path Setting Preferences</title>
                  <para>The most complex part about understanding the Juggler Project <filename>.m4</filename> files is the management of path setting preferences. The path in question is the path to the installed module. The installation may be on the local file system, or it may exist as a developer pseudo-installation (refer to <xref linkend="instlinks.section"/> for more information on that topic). The specification of that path by the user is where we now direct our interest. The following list gives the path setting preferences in order of decreasing preference (i.e., the first has highest precedence, and the last has lowest precedence):</para>
                  <orderedlist>
                     <listitem>
                        <para>The <varname>_CONFIG</varname> environment variable which gives the full path to the module's <filename>-config</filename> script. The name of the environment depends on the specific <filename>.m4</filename> file. For example, <filename>vpr.m4</filename> checks for <varname>$VPR_CONFIG</varname>. In general, the environment variable name should match the name of the <filename>-config</filename> script except in capitalization and the use of an underscore (_) instead of a hyphen (-).</para>
                     </listitem>
                     <listitem>
                        <para>The command-line argument <option>--with-&lt;module&gt;-exec-prefix</option> which specifies the directory containing the <filename>-config</filename> script. Here, the string <literal>&lt;module&gt;</literal> depends on the way the <filename>.m4</filename> file is written to declare accepted command-line arguments.</para>
                     </listitem>
                     <listitem>
                        <para>The command-line argument <option>--with-&lt;module&gt;-prefix</option> which specifies the directory containing the full module installation. The named directory must contain a <filename>bin</filename> subdirectory, and this subdirectory must contain the module's <filename>-config</filename> script.</para>
                     </listitem>
                     <listitem>
                        <para>The module's <varname>_BASE_DIR</varname> environment variable. The directory named by the environment variable must contain a <filename>bin</filename> subdirectory that in turn contains the module's <filename>-config</filename> script.</para>
                     </listitem>
                     <listitem>
                        <para>The user's path which must include the directory that contains the module's <filename>-config</filename> script.</para>
                     </listitem>
                  </orderedlist>
                  <para>The magic that happens in <command>configure.pl</command> is a result of setting the appropriate <varname>_CONFIG</varname> environment variable and extending the path to include the various module directories in the build tree. Through the combination of these steps, a given <filename>-config</filename> script is found using the <varname>_CONFIG</varname> environment variable, and any other <filename>-config</filename> scripts it needs are found using the path. For each module that is built, the environment in which <command>configure.pl</command> runs is extended. Refer back to <xref linkend="build.cfg.file.section"/> for information about how the necessary file and environment variable names are provided to <command>configure.pl</command>.</para>
               </section>
               <section>
                  <title>Variables Defined</title>
                  <para>Upon successful complection of step 3 (see above), there are several shell variables defined for the calling code to use. Typically, these variables are concatenated with other variables to form the full set of options passed to the compiler and the linker. In order to maintain onsistency across all the <filename>.m4</filename> files, it is important to know what variables must be defined and why.</para>
                  <para>First, the variables can be separated into two broad categories: minimal and maximal. The basic idea with minimal versus maximal flags is to allow the user some flexibility in composing the full command-line options. The minimal variables provide only the minimum amount of information needed for compiling. No dependency information is included. For example, such settings usually include one or two header path extensions (<option>-I</option> options) and mandatory compiler flags such as <option>-LANG:std</option>. The maximal variables, on the other hand, include all the information needed for compiling including dependency data. More concretely, the minimal C++ compiler flags for Gadgeteer would give the header path for the Gadgeteer headers and any mandatory compiler flags. The maximal C++ compiler flags would include the minimal information as well as flags relating to JCCL, Tweek, and VPR (in that order). The same would be true for linker flags. To summarize, the minimal variables must be mixed with other minimal variables if the module has dependencies; the maximal variables can stand on their own.</para>
                  <para>Within the minimal and maximal categories, there are two more categories: compiler flags and linker flags. Based on the discussion above, this distinction should be fairly obvious. This distinction is made to deal with platforms where the compiler is not used to perform the link stage. Since some compilers can call the linker as necessary, <emphasis>linking</emphasis> flags<footnote>
                        <para>Note the distinction between <emphasis>linker</emphasis> flags (flags for the linker program) and <emphasis>linking</emphasis> flags (flags used to link object files).</para>
                     </footnote> suitable for use with the compiler are provided. The distinction is made by the variable name. Linking flags that can be passed to the compiler have <varname>_CC_</varname> in their name; linking flags for the linker have <varname>_LD_</varname> in their name.</para>
                  <para>Continuing with the subdivision, the linking flags are divided into two categories: static and dynamic. This is done to allow static linking of one or more libraries instead of dynamic linking. The usual default would be dynamic linking, and the variable names reflect that. Those variables that contain static linking flags have <varname>_STATIC_</varname> in their names.</para>
               </section>
            </section>
         </section>
         <section id="instlinks.section">
            <title>The Developer Installation</title>
            <indexterm>
               <primary>developer installation</primary>
            </indexterm>
            <indexterm>
               <primary>instlinks</primary>
               <see>developer installation</see>
            </indexterm>
            <para>At various times in the history of the VR Juggler project, the developer <quote>pseudo-installation</quote> has been a topic of great controversy. Questions (or arguments, depending on your perspective) regarding its usefulness and its differences from a release installation come up repeatedly. The reason for its existence is quite simple: to simplify the lives of developers. The differences between the developer installation are also fairly simple. In a nutshell, a developer installation uses debugging libraries by default and links applications statically<indexterm>
                  <primary>developer installation</primary>
                  <secondary>differences from release</secondary>
               </indexterm>. A release installation, on the other hand, uses optimized libraries by default and links applications dynamically. The reasoning behind this is a little more difficult to nail down, and for that reason, we will say that it is beyond the scope of the document.</para>
            <para>To satisfy the only goal of the developer installation (simplification of developers' lives), the developer installation must act exactly like a release installation, but it must be inside the build tree. The developer installation is created automatically as part of the build process, and ideally, its construction is faster than that of a full release installation. In any case, if all goes well, a developer can treat this pseudo-installation as if it were a real installation for the purposes of running tests.</para>
            <para>Prior to early August 2002, the developer installation was created separately from a release installation. This was done through the use of symlinks on UNIX-based platforms and file copies on Win32. Since August 2002, the developer installation still uses symlinks or file copies in the same manner, but there is no longer a separation between creation of the developer installation and the release installation. In other words, the release installation is used to make the developer installation, but it is directed to install into the build tree.</para>
            <para>The decision to use symlinks or file copies is based on the host platform and on the use of the '<literal>links</literal>' target that every module must define. Using a custom Perl script, <command>bsd-install.pl</command><indexterm>
                  <primary>bsd-install.pl</primary>
               </indexterm>, written to be fully compatible with BSD <command>install</command>(1), symlinks may be created instead of using file copies. (The <command>bsd-install.pl</command> script comes with Doozer++<indexterm>
                  <primary>Doozer++</primary>
               </indexterm> 1.5 and beyond.) Within the script, a test is performed to determine if the host platform is a Win32 system. If so, copies are always used because there are no symlinks on Win32 file systems. All of these decisions had been made in each module's build system, but they have since been offloaded into <command>bsd-install.pl</command>. This is in keeping with the Doozer++ goal of centralizing complexity.</para>
         </section>
         <section>
            <title>Future Goals</title>
            <para>At one time, there was a long-term goal for this global build script, or <quote>project builder</quote>. In conjunction with <command>cvs-gather.pl</command>, a semi-arbitrary collection of software packages would be downloaded and compiled. The commonality between them would be the use of configure scripts that would be invoked by the project builder. The dependencies would be specified through some configuration file, possibly written in XML, that would be constructed on the fly based on the <command>cvs-gather.pl</command> dependency file.</para>
            <para>These lofty plans have not materialized, and it is unclear whether the need for such a tool still exists. Nonetheless, the idea of a highly generalized project builder played a key role in the way that <command>configure.pl</command> was written. In particular, its highly generic nature was motivated by the potential for downloading arbitrary source code and running a configure script. The makefile generated by <command>configure.pl</command> initially followed this goal, too, but it has since had its scope narrowed to deal with the specific conventions of the VR Juggler project.</para>
         </section>
      </chapter>
      <chapter id="doc.build.chapter">
         <title>The Documentation Build</title>
         <para>The documentation for the individual modules is maintained separately from the source code build. This is done primarily because writing code to DocBook and related software would take too much time and gain us very little. For the most part, the Juggler Project documentation is intended for posting on the website. As such, the build environment is much more controlled than one that is provided for (easy?) use by the general public. The documentation build is still configurable, but in a different, less automatic method than what is used to build the source tree. This chapter explains the rules of the documentation build and how to configure it for use outside the VRAC lab.</para>
         <section>
            <title>The Rules</title>
            <para>Any module with DocBook-based documentation can be added to the documentation build. As with the source code build, there are rules that must be followed. With this smaller, less complicated build system, there are fewer things to deal with.</para>
            <section id="doc.build.req.targets.section">
               <title>Required Makefile Targets</title>
               <para>Within this subsection, we present the full list of targets that must be implemented for correct operation within the documentation build. As a reference, refer to the file <filename>juggler/Makefile.docs</filename>. This list, containing all of two targets, is as follows:</para>
               <variablelist>
                  <varlistentry>
                     <term>docs</term>
                     <listitem>
                        <para>This target builds the documentation. It is up to each makefile to determine how much is built. In general, the makefiles are set up to generate HTML, PDF, and PostScript. This output may come from DocBook XML source or from output generated by Doxygen. Other tools may be used, but these two are the favored generators at this time.</para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term>install-docs</term>
                     <listitem>
                        <para>This installs the documentation built by the '<literal>docs</literal>' target. By default, the documentation installation uses <filename>$HOME/public_html/jugglerweb</filename> as the base prefix. This truly reflects the intended use of this build system. (To redirect the installed output, simply change the setting for <varname>$(webroot)</varname> in <filename>juggler/Makefile.docs</filename>.)</para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <para>Targets such as '<literal>clean</literal>' and '<literal>clobber</literal>' are needed as well, but those makefiles that include docbook.mk get them for free. If a documentation generating makefile is not using docbook.mk, it must make its own '<literal>clean</literal>' and '<literal>clobber</literal>' targets.</para>
            </section>
            <section>
               <title>Installation Hierarchy</title>
               <para>The individual documentation building makefiles are expected to behave when installing the generated documentation. That is, they should install to a subdirectory of <varname>$(webroot)</varname> that reflects the appropriate project. In many cases, the installation hierarchy should also reflect the version of the software against which the documentation was written.</para>
               <para>Each makefile is responsible for creating its own installation hierarchy and for installing any related, external files. The documentation build offers some automation to help with this, but its abilities are limited. At this time, the documentation build can be directed to install the image fiels that come with the DocBook stylesheets and any local images that the documentation needs.</para>
            </section>
         </section>
         <section>
            <title>Configuration and Customization</title>
            <para>At this time, most of the documentation in the Juggler Project is written using DocBook. Because of that, the settings for building documents from DocBook files are centralized in the file <filename>juggler/doc/docbook.mk</filename>. This file is parameterized to the extreme so that including makefiles can override its default settings easily. Usually, makefiles that include docbook.mk direct the build to use OpenJade, Saxon, or Xalan to process the DocBook input and PassiveTeX, FOP, or XEP to create PDF files. Further configuration can be done that chooses different versions or installations of the DocBook stylesheets, Saxon, Xalan, FOP, etc. The following is the makefile used to generate HTML and PDF versions of this document:</para>
            <programlistingco>
               <areaspec>
                  <areaset coords=" " id="docs.makefile.req.targets">
                     <area coords="3 70" id="doc.makefile.docs.target"/>
                     <area coords="4 70" id="doc.makefile.install-docs.target"/>
                  </areaset>
                  <area coords="6 70" id="docs.makefile.name"/>
                  <area coords="8 70" id="docs.makefile.src.xml"/>
                  <area coords="9 70" id="docs.makefile.gen.html"/>
                  <area coords="10 70" id="docs.makefile.gen.pdf"/>
                  <area coords="12 70" id="docs.makefile.gen.tool"/>
                  <areaset coords=" " id="docs.makefile.install">
                     <area coords="15 70" id="docs.makefile.webroot"/>
                     <area coords="16 70" id="docs.makefile.instdir"/>
                     <area coords="18 70" id="docs.makefile.prefix"/>
                     <area coords="19 70" id="docs.makefile.install-files"/>
                  </areaset>
                  <area coords="21 70" id="docs.makefile.db-images"/>
                  <areaset coords=" " id="docs.makefile.deps">
                     <area coords="23 70" id="docs.makefile.html.deps"/>
                     <area coords="24 70" id="docs.makefile.pdf.deps"/>
                  </areaset>
                  <area coords="26 70" id="docs.makefile.docbook.mk"/>
               </areaspec>
               <programlisting>default: html

docs: html chunk-html pdf
install-docs: install-html install-chunk-html install-pdf

NAME=		build.system

XML_FILES=	$(NAME).xml
HTML_FILES=	$(NAME).html
PDF_FILES=	$(NAME).pdf

XSLT_TOOL=	Saxon

# Fill these in!!  Together, they make up the installation prefix.
webroot=	$(HOME)/public_html/jugglerweb
instdir=	docs/juggler.build.system

prefix=		$(webroot)/$(instdir)
INSTALL_FILES=	$(webroot)/base_style.css

NEED_DB_IMAGES=	1

$(NAME).html: $(NAME).xml
$(NAME).pdf: $(NAME).xml $(NAME).fo

include ../docbook.mk
</programlisting>
               <calloutlist>
                  <callout arearefs="docs.makefile.req.targets">
                     <para>These are the required targets that all makefiles in the documentation build must have. Refer to <xref linkend="doc.build.req.targets.section"/> for more information on these targets.</para>
                  </callout>
                  <callout arearefs="docs.makefile.name">
                     <para>This variable lists the base name of the source document. Since the generated documents differ only in final extension, this variable is used internally as the basis for the name of the source file and the generated documents. If there are multiple source documents, multiple varables (such as <varname>$(NAME1)</varname>, <varname>$(NAME2)</varname>, etc.) would be used.</para>
                  </callout>
                  <callout arearefs="docs.makefile.src.xml">
                     <para>This variable lists all the DocBook XML source files that will be used as input to the XSLT processor. Each source file should have corresponding output files, also listed in this makefile.</para>
                  </callout>
                  <callout arearefs="docs.makefile.gen.html">
                     <para>The source document can be rendered as HTML, and so this variable is used to list the output file. All HTML output files must be listed in this variable. The names must reflect the non-chunked output file names. Chunked HTML output is handled separately since the file names cannot be listed easily in this context.</para>
                  </callout>
                  <callout arearefs="docs.makefile.gen.pdf">
                     <para>Similar to <varname>$(HTML_FILES)</varname>, this lists the PDF file(s) that can be rendered from the XML input. This has the same semantics as <varname>$(HTML_FILES)</varname>.</para>
                  </callout>
                  <callout arearefs="docs.makefile.gen.tool">
                     <para>The variable <varname>$(XSLT_TOOL)</varname> is used to tell <filename>docbook.mk</filename> which XSLT processor should be used. The default tool is Xalan, but Saxon can be used instead, as shown above.</para>
                  </callout>
                  <callout arearefs="docs.makefile.install">
                     <para>These variables deal with the installation process. The critical variables are <varname>$(webroot)</varname> and <varname>$(prefix)</varname>. The variable <varname>$(webroot)</varname> will be overridden by the calling makefile (the top-level documentation makefile) to provide an alternate base directory as necessary. Setting it here provides a good default value to use when writing documentation and testing rendering. The <varname>$(prefix)</varname> variable is what tells <filename>docbook.mk</filename> where the document(s) will be installed. It must be set in order for an installation to succeed. Finally, <varname>$(INSTALL_FILES)</varname> provides any extra files that must be installed. In this case, we want to copy over the common stylesheet used by the rest of the VR Juggler website.</para>
                  </callout>
                  <callout arearefs="docs.makefile.db-images">
                     <para>Defining the variable <varname>$(NEED_DB_IMAGES)</varname> informs <filename>docbook.mk</filename> that the DocBook images are needed by rendered versions of the source document(s). Symlinks will be created as part of the rendering process, and the images directory will be copied over during installation.</para>
                  </callout>
                  <callout arearefs="docs.makefile.deps">
                     <para>These lines simply list dependencies as a way to help <command>make</command>(1) in doing its job effectively. Here, the <varname>$(NAME)</varname> variable again plays a useful role.</para>
                  </callout>
                  <callout arearefs="docs.makefile.docbook.mk">
                     <para>Finally, the last line (and it should always be the last line) includes the <filename>docbook.mk</filename> makefile stub. All of the settings above have an effect on the way that the targets defined in <filename>docbook.mk</filename> behave.</para>
                  </callout>
               </calloutlist>
            </programlistingco>
         </section>
      </chapter>
   </part>
   <part id="extension.part">
      <title>Extension</title>
      <partintro>
         <epigraph>
            <attribution>Miguel de Cervantes, Don Quixote (English translation), opening of Chapter VIII</attribution>
            <para>At this point they came in sight of thirty forty windmills that there are on plain, and as soon as Don Quixote saw them he said to his squire, <quote>Fortune is arranging matters for us better than we could have shaped our desires ourselves, for look there, friend Sancho Panza, where thirty or more monstrous giants present themselves, all of whom I mean to engage in battle and slay, and with whose spoils we shall begin to make our fortunes; for this is righteous warfare, and it is God's good service to sweep so evil a breed from off the face of the earth.</quote></para>
         </epigraph>
         <para>In this part, we discuss the topic that seems most fearsome to the majority of Juggler team members: build system extension. While this does not have to be a complex topic, most people shy away from it because they do not want to spend time trying to understand any given build system. Whether anyone will even bother to read this far into this book is debatable, and this is only the second attempt in four years to write this documentation. Perhaps this time, it will be worth the effort.</para>
      </partintro>
      <chapter id="extend.global.config.chapter">
         <title>Extending the Global Configuration Script</title>
         <para></para>
      </chapter>
      <chapter id="extend.module.config.chapter">
         <title>Extending a Module's Configure Script</title>
         <para></para>
         <section>
            <title>Basic Concepts</title>
            <para></para>
         </section>
         <section>
            <title>Specific Modules</title>
            <para></para>
            <section>
               <title>Tweek</title>
               <para>Tweek is an interesting case because it contains two dinstinct yet interoperable components: a C++ API and a Java API. It is possible to use one without the other, and it is even possible to configure Tweek so that neither is compiled. Of couse, the latter is a rather odd case that usually only occurs when something went wrong during the execution of the configure script. Furthermore, Tweek can be compiled against any Java or C++ CORBA 2.3 (or newer) implementation. This is the result of using high-level CORBA standards and interfaces that allow ORBs swapped and allow ORBs from different vendors to communicate with each other.</para>
            </section>
         </section>
      </chapter>
      <chapter id="extend.module.makefile.chapter">
         <title>Extending a Module's Makefiles</title>
         <para></para>
      </chapter>
   </part>
   <appendix>
      <title>Build System Usage</title>
      <para>We can now delve into the use of the VR Juggler build system. This part is separated into two chapters: one covering the general, everyday use, and one covering more advanced topics for the most stalwart users.</para>
      <section>
         <title>General Use</title>
         <para></para>
      </section>
      <section>
         <title>Advanced Use</title>
         <para></para>
      </section>
   </appendix>
   <glossary>
      <title>Glossary</title>
      <glossdiv>
         <title>A</title>
         <glossentry id="gloss.autoconf">
            <glossterm>Autoconf</glossterm>
            <glossdef>
               <para>Blah blah</para>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.automake">
            <glossterm>Automake</glossterm>
            <glossdef>
               <para>Blah blah</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>C</title>
         <glossentry id="gloss.configure-script">
            <glossterm>configure script</glossterm>
            <glossdef>
               <para>A shell script, generated by the <command>autoconf</command> utility, that tests capabilities of common developer tools such as compilers and linkers and sets up a build environment based on the results of the tests.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>D</title>
         <glossentry id="gloss.dependency-graph">
            <glossterm>dependency graph</glossterm>
            <glossdef>
               <para>A directed, acyclic graph defining connections between components. The connections imply a dependency of the source component on the target component.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>G</title>
         <glossentry id="gloss.glue-makefile">
            <glossterm>glue makefile</glossterm>
            <glossdef>
               <para>A makefile that pulls together smaller makefiles and/or directs the compilation of a collection of makefiles in a source tree. In terms of the VR Juggler build, this usually means controlling the recursion through a source tree when building a module.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>I</title>
         <glossentry id="gloss.idl-compiler">
            <glossterm>IDL compiler</glossterm>
            <glossdef>
               <para>A software tool that reads an IDL file and generates code in a specific language (e.g., Java, C++, Smalltalk, etc.). This code may be anything, but typically, it is stub or skeleton code that is extended by user-defined code that completes the interface implementation.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>J</title>
         <glossentry id="gloss.jar-file">
            <glossterm>JAR file</glossterm>
            <glossdef>
               <para>A Java archive. These files typically contain everything needed to execute a Java application or a Java applet. They may also be used to package language-independent information such as data files or images.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>S</title>
         <glossentry id="gloss.substitution-variable">
            <glossterm>substitution variable</glossterm>
            <glossdef>
               <para>A shell variable within an Autoconf-based configure script that is substituted in a <filename>.in</filename> template file. For the variable <varname>$variable</varname>, the Autoconf <literal>@variable@</literal> syntax is used in the <filename>.in</filename> template file. This is not a formal term used in Autoconf documentation but rather a term used within the VR Juggler build system documentation to distiguish these variables from other shell variables in a configure script.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>X</title>
         <glossentry id="gloss.xslt">
            <glossterm>XSLT</glossterm>
            <glossdef>
               <para></para>
            </glossdef>
         </glossentry>
      </glossdiv>
   </glossary>
   <index/>
</book>
