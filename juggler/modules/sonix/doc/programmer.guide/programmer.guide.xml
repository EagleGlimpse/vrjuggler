<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="file://localhost/home/users/kevn/Open/juggler_xml_docs/stylesheet/docbook_ab.css" type="text/css"?>
<?morphon-document-settings
  morphon.document.settings.whitespaces.amount="3"
  morphon.document.settings.print.fixed.attributes="true"
  morphon.document.settings.stylesheetpi.autoupdate="true"
  morphon.document.settings.print.defaultvalues.attributes="false"
  morphon.document.settings.relative.systemids="2"
  morphon.document.settings.endofline.type="2"
  morphon.document.settings.whitespaces.type="indent.attr"
?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article lang="en">
   <articleinfo>
      <title>Sonix: The Juggler High Level Simple Sound Abstraction</title>
      <subtitle>Course notes for Open source VR - IEEEVR2002</subtitle>
      <authorgroup>
         <author>
            <firstname>Kevin</firstname>
            <surname>Meinert</surname>
         </author>
      </authorgroup>
      <pubdate>$Date$</pubdate>
      <address><email>kevn@vrjuggler.org</email></address>
   </articleinfo>
   <section>
      <title>Introduction</title>
      <para>Sonix is a high level abstraction for audio hardware or audio APIs, The interface to sonix is kept very very simple in order to get people up and running with sound as fast as possible... </para>
      <para>Sonix is reconfigurable allowing audio APIs to be safely swapped out at runtime without the dependant systems noticing. systems using this layer expect to be completely portable. changing sound APIs at run time will be useful so that the user can play with quality and latency differences of different hardware and different soud APIs </para>
      <para>Here is an overview of Sonix capabilities: <itemizedlist>
            <listitem>
               <para>Very simple interface.</para>
               <para>Small learning curve.</para>
            </listitem>
            <listitem>
               <para>Sound abstraction supports reconfigurability.</para>
               <para>Reconfigurations of sound resources are protected (i.e. does not break application).</para>
               <para>Changing a sound resource reflects properly in all other handles to the same resource (resources allow multiple users) </para>
            </listitem>
            <listitem>
               <para>Support for features needed by 3D virtual environments.</para>
               <para>Spacialized or ambient audio</para>
               <para>One-shot and looping sounds.</para>
            </listitem>
            <listitem>
               <para>Runs on top of some well known audio systems - <productname>OpenAL</productname>, and Multigen/Paradigm's <productname>AudioWorks</productname>. </para>
            </listitem>
         </itemizedlist></para>
   </section>
   <section>
      <title>Simple Minimalist Interface</title>
      <para>In <xref linkend="simplesonixinterface"/> we see the API for sonix (see <xref linkend="completesonixinterface"/> for the complete software architechture). The main parts that a sound programmer will use is shown, namely the <classname>snx::SoundHandle</classname> class, and the <classname>sonix</classname> singleton class. The <classname>sonix</classname> singleton class is used to start, stop and reconfigure the sound system. The <classname>snx::SoundHandle</classname> class is used to manipulate individual sounds. Both classes must be used for any sound to be heard. <figure id="simplesonixinterface" xreflabel="simplesonixinterface">
            <title>UML diagram of the sonix interface.</title>
            <mediaobject>
               <imageobject>
                  <imagedata
                    fileref = "simple.interface.uml.png"
                    format  = "PNG"
                  />
               </imageobject>
            </mediaobject>
         </figure></para>
      <para>To start the <productname>sonix</productname> system is easy (see <xref linkend="startupCode"/>). Basically the only call needed to start the system is <methodname>changeAPI()</methodname>. Currently only OpenAL and AudioWorks is supported by <productname>sonix</productname>, so you would pass one of these two strings to <methodname>changeAPI()</methodname>.<figure>
            <title>Code to startup and initialize sonix to use the OpenAL audio subsystem</title>
            <programlisting
              id     = "startupCode"
            >sonix::instance()-&gt;changeAPI( "OpenAL" );</programlisting>
         </figure></para>
      <para><methodname></methodname>To setup a sound is also straight forward as seen in <xref linkend="soundHandleSetup"/>. Here we use a <ooclass>
            <classname>snx::SoundInfo</classname>
         </ooclass> to configure the sound object, which is accessed by a <ooclass>
            <classname>snx::SoundHandle</classname>
         </ooclass>. <figure>
            <title>Code to setup a sonix sound</title>
            <programlisting
              id     = "soundHandleSetup"
            >snx::SoundInfo info;
info.filename = "crack.wav";
info.datasource = snx::SoundInfo::FILESYTEM;

snx::SoundHandle crack_sound( "crack" );
crack_sound.configure( info );</programlisting>
         </figure>To keep sonix running, you need to repeatedly call an update function called <methodname>step( float time )</methodname>. <varname>time</varname> is the amount of time since you last called <methodname>step()</methodname>, and <methodname>step()</methodname> should be called in your application's frame function (see ).<figure id="stepCode">
            <title>Call sonix::step() in your frame function</title>
            <programlisting>void frame()
{
   time_delta = getTimeChangeInSeconds(); // use a system call, or other API to get your time delta
   sonix::instance()-&gt;step( time_delta );
}</programlisting>
         </figure></para>
   </section>
   <section>
      <title>Reconfiguration</title>
      <para>Audio API abstraction for audio sound objects ontop of hardware or audio APIs, reconfigurable allowing audio APIs to be safely swapped out at runtime without the dependant systems noticing. systems using this layer expect to be completely portable. changing sound APIs at run time will be useful so that the user can play with quality and latency differences of different hardware and different soud APIs</para>
      <para></para>
   </section>
   <section>
      <title>Techinical Details / Internal Implementation</title>
      <para></para>
      <section>
         <title>Design Patterns Overview</title>
         <para>Design patterns describe simple and elegant solutions to specific problems in object oriented software design <xref linkend="Patterns"/>. When designing sonix, we used many design patterns, which were appropriate to a simple audio system <xref linkend="Gems2"/>.</para>
         <itemizedlist>
            <listitem>
               <para>Adaptor (<classname>snx::SoundImplementation</classname>) provides a common interface to the underlying sound API. </para>
            </listitem>
            <listitem>
               <para>Prototype (<classname>snx::SoundImplementation</classname>) each sound implementation can be cloned, preserving its engine setup state </para>
            </listitem>
            <listitem>
               <para>Store/plugin-method (<classname>snx::SoundFactory</classname>) each sound impl is registered with a Store. The Store allows users to select items from its inventory. The Store is also an "Abstract Factory" </para>
            </listitem>
            <listitem>
               <para>Abstract Factory (<classname>snx::SoundFactory</classname>) The Store can create new instances of the requested sound implementation. The Abstract Factory consults its Store of registered objects, and if found, makes a clone of that object (Prototype pattern). The Abstract Factory is used to configure the Bridge. </para>
            </listitem>
            <listitem>
               <para>Bridge (sonix interface class / <classname>snx::SoundImplementation</classname>) sonix class is the audio system abstraction which is decoupled from its implementation SoundImplementation. This way the two can vary independently. Bridge also facilitates run-time configuration of the sound API. </para>
            </listitem>
            <listitem>
               <para>Proxy (<classname>std::string</classname>) refer to actual sounds with a <classname>std::string</classname> Proxy. This allows you to generically control a sound for any sound API. The sonix class acts as Mediator between every Proxy method and the actual SoundImplementation Adaptor. </para>
            </listitem>
         </itemizedlist>
         <figure
           id        = "completesonixinterface"
           xreflabel = "completesonixinterface"
         >
            <title>The complete sonix interface.</title>
            <mediaobject>
               <imageobject>
                  <imagedata
                    fileref = "complete.interface.uml.png"
                    format  = "PNG"
                  />
               </imageobject>
            </mediaobject>
         </figure>
      </section>
   </section>
   <bibliography>
      <title>References</title>
      <biblioentry
        id = "Gems2"
      >
         <abbrev>Gems2</abbrev>
         <biblioset
           relation = "article"
         >
            <author>
               <surname>Patterson</surname>
               <firstname>Scott</firstname>
            </author>
            <title>Game Audio Design Patterns</title>
            <pagenums>514</pagenums>
         </biblioset>
         <biblioset
           relation = "article"
         >
            <author>
               <surname>Lewis</surname>
               <firstname>Ian</firstname>
            </author>
            <title>A Low-Level Sound API</title>
            <pagenums>559 </pagenums>
         </biblioset>
         <biblioset
           relation = "book"
         >
            <author>
               <surname>Deloura</surname>
               <firstname>Mark</firstname>
            </author>
            <title>Game Programming Gems 2</title>
            <publishername>Charles River Media </publishername>
            <pubdate>2001</pubdate>
            <copyright>
               <year>2001</year>
               <holder>Charles River Media Inc.</holder>
            </copyright>
         </biblioset>
      </biblioentry>
      <biblioentry
        id = "Patterns"
      >
         <abbrev>Patterns</abbrev>
         <biblioset
           relation = "book"
         >
            <author>
               <surname>Gamma</surname>
               <firstname>Erich</firstname>
            </author>
            <author>
               <surname>Helm</surname>
               <firstname>Richard</firstname>
            </author>
            <author>
               <surname>Johnson</surname>
               <firstname>Ralph</firstname>
            </author>
            <author>
               <surname>Vlissides</surname>
               <firstname>John</firstname>
            </author>
            <title>Design Patterns</title>
            <subtitle>Elements of Reusable Object-Oriented Software</subtitle>
            <publishername>Addison Wesley </publishername>
            <pubdate>1995</pubdate>
            <copyright>
               <year>1995</year>
               <holder>Addison Wesley Longman, Inc</holder>
            </copyright>
         </biblioset>
      </biblioentry>
   </bibliography>
</article>
