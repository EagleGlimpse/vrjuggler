/* PropertyDesc.java
 */

package VjConfig;

import java.util.StringTokenizer;
import java.util.Vector;
import VjConfig.ValType;
import VjConfig.DescEnum;
import java.io.*;

public class PropertyDesc {

  public String name;
  public String token;
  public String help;
  public Vector enums;
  public Vector valuelabels;
  public int num;
  public ValType valtype;

  public boolean equals(PropertyDesc d) {
    DescEnum e1, e2;
    if (!name.equalsIgnoreCase(d.name))
      return false;
    if (!token.equalsIgnoreCase(d.token))
      return false;
    if (!help.equalsIgnoreCase(d.help))
      return false;
    if (num != d.num)
      return false;
    if (!valtype.equals(d.valtype))
      return false;
    for (int i = 0; i <enums.size(); i++) {
      //CJ - missing compare code here
      try {
	e1 = (DescEnum)enums.elementAt(i);
	e2 = (DescEnum)d.enums.elementAt(i);
	if (!e1.equals(e2))
	  return false;
      }
      catch (ArrayIndexOutOfBoundsException e) {
	return false;
      }
    }
    return true;
  }

  public String toString() {
    String s = token + " " + valtype.strVal() + " " + Integer.toString(num) 
      + " \"" + name + "\"";
    /* enumerations: */

    if (valuelabels.size() > 0) {
      DescEnum e;
      s += " vj_valuelabels { ";
      for (int i = 0; i < valuelabels.size(); i++) {
	e = (DescEnum) valuelabels.elementAt(i);
	s += "\"" + e.str + "\" ";
      }
      s += "}";
    }

    if (enums.size() > 0) {
      DescEnum e;
      s += " { ";
      for (int i = 0; i < enums.size(); i++) {
	e = (DescEnum) enums.elementAt(i);
	if (valtype.equals(ValType.t_string) || 
	    valtype.equals(ValType.t_chunk))
	  s += "\"" + e.str + "\" ";
	else
	  s += e.str + "=" + e.val + " ";
      }
      s += "}";
    }
    s += " \"" + help + "\"";
    return s;
  }

  public VarValue getEnumValue(String val) throws java.util.NoSuchElementException {
    /* returns the int value associated with this enum el */
    DescEnum t;
    VarValue v;

    if (valtype.equals(ValType.t_string) || valtype.equals(ValType.t_chunk)) {
      v = new VarValue(valtype);
      v.set(val);
      return v;   // no need for translation
    }

    for (int i = 0; i < enums.size(); i++) {
      t = (DescEnum)enums.elementAt(i);
      if (t.str.equalsIgnoreCase(val)) {
	v = new VarValue(t.val);
	return v;
      }
    }
    throw new java.util.NoSuchElementException();
  }

  public String getEnumString(int val) throws java.util.NoSuchElementException {
    /* does the reverse mapping of getEnumVal - maps a value back to the
     * name of the enum entry 
     */
    DescEnum t;
    if (!valtype.equals(ValType.t_int))
      throw new java.util.NoSuchElementException();
    for (int i = 0; i < enums.size(); i++) {
      t = (DescEnum)enums.elementAt(i);
      if (t.val.getInt() == val) {
	return t.str;
      }
    }
    throw new java.util.NoSuchElementException();
  }


  public String getEnumString(float val) throws java.util.NoSuchElementException {
    /* does the reverse mapping of getEnumVal - maps a value back to the
     * name of the enum entry 
     */
    DescEnum t;
    if (!valtype.equals(ValType.t_float))
      throw new java.util.NoSuchElementException();
    for (int i = 0; i < enums.size(); i++) {
      t = (DescEnum)enums.elementAt(i);
      if (t.val.getFloat() == val) {
	return t.str;
      }
    }
    throw new java.util.NoSuchElementException();
  }


  public PropertyDesc () {
    /* creates an "empty" PropertyDesc */
    name = "";
    token = "";
    help = "";
    enums = new Vector();
    valuelabels = new Vector();
    num = 1;
    valtype = new ValType ("int");
  }


  public PropertyDesc (ConfigStreamTokenizer st) {
    /* note: line is an unparsed configchunk line.  The only 
     * assumption I'm willing to make about it is that it was
     * generated by PropertyDesc << on the C++ side.  That
     * actually lets us assume quite a bit.
     */
    enums = new Vector();
    valuelabels = new Vector();

    try {

      st.nextToken();
      token = st.sval;
      st.nextToken();
      valtype = new ValType (st.sval);
      st.nextToken();
      num = Integer.parseInt(st.sval);
      st.nextToken();
      name = st.sval;

      //System.out.println ("reading property desc: " + name + " " + token);

      st.nextToken();


      if ((st.ttype == StreamTokenizer.TT_WORD) && st.sval.equalsIgnoreCase ("vj_valuelabels")) {
	st.nextToken();
	if (st.ttype != '{') {
	  System.err.println ("Error: parsing " 
			      + token + " expected '{' after vj_valuelabels" );
	}
	/* we've got an enumeration to parse */
	st.nextToken();
	while (st.ttype != '}') {

	    //System.out.println (st.sval);

	  /* ok; st.sval is an enumeration entry, maybe with an = */
	  if (st == null) System.err.println ("foo");
	  if (st.sval == null) {
	  }
	  System.out.println ("adding value label " + st.sval);
	  valuelabels.addElement (new DescEnum(st.sval,0));
	  st.nextToken();
	}
	st.nextToken();
      }



      if (st.ttype == '{') {
      
	/* we've got an enumeration to parse */
	st.nextToken();
	int j, enumval = 0;
	float enumfloatval = 0.0f;
	int k=0;
	while (st.ttype != '}') {

	    //System.out.println (st.sval);

	  /* ok; st.sval is an enumeration entry, maybe with an = */
	  if (st == null) System.err.println ("foo");
	  if (st.sval == null) {
	  }
k++;
	  j = st.sval.indexOf('=');
	  if (j == -1) {
	    /* no explicit value */
	    enums.addElement (new DescEnum(st.sval,enumval++));
	  }
	  else {
	    /* explicit value */
	    String n = st.sval.substring(0,j);
	    if (valtype.equals(ValType.t_int)) {
	      enumval = Integer.parseInt(st.sval.substring(j+1));
	      enums.addElement (new DescEnum(n, enumval++));
	    }
	    else if (valtype.equals(ValType.t_float)) {
	      enumfloatval = Float.valueOf(st.sval.substring(j+1)).floatValue();
	      enums.addElement (new DescEnum(n, enumfloatval));
	    }
	    else {
	      System.err.println ("Only float and int enums can have " +
				  "explicit values");
	      enums.addElement (new DescEnum(st.sval,enumval++));
	    }
	  }
	  st.nextToken();
	}
	st.nextToken();
      }
      help = st.sval;

    }
    catch (IOException e) {
      System.err.println ("error in PropertyDesc constructor");
      System.err.println (e);
    }
    catch (NumberFormatException e2) {
      System.err.println ("PropertyDesc.<init>(): Invalid number format: " 
			  + st.sval);
    }
  }


//   public void getEnums (String line) {
//     System.out.println ("Line is " + line);
//     StringTokenizer st = new StringTokenizer(line, " \t");
//     //StringTokenizer st2;
//     //String tok, tok2;
//     String tok;
//     while (st.hasMoreTokens()) {
//       tok = st.nextToken();
//       enums.addElement(new DescEnum(tok));
//     }
//   }


}
