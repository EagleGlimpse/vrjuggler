<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="../../../../../../docs/stylesheet/docbook_ab.css" type="text/css"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>VR Juggler</title>
      <subtitle>Getting Started Guide</subtitle>
      <releaseinfo>1.0.0</releaseinfo>
      <pubdate>$Date$</pubdate>
   </bookinfo>
   <chapter>
      <title>Introduction</title>
      <para>This book is for people who are just getting started with VR Juggler. It will guide you through getting and installing VR Juggler, configuring your environment to use it and compiling and running a sample application.</para>
      <section>
         <title>Prerequisites</title>
         <para>The prerequisites for reading this book are minimal. They are:</para>
         <itemizedlist>
            <listitem>
               <para>Some experience with a command-line interface (i.e., a shell such as tcsh or the DOS shell)</para>
            </listitem>
            <listitem>
               <para>Creating and browsing directories </para>
            </listitem>
         </itemizedlist>
         <para>Those users who want to get more involved with VR Juggler to do more than just run applications should be aware right away of the following prerequisites: </para>
         <itemizedlist>
            <listitem>
               <para>Knowledge of C++ and object-oriented design</para>
            </listitem>
            <listitem>
               <para>Knowledge of one of VR Juggler's currently supported graphics APIs (<ulink url="http://www.opengl.org/">OpenGL</ulink>or<ulink url="http://www.sgi.com/software/performer/">IRIS Performer</ulink></para>
            </listitem>
         </itemizedlist>
      </section>
   </chapter>
   <chapter id="install.vrj.chapter">
      <title>Installing VR Juggler</title>
      <para>As with most OpenSource projects, VR Juggler is distributed as compressed archive files using popular formats. Installing a distribution requires very little effort, but you do need to know how to use archiving utilities to extract the installation tree. Automation of the installation is a goal of the VR Juggler team, but we are not there yet. Before reading further, you should know where you want to install VR Juggler, and you should make sure that you have access to write to that directory.</para>
      <section>
         <title>Installing from a Compressed TAR File</title>
         <para>The TAR (Tape ARchive) format has been around for a long, long time in the UNIX world. It is simply a collection of files in a directory tree that are lumped into a single file suitable for writing to a tape or for downloading. The format is a standard, and the tar 1) utility is available on every UNIX-based platform and on Win32. A free version can be downloaded from <ulink url="http://www.gnu.org/">the GNU Project</ulink>. A compressed TAR file is made for each VR Juggler distribution, and some distributions come in other formats as well. You can always count on the availability of a TAR file, though. The TAR files are compressed using GZIP which is a standard compression format. The gzip(1) utility is freely available from the GNU Project (the GNU version of TAR has the GZIP algorithm built in) if your platform does not have it.</para>
         <para>Once you have downloaded a VR Juggler TAR distribution, you can unpack it one of two ways depending on what your platform's version of TAR supports. Before extracting the installation tree, make sure that your current directory is the one where you want to install VR Juggler. If your version of TAR does not have GZIP built in (it does not support the <option>-z</option> option), the following command will do the decompression and extraction:</para>
         <programlisting>% gzip -cd vrjuggler-distribution.tar.gz | tar -xvf -vrjuggler-distribution.tar.gz</programlisting>
         <para>Here, you should fill in <filename>vrjuggler-distribution.tar.gz</filename> with the name of the VR Juggler distribution file you downloaded. The above command will work with any shell that supports redirection of standard output to a pipe. If that looks too scary, you can separate the decompression and extraction into two commands:</para>
         <programlisting>% gunzip vrjuggler-distribution.tar.gz
% tar -xvf vrjuggler-distribution.tar.gzgziptar-z</programlisting>
         <para>Note that the distribution file in the second command does not have the <filename>.gz</filename> extension after <command>gzip</command>(1) is run. These steps also work if your version of <command>tar</command>(1) supports the <option>-z</option> option, but you can simplify your work if that option is supported. The follow illustrates how to uncompress and extract all in one step:</para>
         <programlisting>% tar -xzvf vrjuggler-distribution.tar.gzztar</programlisting>
         <para>In either case, while the command runs, you will see the name of each file as it is written to disk. This is because of the v option to <command>tar</command>(1) that tells it to be verbose in its efforts. <command>tar</command>(1) takes care of creating all the directories in the installation tree, so you only need to have the base directory (for example, <filename>/usr/local</filename>) when you start. For more information about these utilities, please refer to the <command>tar</command>(1) and <command>gzip</command>(1) manual pages.</para>
      </section>
      <section>
         <title>Installing from a ZIP File (Win32 only)</title>
         <para>On the Win32 family of platforms, the ZIP format rules. In the old days, you would use the PKZIP utility to uncompress and extract a ZIP file. Nowadays, you use <ulink url="http://www.winzip.com/">WinZip</ulink> or some other comparable graphical interface. This documentation covers only the use of WinZip when extracting a ZIP file.</para>
         <para>Once you have downloaded the VR Juggler ZIP file, the easiest way to extract it is to double-click on its icon in the open folder window as shown below:</para>
         <figure>
            <title>Windows Folder View of ZIP File</title>
            <mediaobject>
               <imageobject>
                  <imagedata/>
               </imageobject>
            </mediaobject>
         </figure>
         <para>Double-clicking opens the main WinZip window:</para>
         <figure>
            <title>Open WinZip Window</title>
            <mediaobject>
               <imageobject>
                  <imagedata/>
               </imageobject>
            </mediaobject>
         </figure>
         <para>Note that in this screen shot, the <guibutton>Extract</guibutton> button is highlighted. Click this button to open the following window:Note that in this screen shot, the <guibutton>Extract</guibutton> button is highlighted. Click this button to open the following window:</para>
         <figure>
            <title>WinZip Extract Dialog</title>
            <mediaobject>
               <imageobject>
                  <imagedata/>
               </imageobject>
            </mediaobject>
         </figure>
         <para>In this window, choose the directory where VR Juggler will be installed and click <guibutton>Extract</guibutton>. WinZip will then proceed to extract the ZIP file into the directory you named. That's all there is to it.</para>
      </section>
   </chapter>
   <chapter id="envvar.chapter">
      <title>Environment Variables</title>
      <para>There are several <firstterm>environment variables</firstterm> that affect the way that VR Juggler works. Some of these are required to compile and run applications while others are optional. This page lists all such variables and explains their meanings and uses.</para>
      <section>
         <title>How to Set Environment Variables</title>
         <para>The syntax for setting or changing an environment variable varies with operating systems and shell interpreters. Instead of choosing one style of syntax that is specific to a particular shell type, we define our own syntax which you must then translate to your shell's specific syntax. Before defining this syntax, we present the method used to set environment variables in the three most common types of shells. We also provide a quick overview of how to set environment variables using Win32-based GUIs.</para>
         <section>
            <title>Common Conventions and Background</title>
            <para>A convention used throughout is to name the variables using all capital letters. In almost all cases regardless of the shell, this is the naming convention used for environment variables.</para>
            <para>Setting a path with an environment variable can require special syntax. Because of this, the method for doing so may vary from shell to shell. Paths are important with VR Juggler when looking up the path to a shared library (dynamically linked library). For each shell, the syntax for setting a path is given.</para>
            <para>Referring to environment variables can also vary from shell to shell. An example of how to print the value of an environment variable is given for each shell. An example of how to refer to an environment variable is also provided as these two operations may vary even within one kind of shell!</para>
            <para>In all shells, an environment variable is only available within that single shell instance. That is, setting an environment variable at a command prompt only affects that specific shell and will not be available from other concurrent or future shells. To make a setting <quote>permanent</quote>, it should be done in file read by all shell instances when they are started. This is addressed briefly as appropriate for each shell type.</para>
         </section>
         <section>
            <title>C-Style Shells (csh, tcsh)</title>
            <para>In a C-style shell (i.e., one whose interface is based on the C programming language), setting environment variables is done using the built-in command setenv. It is used as follows: </para>
            <programlisting>% setenv &lt;VARIABLE_NAME&gt; &lt;value&gt;</programlisting>
            <para>where the string <literal>&lt;VARIABLE_NAME&gt;</literal> represents the name of the variable you are going to set and <literal>&lt;value&gt;</literal> represents the value assigned to that variable. Both are required. If the named variable did not exist before, it will pop into existence. Otherwise, you overwrite the old setting with the new one.</para>
            <para>To print the value of an environment variable, use the following command:</para>
            <programlisting>% printenv &lt;VARIABLE_NAME&gt;</programlisting>
            <para>Referring to a variable, however, is done using the following syntax:</para>
            <programlisting>% cd $VARIABLE_NAME/bin</programlisting>
            <para>Paths are specified as a colon-separated list. An example of this is: </para>
            <programlisting>% printenv PATH
/bin:/sbin:/usr/bin:/usr/sbin</programlisting>
            <para>For these types of shells, a <quote>permanent</quote> setting for a given variable should usually be done in your .cshrc file or in your <filename>.login</filename> file, both of which should be in your home directory. In most cases, it is better to use <filename>.cshrc</filename> because it is evaluated for every shell instance. </para>
         </section>
         <section>
            <title>sh-Derived Shells (sh, ksh, bash, zsh, etc.)</title>
            <para>In a shell based on sh, setting environment variables is done using the built-in command export. It is used as follows:</para>
            <programlisting>% export &lt;VARIABLE_NAME&gt;=&lt;value&gt;</programlisting>
            <para>or </para>
            <programlisting>% &lt;VARIABLE_NAME&gt;=&lt;value&gt;
% export &lt;VARIABLE_NAME&gt;</programlisting>
            <para>Here, the string <literal>&lt;VARIABLE_NAME&gt;</literal> represents the name of the variable you are going to set and <literal>&lt;value&gt;</literal> represents the value assigned to that variable. Both are required. Note that there is no space between the variable name and its value. If the named variable did not exist before, it will pop into existence. Otherwise, you overwrite the old setting with the new one. If the variable was already among your current shell's environment variables, the export command is not necessary.</para>
            <para>To print the value of an environment variable, use the following command: </para>
            <programlisting>% echo $VARIABLE_NAME</programlisting>
            <para>Getting the value of a variable works the same way.</para>
            <para>Paths are specified as a colon-separated list. An example of this is:</para>
            <programlisting>% echo $PATH
/bin:/sbin:/usr/bin:/usr/sbin</programlisting>
            <para>For these types of shells, a <quote>permanent</quote> setting for a given variable should usually be done in the .profile file in your home directory or in your shell's <quote>rc</quote> file. Different shells have different names for this file. Examples are <filename>.bashrc</filename> for BASH and <filename>.zshrc</filename> for zsh. Please refer to your shell's documentation for more information. In any case, the file will be in your home directory.</para>
         </section>
         <section id="envvar.dos.section">
            <title>DOS Shell</title>
            <para>The typical syntax for setting an environment variable from the command line (in a DOS shell window) under Win32 is:</para>
            <programlisting>C:\ set &lt;VARIABLE_NAME&gt;=&lt;value&gt;</programlisting>
            <para>Here, <literal>&lt;VARIABLE_NAME&gt;</literal> is the name of the environment variable to be set, and <literal>&lt;value&gt;</literal> is the value being assigned to that variable. If the named variable did not exist before, it will pop into existence. Otherwise, you overwrite the old setting with the new one.</para>
            <para>To print the value of an environment variable, use the following command:</para>
            <programlisting>C:\ set &lt;VARIABLE_NAME&gt;</programlisting>
            <para>Referring to a variable, however, is done using the following syntax: </para>
            <programlisting>C:\ cd %VARIABLE_NAME%\bin</programlisting>
            <para>Paths are specified as a semicolon-separated list. An example of this is:</para>
            <programlisting>C:\ set PATH
C:\WINDOWS;C:\bin;C:\</programlisting>
            <para>For some versions of Windows, a <quote>permanent</quote> setting for a given variable should usually be done in <filename>C:\AUTOEXEC.BAT</filename>. In newer versions and in the Windows NT line, the setting is done using the Control Panel. Please refer to the next section for more information on that method.</para>
         </section>
         <section>
            <title>Win 32 GUI</title>
            <para>Before reading this section, please be sure to have read <xref linkend="envvar.dos.section"/>. This is necessary because the Win32 GUI for setting environment variables is simply a front-end to that older method and thus uses the same conventions and syntax. The versions of Windows to which this subsection applies are indicated individually since each is a little different. For more detailed information, please refer to the Windows online help system and search for <quote>environment variables</quote>.</para>
            <section>
               <title>Windows 2000</title>
               <para>In the Control Panel, open the <guiicon>System</guiicon> icon. Under the <guilabel>Advanced</guilabel> tab, there is a button labeled <guibutton>Environment Variables</guibutton>. Here, you can set variables for yourself and, if you have the access privileges, for all users. </para>
            </section>
            <section>
               <title>Windows NT 4.0</title>
               <para>In the Control Panel, open the <guiicon>System</guiicon> icon. The window that is opened has a tab labeled <guilabel>Environment Variables</guilabel>. Here, you can set variables for yourself and, if you have the access privileges, for all users. </para>
            </section>
         </section>
         <section>
            <title>Syntax Used in this Document</title>
            <para>To avoid tying this documentation to a single style of environment variable creation, assignment and reference, the following syntax will be used exclusively from this point onward. Please read this carefully before proceeding.</para>
            <section>
               <title>Naming Environment Variables</title>
               <para>When naming an environment variable in the plain text of this document, the variable will be referred to by its name only. For example, to talk about the environment variable containing your path, we will talk about it as PATH. </para>
            </section>
            <section>
               <title>Creating/Setting Environment Variables</title>
               <para>The syntax to set an environment variable is: </para>
               <programlisting>% &lt;VARIABLE_NAME&gt; = &lt;value&gt;</programlisting>
               <para>Setting an environment variable also creates it if it is not already present in the current shell's environment. </para>
            </section>
            <section>
               <title>Printing an the Value of an Environment Variable</title>
               <para>Printing an environment variable's value to standard output (stdout) is done as follows: </para>
               <programlisting>% echo $VARIABLE_NAME
value</programlisting>
            </section>
            <section>
               <title>Referring to the Value of an Environment Variable</title>
               <para>To get the value of an environment variable when it needs to be expanded, the following syntax will be used: </para>
               <programlisting>% cd $VARIABLE_NAME/bin</programlisting>
               <para> Here, the reference to the value is <varname>$VARIABLE_NAME</varname>. </para>
            </section>
         </section>
         <section>
            <title>Required Environment Variables</title>
            <variablelist>
               <varlistentry>
                  <term>VJ_BASE_DIR</term>
                  <listitem>
                     <para>The environment variable VJ_BASE_DIR tells a VR Juggler application where to find important data files. It is required to compile and run any Juggler app. It should be set to the base directory of the installed VR Juggler library. For example, if you downloaded a UNIX version of VR Juggler 0.1.97 and extracted it to the directory /home/software/, you would set VJ_BASE_DIR with this command: </para>
                     <programlisting>% VJ_BASE_DIR = /home/software/vrjuggler-1.0</programlisting>
                     <para>The last component of this example (the part in italics) depends on the particular version of Juggler you have downloaded. </para>
                     <para>If you downloaded and built VR Juggler from the source code, the compilation creates a directory called instlinks which can be used as a Juggler base: </para>
                     <programlisting>% VJ_BASE_DIR = $HOME/juggler/my_build_dir/instlinks</programlisting>
                     <para>In any case, on a Win32 platform, you should use /'s as the path separator for <varname>VJ_BASE_DIR</varname> rather than \'s. The compiler tools can handle either, and the utilities in <filename>juggler-tools</filename> will behave much better if UNIX-style paths are used. It is safe to use the drive letter at the start of the path (e.g., <filename>C:/software/vrjuggler-1.0.5</filename>). </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>JDK_HOME</term>
                  <listitem>
                     <para>The <varname>JDK_HOME</varname> environment variable is required by the script that starts VjControl, the VR Juggler configuration program. If Java is installed on your system, <varname>JDK_HOME</varname> may already be set. If not, it needs to be set to the base of the Java installation. </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>LD_LIBRARY_PATH (UNIX/Linux only)</term>
                  <term>LD_LIBRARYN32_PATH (IRIX only)</term>
                  <term>LD_LIBRARY64_PATH (IRIX only)</term>
                  <listitem>
                     <para>UNIX/Linux systems use these environment variables to find dynamically loaded libraries, such as libJuggler.so. Unless you're building everything with static libraries, you will need to set these to include the VR Juggler library directory (under <varname>VJ_BASE_DIR</varname>). IRIX supports several Application Binary Interfaces (ABIs). VR Juggler supports only the N32 and 64 formats, and there are different library path variables for each. The N32 ABI uses the <varname>LD_LIBRARYN32_PATH</varname> variable, and the 64 ABI uses <varname>LD_LIBRARY64_PATH</varname>. An example of setting the library path is as follows: </para>
                     <programlisting>% LD_LIBRARY_PATH = $VJ_BASE_DIR/lib</programlisting>
                     <note>
                        <para>On some SGI systems running IRIX, users of the MIPSpro compiler (version 7.3) will need to add another directory as follows:</para>
                        <programlisting>% LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/usr/lib32/cmplrs:$VJ_BASE_DIR</programlisting>
                     </note>
                  </listitem>
               </varlistentry>
            </variablelist>
         </section>
         <section>
            <title>Optional Related Environment Variables </title>
            <variablelist>
               <varlistentry>
                  <term>PATH</term>
                  <listitem>
                     <para>If you intend to use the VjControl program, you may want to add the $VJ_BASE_DIR/bin directory to your $PATH as follows:</para>
                     <programlisting>% PATH = $PATH:$VJ_BASE_DIR/bin</programlisting>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>VJ_DEBUG_NFY_LEVEL</term>
                  <listitem>
                     <para>This variable can be used to control the amount of diagnostic information a VR Juggler application outputs. Its value is a number between 0 (only very important messages are printed) and 7 (vast amounts of data) inclusive. Non-hackers are advised to use levels 0 through 3, as higher debug levels become increasingly cryptic and <emphasis>can severely impact application performance</emphasis>. The default is level 1--only errors and critical information is output. An example of setting a value for this variable is:</para>
                     <programlisting>% VJ_DEBUG_NFY_LEVEL = 3</programlisting>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>VJ_DEBUG_CATEGORIES</term>
                  <listitem>
                     <para>This variable can be used to control which components of VR Juggler are allowed to output diagnostic data. If for some reason you set <varname>VJ_DEBUG_NFY_LEVEL</varname> to 5 or higher, this variable can be used to filter the output. The value of <varname>VJ_DEBUG_CATEGORIES</varname> is a space-separated list of Juggler debug component names (defined in <filename>$VJ_BASE_DIR/include/Kernel/vjDebug.h</filename>). The default value is <quote>DBG_ALL</quote>, which performs no filtering whatsoever. Examples of setting it are as follows:</para>
                     <programlisting>% VJ_DEBUG_CATAGORIES = DBG_ERROR
% VJ_DEBUG_CATAGORIES = "DBG_KERENEL DBG_INPUT"
% VJ_DEBUG_CATAGORIES = "DBG_CONFIGDB DBG_ENV_MGR"</programlisting>
                  </listitem>
               </varlistentry>
            </variablelist>
         </section>
      </section>
   </chapter>
   <chapter>
      <title>VR Juggler Sample Applications</title>
      <para>VR Juggler comes with several sample applications in its samples directory tree. Many of them are very simple and are designed to demonstrate a specific feature of VR Juggler or a technique to use when writing your own applications. This chapter lists the current sample applications as of this writing and gives a quick description of what you as a potential developer might find interesting in the code. Those users who just want to run applications can safely skip this chapter.</para>
      <section>
         <title>OpenGL Applications</title>
         <para>The OpenGL sample applications are in <filename>$VJ_BASE_DIR/share/samples/ogl</filename>. They are as follows:</para>
         <itemizedlist>
            <listitem>
               <para>Analog: A very simple demo that allows you to test out analog input to VR Juggler. Use an analog simulator, or a real analog device (like a potentiometer hooked up to an IBOX, etc), you can move a cube from the floor to 6 feet above the floor.</para>
               <note>
                  <para>This demo is well documented within the header comments, so would also be a good application for you to learn VR Juggler from (very basic though).</para>
               </note>
            </listitem>
            <listitem>
               <para>Cones: A 10x10x10 array of cones in space. The cones are created using GLU quadrics. Navigation is done using quaternions and is not recommended as a basis for navigation in most applications.</para>
            </listitem>
            <listitem>
               <para>Cubes: A 10x10x10 array of cubes in space. The cubes are created using OpenGL display lists. This is the best example of using display in VR Juggler and should be studied carefully. Navigation is done using quaternions and is not recommended as a basis for navigation in most applications.</para>
            </listitem>
            <listitem>
               <para>Torus: A very, very simple that renders a purple torus at a key point in space. That is, the torus is positioned such that in a CAVE-like device, the center of the torus is at the lower left corner of the device where the front wall, left wall and floor meet. It is designed specifically to test VR Juggler's handling of multiple walls and project alignment (in an extremely crude manner). Lighting of the torus is done with a flashlight on the wand but should not be used as an example of doing lighting in VR Juggler. The behavior of the flashlight is very hard to predict.</para>
            </listitem>
            <listitem>
               <para>Wand: A trivial program showing how to get input from a wand using digital inputs (buttons). This application is designed primarily as a tool to test wand tracking and button input in a VR system.</para>
            </listitem>
            <listitem>
               <para>Texture: An application demonstrating the use of OpenGL texture objects (and display lists). It includes code for loading many different texture formats: SGI RGB and RGBA, BMP, TGA (24 and 32 bit), and PCX.</para>
               <note>
                  <para>This demo is well documented within the header comments. This is a good example for you to start learning VR Juggler.</para>
               </note>
            </listitem>
            <listitem>
               <para>Combo: A collection of Cubes, Torus and Wand that demonstrates how to cycle between three VR Juggler OpenGL applications.</para>
            </listitem>
            <listitem>
               <para>Glove: An example of picking up objects with a glove and navigating through an environment.</para>
            </listitem>
            <listitem>
               <para>SimpleGlove: A very simple application that shows how to use the VR Juggler glove interface with a gesture interface.</para>
            </listitem>
            <listitem>
               <para>DigitalGlove: Based on SimpleGlove, this is another simple application that shows how to use the VR Juggler glove interface but this time with digital interfaces for each finger.</para>
            </listitem>
         </itemizedlist>
      </section>
      <section>
         <title>OpenGL Performer Applications </title>
         <para>Examples of OpenGL Performer applications can be found in <filename>$VJ_BASE_DIR/share/samples/pf</filename>. These are for more advanced developers who are familiar with Performer and some of the more complicated aspects of VR Juggler. There are two main programs there:</para>
         <itemizedlist>
            <listitem>
               <para>pfNav: A starting point for basic VR Juggler Performer applications that need to load a model and navigate through it. Users implement their application by inheriting from a provided class . This is a good place for Performer beginners to start because simplePfNav hides many of the complicated details (which actually makes that class far from simple).</para>
            </listitem>
            <listitem>
               <para>pfConfigNav: A more advanced example of a VR Juggler Performer application that can be given its model through a VR Juggler config chunk.</para>
            </listitem>
         </itemizedlist>
      </section>
   </chapter>
   <chapter id="app.compile.chapter">
      <title>Compiling a VR Juggler Sample Program</title>
      <para>Now that you have VR Juggler installed and you have your environment all configured, it's time for the fun to begin. No, seriously. You are now ready to compile and run VR Juggler applications, and that's the whole point, right? This document explains how to compile the applications provided in the directory <filename>$VJ_BASE_DIR/share/samples</filename>.</para>
      <section>
         <title>Required Reading </title>
         <para>Before reading any further, make sure you have already read the instructions on how to install VR Juggler (in <xref linkend="install.vrj.chapter"/>) and on how to configure your environment (in <xref linkend="envvar.chapter"/>). That information will not be repeated, and it is assumed that you already know what we mean by . You should also have a basic understanding of how <command>make</command>(1) works, but in these examples, nothing more will be necessary than typing make on the command line. Refer to the <command>make</command>(1) manual page for more information about it.</para>
      </section>
      <section>
         <title>Compiling an Application </title>
         <para>There are two ways to compile VR Juggler applications: from the command line or with Microsoft Visual Studio. Compiling an application at the command line will work on all supported platforms including Win32. Using Microsoft Visual Studio will only work on Win32. </para>
         <section>
            <title>Compiling from the Command Line</title>
            <para>All the sample programs in <filename>$VJ_BASE_DIR/share/samples</filename> use the same basic steps to compile unless otherwise noted. Always refer to the top of the sample application's Makefile for information that may be specific to building that application. In general, though, all applications' makefiles are compatible with the standard version of the make(1) utility. This includes the nmake command provided with Visual C++.</para>
            <para>The example used here will be the torus application found in <filename>$VJ_BASE_DIR/share/samples/ogl/torus</filename>. It is an OpenGL-based application that will compile and run on all platforms supported by VR Juggler. Begin by changing into the directory <filename>$VJ_BASE_DIR/share/samples/ogl/torus</filename> in a command shell.</para>
            <para>To compile torus, simply enter the following:</para>
            <programlisting>% make</programlisting>
            <para>or on Win32 without Cygwin, enter: </para>
            <programlisting>% nmake</programlisting>
            <para>The compile process will then begin. If you have your system set up properly, it will complete with an executable torus file (or torus.exe on Win32) in the directory. Now that you have a program compiled, it's time to learn how to run it.</para>
         </section>
         <section>
            <title>Compiling Using Microsoft Visual Studio </title>
            <para>All of the OpenGL sample applications are shipped with pre-configured Microsoft Visual C++ workspaces. This is done to help new users get started with compiling VR Juggler applications and to give experienced Visual Studio users a starting place for their application development. To use the workspace for the torus application, begin by opening the folder containing the source code and double-clicking on torus.dsw.</para>
            <figure>
               <title>Selecting the Workspace File</title>
               <mediaobject>
                  <imageobject>
                     <imagedata/>
                  </imageobject>
               </mediaobject>
            </figure>
            <para>Visual C++ will open, and the torus project will be loaded. The unexpanded class view will look like the following when Visual C++ first loads:</para>
            <figure>
               <title>torus Project</title>
               <mediaobject>
                  <imageobject>
                     <imagedata/>
                  </imageobject>
               </mediaobject>
            </figure>
            <para>Before proceeding, the program arguments must be set. This is done using the <guimenuitem>Settings</guimenuitem> item under the <guimenu>Project</guimenu> menu:</para>
            <figure>
               <title>Project Menu</title>
               <mediaobject>
                  <imageobject>
                     <imagedata/>
                  </imageobject>
               </mediaobject>
            </figure>
            <para>Selecting this item opens the <quote>Project Settings</quote> dialog. In this window, choose the <guilabel>Debug</guilabel> tab. There will be an empty text entry field under the heading <guilabel>Project arguments</guilabel>. Here, enter the full paths to the VR Juggler config files that will be used to run the torus application. The <varname>$VJ_BASE_DIR</varname> environment variable cannot be used here, unfortunately, so the <emphasis>full path</emphasis> to <emphasis>every</emphasis> file must be used. The following shows the beginning of the program arguments listing <filename>sim.base.config</filename>, <filename>sim.wand.mixin.config</filename>, and <filename>sim.displays.config</filename>:</para>
            <figure>
               <title>Project Settings Dialog</title>
               <mediaobject>
                  <imageobject>
                     <imagedata/>
                  </imageobject>
               </mediaobject>
            </figure>
            <para>Note that in this example, the / directory separator is used instead of \. This is not strictly required in this case, but doing it this way maintains consistency with other examples. </para>
            <para>Once the program arguments are set up, compile the application. Under the <guimenu>Build</guimenu> menu, choose the <guimenuitem>Build torus.exe</guimenuitem> item as shown below:</para>
            <figure>
               <title>Build Menu</title>
               <mediaobject>
                  <imageobject>
                     <imagedata/>
                  </imageobject>
               </mediaobject>
            </figure>
            <para>Visual C++ will compile the application, and if you have everything configured properly on your computer, the compiling will complete successfully. Once it is done, execute the torus program by choosing the <guimenuitem>Execute torus.exe</guimenuitem> item from the <guimenu>Build</guimenu> menu, shown below.</para>
         </section>
      </section>
      <section>
         <title>Additional Notes</title>
         <para>In some cases, VR Juggler applications have makefiles that require the use of GNU make. This is always noted in the heading comments of Makefile in the application's directory. GNU make is free software that can be downloaded from <ulink url="http://www.gnu.org/">the GNU Project</ulink>. Some operating system vendors provide pre-compiled packages for easy installation of GNU software.</para>
         <para>On the Win32 family of platforms, it is possible to develop VR Juggler applications as Visual C++ projects rather than using the command-line interface. We do not currently have an example of how to do this, but when it is available, it will be in the <emphasis>Programmer Guide</emphasis></para>
      </section>
   </chapter>
   <chapter>
      <title>Running a VR Juggler Sample Program</title>
      <para>It is important to note that the same VR Juggler application can be run in simulator mode or in a full-scale VR system with no modifications. What does change is the configuration files used when starting the program. In <filename>$VJ_BASE_DIR/share/Data/configFiles</filename>, you can find many basic configuration files including those for running in simulator using a mouse and keyboard to simulate VR input devices and some example files based on those used for the VRAC C2 systems. In the directory, you will see some files whose name contains <quote>mixin</quote>. These are special files that provide a specific capability not necessarily needed by all applications. They can be mixed in (hence the name) with other configuration files as needed. The configuration files found in the configFiles directory will be referenced in the examples provided, so be sure you know where they are.</para>
      <section>
         <title><anchor id="reading"/>Required Reading </title>
         <para>Before reading any further, make sure you have already read the instructions on how to install VR Juggler (see <xref linkend="install.vrj.chapter"/>) and on how to configure your environment (see <xref linkend="envvar.chapter"/>). That information will not be repeated, and it is assumed that you already know what we mean by <varname>$VJ_BASE_DIR</varname> and <varname>$LD_LIBRARY_PATH</varname> to name two environment variables. At this point, it is also assumed that you already have compiled an application (torus in the case of the examples provided), so you should be sure to have read about how to compile a sample VR Juggler application (in <xref linkend="app.compile.chapter"/>) before proceeding.</para>
      </section>
      <section>
         <title><anchor id="simulator"/>Running an Application in Simulator Mode </title>
         <para>Running in simulator mode means that your input is simulated and your display windows have limited functionality. (By, <quote>simulated input</quote>, we mean that input is provided through windows that take keyboard and mouse input and translate that into transformations in the virtual world.) Simulator displays are limited primarily in that they cannot display stereo graphics. It is important to note that a simulator display is a special kind of VR Juggler display. Instead of basing its viewpoint on the head position of one of the users, the viewpoint is controlled by a separate <quote>camera</quote> that is just another positional device. The Sim Display also draws certain objects to help visualize the environment. For example, the heads of users are represented as blue spheres with gray eyes, and a wand (if present) is drawn as a green cone. Besides these common simulator objects, surface displays can be drawn. These are Juggler Displays representing projection screens or HMD viewing projections and are drawn as translucent rectangles.</para>
         <para>As mentioned, several simulator configuration files are provided with a VR Juggler distribution. These files provide a complete simulation of an immersive environment. Please note that this documentation reflects the state of the configuration files at the time the documentation was written. For more information about the configuration files and how to view or modify the configuration, refer to the <emphasis>VjControl Guide</emphasis>. (Using VjControl is the best way to find out how a specific configuration file is set up.) The configuration files of interest for simulator mode are as follows:</para>
         <para>For the torus application, we only need the base configuration file, the displays configuration file and the wand mix-in configuration file. </para>
         <itemizedlist>
            <listitem>
               <para><filename>sim.base.config</filename> - The basic configuration file needed by all applications when run in simulator mode. It defines commonly used VR Juggler concepts that are beyond the scope of this particular book. It also defines simulated head movement using the keyboard. For now, it is sufficient to know that it is required to run the sample applications in simulator mode.</para>
            </listitem>
            <listitem>
               <para><filename>sim.displays.config</filename> - The basic simulator display configuration file needed by all applications when run in simulator mode. This file defines the display windows where the rendering magic occurs. Two simulator display windows are configured by this file: a small one that is active by default and a larger one that is inactive initially.</para>
            </listitem>
            <listitem>
               <para><filename>sim.analog.wandmixin.config</filename> - A <quote>mix-in</quote> configuration file that defines simulated analog input using the keyboard. This is only required for applications where analog input is used and needs to be simulated when in simulator mode.</para>
            </listitem>
            <listitem>
               <para><filename>sim.analog.mixin.config</filename> - This version of the wand sim opens its own window. See the previous sim.analog.wandmixin.config for other details.</para>
            </listitem>
            <listitem>
               <para><filename>sim.c6displays.mixin.config</filename> - A <quote>mix-in</quote> configuration file that defines the surface displays of VRAC's C6. This is not required for any application but can be used to test opening multiple display windows (both surface and simulator) before running in a multi-screen VR system.</para>
            </listitem>
            <listitem>
               <para><filename>sim.digital.glove.mixin.config</filename> - A <quote>mix-in</quote> configuration file that defines simulated digital glove input using the keyboard. This is only required for applications where digital glove input is used and needs to be simulated when in simulator mode.</para>
            </listitem>
            <listitem>
               <para><filename>sim.glove.mixin.config</filename> - A <quote>mix-in</quote> configuration file that defines simulated gesture-based glove input using the keyboard. This is only required for applications where gesture-based glove input is used and needs to be simulated when in simulator mode.</para>
            </listitem>
            <listitem>
               <para><filename>sim.wand.mixin.config</filename> - A <quote>mix-in</quote> configuration file that defines simulated wand input using the mouse. This is only required for applications where wand input is used and needs to be simulated when in simulator mode.</para>
            </listitem>
         </itemizedlist>
         <para>Now it is time to run the application--finally! Make sure that all your environment variables are set properly before trying to start the application. Once you are ready, you specify the name of the application and all the configuration files it needs. An example of this is:</para>
         <programlisting>% torus sim.base.config sim.displays.config sim.wand.mixin.config</programlisting>
         <para>You will notice that no paths are specified for finding the three configuration files. This is intentional to shorten the command line given in the example. In general, you always have to give the full path to the files. VR Juggler does not have any logic (at this time) for defining a path that would contain configuration files. Beginning users will typically want to reference the example configuration files in <filename>$VJ_BASE_DIR/share/Data/configFiles</filename>. As you get more comfortable with VR Juggler and its configuration system, you may want to make your own modified files and put them in the directory <filename>$HOME/.vjconfig</filename>. To simplify running applications, you may want to make a shell script (or batch file as appropriate) that does all the work of passing configuration files and common command-line arguments. For now, though, use the path <filename>$VJ_BASE_DIR/share/Data/configFiles</filename> for each of the configuration files you pass on the command line. </para>
         <para>As the application starts, you will see a plethora of output (more or less depending on how you have <varname>$VJ_DEBUG_NFY_LEVEL</varname> and <varname>$VJ_DEBUG_CATAGORIES</varname> set), and then one moderately sized simulator display window will open on the left side of your screen while three blank keyboard input windows open on the right side of your screen. The display window will be titled <quote>SimWindow1</quote>, and the keyboard input windows will be titled <quote>Head Keyboard</quote>, <quote>Sim View Cameras Control</quote> and <quote>Wand Keyboard</quote> (in order from the top of the display to the bottom). Don't worry that the keyboard windows are black--that's normal. The display window will have a purple torus, a cyan sphere and a green cone. The torus is what you have come to see; the sphere is the simulated user's head; and the cone is the simulated user's wand. In <xref linkend="torus.running.figure"/>, we show what this looks on an IRIX 6.5 desktop for comparison with what you are seeing. Note that the head and wand are only rendered in the simulator windows. They are present because head and wand input are being simulated, and it is typically quite helpful to see the results of that simulated input. </para>
         <figure id="torus.running.figure">
            <title>torus running on an IRIX desktop</title>
            <mediaobject>
               <imageobject>
                  <imagedata/>
               </imageobject>
            </mediaobject>
         </figure>
         <para>So now you are probably wondering what you can do with this fancy application. Interaction is done through the keyboard windows on the right side of your desktop. Moving the head is done with the keyboard in <quote>Head Keyboard</quote>; moving the camera is done with with the keyboard int <quote>Sim View Cameras Control</quote>; and moving the wand is done with the mouse in <quote>Wand Keyboard</quote>. As noted above, this information is current as of this writing. For information on how to verify these settings and to view the current configuration, refer to the <emphasis>VjControl Guide</emphasis>. The following list of tables provides all the keyboard and mouse controls for the simulator when using these particular configuration files. Note that it is possible to reconfigure the simulator to suit your preferences. This is provided mainly for those who just want something that works now.</para>
         <glosslist>
            <glossentry>
               <glossterm><emphasis>Moving the user's wand</emphasis></glossterm>
               <glossdef>
                  <para>Transformation Key Press </para>
                  <para>Move head backward 2 on keypad </para>
                  <para>Move head left 4 on keypad </para>
                  <para>Move head right 6 on keypad </para>
                  <para>Move head forward 8 on keypad </para>
                  <para>Move head down 7 on keypad </para>
                  <para>Move head up 9 on keypad </para>
                  <para>Turn head up CTRL+2 on keypad </para>
                  <para>Turn head left CTRL+4 on keypad </para>
                  <para>Turn head right CTRL+6 on keypad </para>
                  <para>Turn head down CTRL+8 on keypad </para>
                  <para>Rotate head clockwise 1 on keypad </para>
                  <para>Rotate head counter-clockwise 3 on keypad </para>
                  <para></para>
               </glossdef>
            </glossentry>
            <glossentry>
               <glossterm><emphasis>Moving the user's wand</emphasis></glossterm>
               <glossdef>
                  <para>Transformation Mouse Input</para>
                  <para>Move wand backward ALT+move mouse backward </para>
                  <para>Move wand forward CTRL+move mouse forward </para>
                  <para>Move wand left CTRL+move mouse left </para>
                  <para>Move wand right CTRL+move mouse right </para>
                  <para>Move wand up CTRL+move mouse forward </para>
                  <para>Move wand down CTRL+move mouse backward </para>
                  <para>Rotate wand left SHIFT+move mouse left </para>
                  <para>Rotate wand right SHIFT+move mouse right </para>
                  <para>Rotate wand up SHIFT+move mouse forward </para>
                  <para>Rotate wand down SHIFT+move mouse backward </para>
                  <para>Rotate wand clockwise Right arrow </para>
                  <para>Rotate wand counter-clockwise Left arrow </para>
                  <para>Wand button #1 Left mouse button </para>
                  <para>Wand button #2 Middle mouse button </para>
                  <para>Wand button #3 Right mouse button </para>
               </glossdef>
            </glossentry>
            <glossentry>
               <glossterm><emphasis>Moving the camera</emphasis></glossterm>
               <glossdef>
                  <para>Transformation Key Press </para>
                  <para>Move camera backward 2 on keypad </para>
                  <para>Move camera left 4 on keypad </para>
                  <para>Move camera right 6 on keypad </para>
                  <para>Move camera forward 8 on keypad </para>
                  <para>Move camera down 7 on keypad </para>
                  <para>Move camera up 9 on keypad </para>
                  <para>Turn camera up CTRL+2 on keypad </para>
                  <para>Turn camera left CTRL+4 on keypad </para>
                  <para>Turn camera right CTRL+6 on keypad </para>
                  <para>Turn camera down CTRL+8 on keypad </para>
                  <para>Rotate camera clockwise 1 on keypad </para>
                  <para>Rotate camera counter-clockwise 3 on keypad </para>
                  <para></para>
               </glossdef>
            </glossentry>
         </glosslist>
         <para>Before continuing on to running an application in a full-scale VR system, we provide two asides: using a simulated glove and using a simulated analog device. The examples provided thus far have not discussed this because the information was not relevant to the particular sample application being used. Knowing how to use these simulated devices is important, however, and it is treated separately as a reference for your future endeavors in running VR Juggler applications.</para>
         <section>
            <title>Using a Simulated Glove </title>
            <para>If you include the <filename>sim.glove.mixin.config</filename> file, your application will also have access to a simulated glove, with position and gesture inputs. The glove is controlled by a window titled <quote>Glove Keyboard</quote>. This window lets you control the glove position and selected gesture. Movement control of the glove uses the mouse and is the same as that of the wand. The mouse buttons are used to select gestures. The mapping of the gesture numbers to actual hand positions is controlled by the <quote>training file</quote> for the sim glove. The defaults training file is <filename>$VJ_BASE_DIR/share/Data/gesture/simpleSimGestures.dat</filename>.</para>
         </section>
      </section>
      <section>
         <title>Running an Application in a VR System </title>
         <para>Running an application full-scale in a VR system is more complicated than running in simulator mode. The reason for this is that VR systems tend to differ in configuration and in available hardware. VR Juggler is flexible enough to handle most any configuration you throw at it, but those configurations need to be put together first. Examples of configuration files used in VRAC's C2 system are provided, and they are used in this documentation. It should be noted, however, that for any particular system, custom configuration files will probably have to be written. The idea behind this section is to provide a basic understanding of what is needed to get started with running in a VR system.</para>
         <para>The example configuration files in the directory <filename>$VJ_BASE_DIR/share/Data/configFiles</filename> modeled after those used for VRAC's C2 system are as follows:</para>
         <itemizedlist>
            <listitem>
               <para><filename>C2.base.config</filename> - The basic configuration file needed by all applications when run in the C2. It defines commonly used VR Juggler concepts that are beyond the scope of this particular book.</para>
            </listitem>
            <listitem>
               <para><filename>C2.displays.config</filename> - The basic display configuration file needed to run with all four walls active and rendering stereo graphics. This defines only the four surface displays to be opened.</para>
            </listitem>
            <listitem>
               <para><filename>C2.flock.config</filename> - The Ascension Flock of Birds configuration file that defines which bird provides input for the head and for the wand.</para>
            </listitem>
            <listitem>
               <para><filename>C2.ibox_buttons.config</filename> - The IBOX configuration file that handles the digital wand button inputs.</para>
            </listitem>
            <listitem>
               <para><filename>C2.mono.displays.config</filename> - The same configuration as <filename>C2.displays.config</filename> except that the walls are opened to render mono graphics.</para>
            </listitem>
         </itemizedlist>
         <para>Running the application is the same as in simulator mode except that the configuration files given on the command line are different. For example, to run torus in the C2 with stereo graphics, the following command would be used:</para>
         <programlisting>% torus C2.base.config C2.displays.config C2.flock.config C2.ibox_buttons.config </programlisting>
      </section>
   </chapter>
</book>
