/* Generated by Together */

#ifndef AJ_H
#define AJ_H
#include "ISoundInterface.h"
class aj : public ISoundInterface
{
public:

   aj() : ISoundInterface()
   {
   }

   virtual ~aj()
   {
   }

   /**
    * @input alias of the sound to trigger, and number of times to play
    * @preconditions alias does not have to be associated with a loaded sound.
    * @postconditions if it is, then the loaded sound is triggered.  if it isn't then nothing happens.
    * @semantics Triggers a sound
    */
   virtual void trigger(const std::string & alias, const unsigned int & looping = 0)
   {
      if (mImplementation != NULL)
      {
         mImplementation->trigger( alias, looping );
      }
   }

   /**
    * @semantics stop the sound
    * @input alias of the sound to be stopped
    */
   virtual void stop(const std::string & name)
   {
      if (mImplementation != NULL)
      {
         mImplementation->stop( name );
      }
   }

   /**
    * @semantics call once per sound frame (doesn't have to be same as your graphics frame)
    * @input time elapsed since last frame
    */
   virtual void step(const float & timeElapsed)
   {
      if (mImplementation != NULL)
      {
         mImplementation->step( timeElapsed );
      }
   }


   /**
    * @preconditions provide an alias and a filename
    * @postconditions alias will point to loaded sound data
    * @semantics associate an alias to sound data.  later this alias can be used to operate on this sound data.
    */
   virtual void associate(const std::string & alias, const std::string & filename)
   {
      if (mImplementation != NULL)
      {
         mImplementation->associate( alias, filename );
      }
   }


   virtual void remove(const std::string alias)
   {
      if (mImplementation != NULL)
      {
         mImplementation->remove( alias );
      }
   }

   virtual void setPosition( const std::string& alias, float x, float y, float z )
   {
      if (mImplementation != NULL)
      {
         mImplementation->setPosition( alias, x, y, z );
      }
   }

   /**
    * @input usually a name of a valid registered sound API implementation
    * @preconditions sound implementation should be registered
    * @postconditions interface holds only one implementation, if one is already attached, then this function will detach it first.  if impl is not registered, then attach fails returning false.  otherwise a sound implementation is attached. 
    */
   virtual void attachAPI( const std::string& apiName, bool& result )
   {
      this->detachAPI();
      SoundFactory::instance()->createImplementation( apiName, mImplementation, result );
   }

   /**
    * @input none
    * @preconditions usually an API was already attached, but doesn't have to be.
    * @postconditions if an API was attached, then the API implemetation is detached.  Any future calls to trigger etc... results in a stubbed out version of the function until a Sound API Implemention is attached again.
    */
   virtual void detachAPI()
   {
      if (mImplementation != NULL)
      {
         delete mImplementation;
         mImplementation = NULL;
      }
   }

privatmImplementation e:

   /** @link dependency */
   /*#  SoundFactory lnkSoundFactory; */

   /** @link aggregation 
    * @clientCardinality 1
    * @supplierCardinality 1*/
   ISoundImplementation* mImplementation;
};
#endif //AJ_H
