package org.vrjuggler.jccl.editors;

import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.dnd.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;

import org.vrjuggler.jccl.config.*;

public class ConfigContextEditor
   extends JPanel
{
   public ConfigContextEditor()
   {
      // Init the GUI
      try
      {
         jbInit();
      }
      catch (Exception e)
      {
         e.printStackTrace();
      }

      // Set up the tree
      mContextModel = new ConfigContextModel();
      mElementTree.setModel(mContextModel);
      mElementTree.setCellRenderer(new ConfigContextCellRenderer());
      mElementTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);

      // Setup a listener for the tree so that when an element is selected, the
      // appropriate element is displayed in the property sheet.
      mElementTree.addTreeSelectionListener(new TreeSelectionListener()
         {
            public void valueChanged(TreeSelectionEvent evt)
            {
               DefaultMutableTreeNode node =
                  (DefaultMutableTreeNode)mElementTree.getLastSelectedPathComponent();
               if(null == node)
               {
                  return;
               }
               Object value = node.getUserObject();
               if (value == null || !(value instanceof ConfigElement))
               {
                  return;
               }

               ConfigElement elt = (ConfigElement)value;
               mElementPropSheet.setElement(elt);
              
               if (mCustomEditors != null)
               {
                  for(Iterator itr = mCustomEditors.iterator() ; itr.hasNext() ; )
                  {
                     CustomEditor editor = (CustomEditor)itr.next(); 
                     mTabPane.remove(mTabPane.indexOfTab(editor.getTitle()));
                  }
                  mCustomEditors = null;
               }

               mCustomEditors = CustomEditorRegistry.findEditors(elt.getDefinition().getToken());
    
               if (mCustomEditors != null)
               {

                  for(Iterator itr = mCustomEditors.iterator() ; itr.hasNext() ; )
                  {
                     CustomEditor editor = (CustomEditor)itr.next(); 
                     editor.setConfigElement(elt);
                     mTabPane.add(editor.getPanel(), editor.getTitle());
                  }
               }  
            }
         });
   }

   /**
    * Sets the configuration context this editor should be editing.
    *
    * @param context      the context to edit
    */
   public void setContext(ConfigContext context)
   {
      mContextModel.setContext(context);
      java.util.List elts = getBroker().getElements(context);
      if (elts.size() > 0)
      {
         ConfigElement elt = (ConfigElement)elts.get(0);
         mElementPropSheet.setElement(elt);
      }

      mElementTree.expandPath(new TreePath(mContextModel.getRoot()));
   }

   /**
    * Gets the configuration context this editor is editing.
    *
    * @return  the context being edited
    */
   public ConfigContext getContext()
   {
      return mContextModel.getContext();
   }

   /**
    * Gets a handle to the configuration broker.
    */
   protected ConfigBroker getBroker()
   {
      if (mBroker == null)
      {
         synchronized (this)
         {
            if (mBroker == null)
            {
               mBroker = new ConfigBrokerProxy();
            }
         }
      }
      return mBroker;
   }

   /**
    * Initializes the GUI. Auto-generated by JBuilder.
    */
   private void jbInit()
      throws Exception
   {
      JPanel temp = new JPanel();
      temp.setLayout(new BorderLayout());
      treePane.setLayout(treeLayout);
      
      this.setLayout(mBaseLayout);
      mElementTreeScrollPane.setMinimumSize(new Dimension(0, 0));
      mElementTree.setRootVisible(false);
      mElementTree.setShowsRootHandles(true);
      mBaseSplitPane.setOneTouchExpandable(true);
      this.add(mBaseSplitPane, BorderLayout.CENTER);
      mBaseSplitPane.add(treePane, JSplitPane.LEFT);
      mBaseSplitPane.add(mTabPane, JSplitPane.RIGHT);
      mTabPane.add(mElementPropSheetScrollPane, "DefaultEditor");
      mElementPropSheetScrollPane.getViewport().add(mElementPropSheet, null);
      mElementTreeScrollPane.getViewport().add(mElementTree, null);
      
      treeToolbar.setFloatable(false);

      addBtn.setText("Add");
      //addBtn.setEnabled(false);
      removeBtn.setText("Remove");
      //removeBtn.setEnabled(false);
 
      addBtn.addActionListener(new ActionListener()
      {
         public void actionPerformed(ActionEvent evt)
         {
            addAction(evt);
         }
      });
      removeBtn.addActionListener(new ActionListener()
      {
         public void actionPerformed(ActionEvent evt)
         {
            removeAction(evt);
         }
      });
      
      treePane.add(treeToolbar, BorderLayout.NORTH);
      treePane.add(mElementTreeScrollPane, BorderLayout.CENTER);
      treeToolbar.add(addBtn);
      treeToolbar.add(removeBtn);
   }

   /**
    * Removes a config element from the current context using the ConfigBroker.
    */
   protected void removeAction(ActionEvent evt)
   {
      TreePath path = mElementTree.getLeadSelectionPath();
      DefaultMutableTreeNode node = (DefaultMutableTreeNode)path.getLastPathComponent();
      Object temp = node.getUserObject();
      if(temp instanceof ConfigElement)
      {
         // Try to remove the element.
         if (!getBroker().remove(mContextModel.getContext(), (ConfigElement)temp))
         {
            System.out.println("Failed...");
         }
      }

   }

   /**
    * Adds a new config element to the current context using the ConfigBroker.
    */
   protected void addAction(ActionEvent evt)
   {
      DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                     mElementTree.getLastSelectedPathComponent();

      // Get a DB of all known ChunkDescs
      ConfigDefinitionRepository temp = getBroker().getRepository();
      java.util.List defs = temp.getAllLatest();
      //java.util.List descs = getBroker().getDescs(getContext());

      // Ask the user to choose a base ChunkDesc
      ConfigDefinitionChooser chooser = new ConfigDefinitionChooser();
      chooser.setDefinitions(defs);
      int result = chooser.showDialog(this);

      // If the user did not cancel their choice, make a new ConfigChunk for
      // the chose ChunkDesc
      if (result == ConfigDefinitionChooser.APPROVE_OPTION)
      {
         ConfigElementFactory tempfac = new ConfigElementFactory(defs);
         
         // TODO: Compute a unique name
         // -We used to use the following to get a unique name, but it is gone now :(
         //       chunk.setName(configChunkDB.getNewName(chunk.getDesc().getName()));

         // -The following method can lead to problems since we do not want
         // elements that are named the same.
         //       chunk.setName(chunk.getDesc().getName()); 
         
         // -Our temporary Solution is to try to make it obvious to the user that they 
         // need to change it.
         ConfigElement element = tempfac.create("CHANGEME", chooser.getSelectedDefinition());
         

         // Make sure this add goes through successfully
         if (! getBroker().add(getContext(), element))
         {
            JOptionPane.showMessageDialog(this,
                                          "There are no configuration files active.",
                                          "Error",
                                          JOptionPane.ERROR_MESSAGE);
            return;
         }

// TODO: Make this work again
         // Make sure the new node gets selected
//         List chunk_nodes = getNodesFor(chunk);
//         if (chunk_nodes.size() > 0)
//         {
//            TreeNode chunk_node = (TreeNode)chunk_nodes.get(0);
//            TreePath path = new TreePath(treeModel.getPathToRoot(chunk_node));
//            mElementTree.setSelectionPath(path);
//         }
      }
   }
      
   private BorderLayout mBaseLayout = new BorderLayout();
   private JSplitPane mBaseSplitPane = new JSplitPane();
   private JTabbedPane mTabPane = new JTabbedPane();
   private JScrollPane mElementTreeScrollPane = new JScrollPane();
   private JTree mElementTree = new ElementTree();
   private JScrollPane mElementPropSheetScrollPane = new JScrollPane();

   // CustomEditor stuff
   private JScrollPane mCustomConfigElementEditorScrollPane = new JScrollPane();
   private java.util.List mCustomEditors = null;
   
   private ConfigElementPropertySheet mElementPropSheet = new ConfigElementPropertySheet();
   
   private BorderLayout treeLayout = new BorderLayout();
   private JPanel treePane = new JPanel();
   private JToolBar treeToolbar = new JToolBar();
   private JButton addBtn = new JButton();
   private JButton removeBtn = new JButton();

   /** The data model used to represent the context. */
   private ConfigContextModel mContextModel;

   /** The handle to the configuration broker. */
   private ConfigBroker mBroker;
}

/**
 * Wraps a ConfigElement to allow us to transfer it from on context to another
 * either using copy/past or drag and drop methods.
 */
class ConfigElementSelection implements ClipboardOwner, Transferable
{
   /**
    * Constructor that takes the given ConfigElement and creates a Transferable
    * wrapper around it to allow us to move the ConfigElement from one context
    * to another.
    */
   public ConfigElementSelection(ConfigElement elm)
   {
      mConfigElement = elm;
   }

   /**
    * Return the ConfigElement that we are transfering.
    */
   public Object getTransferData(DataFlavor flavor) 
      throws UnsupportedFlavorException
   {
      if (flavor.getRepresentationClass().equals(ConfigElement.class)) 
      {
         return mConfigElement;
      }
      else 
      {
         throw new UnsupportedFlavorException(flavor);
      }
   }

   /**
    * Return an array of valid DataFlavors that we can use to pass
    * ConfigElements from one context to another context.
    */
   public DataFlavor[] getTransferDataFlavors()
   {
      return flavors;
   }

   /**
    * Check if the given DataFlavor is a valid flavor for transfering
    * ConfigElements from one context to another.
    */
   public boolean isDataFlavorSupported(DataFlavor flavor) 
   {
      if (flavor.getRepresentationClass().equals(ConfigElement.class))
      {
         return true;
      }
      return false;
   }

   /**
    * Informs the ConfigContextEditor that it has lost the clipboard.
    */
   public void lostOwnership(Clipboard clip, Transferable obj)
   {;}
   
   /** ConfigElement that we are transfering. */
   private ConfigElement mConfigElement = null;

   /** Array of valid DataFlavors for transfering a ConfigElement. */
   private DataFlavor flavors[] = {new DataFlavor(ConfigElement.class,
                                                "VR Juggler Config Element")};
}

/**
 * A JTree that allows us to transfer ConfigElements to/from other ElementTrees
 * in other contexts.
 */
class ElementTree extends JTree implements DragGestureListener, 
         DragSourceListener, DropTargetListener
{
   /**
    * Create a JTree that supports the dragging and dropping of ConfigElements.
    */
   public ElementTree()
   {
      super();
      DragSource dragSource = DragSource.getDefaultDragSource();
      
      // Create a new drop target. We do not need to keep a reference to this
      // since internally it associates itself with the componenets that it
      // needs.
      new DropTarget(this, // Component to associate DropTarget with.
          DnDConstants.ACTION_COPY_OR_MOVE, // Default acceptable actions.
          this);  // Drop target listener.
      
      // Create a DragGestureRecognizer to watch for drags. Once again we do not
      // need to keep the reference that is returned from this method.
      dragSource.createDefaultDragGestureRecognizer(
            this, // component where drag originates
            DnDConstants.ACTION_COPY_OR_MOVE, // actions
            this); // drag gesture recognizer
   }
   
   /**
    * When the user attempts to drag an object out of the JTree we need to
    * prepare the associated transfer object.
    */
   public void dragGestureRecognized(DragGestureEvent e) 
   {     
      if(e.getDragAction() == DnDConstants.ACTION_COPY)
      {
         System.out.println("Copy...");
      }
      else if(e.getDragAction() == DnDConstants.ACTION_MOVE)
      {
         System.out.println("Move...");
      }
      else
      {
         System.out.println("Something else: " + e.getDragAction());
      }
      
      // Get the selected node the JTree.
      TreePath path = getLeadSelectionPath();
      DefaultMutableTreeNode node = (DefaultMutableTreeNode)path.getLastPathComponent();
      
      // Get the object associated with it, and if it is a ConfigElement
      // prepare it to be transfered.
      Object temp = node.getUserObject();
      if(null != temp && temp instanceof ConfigElement)
      {
         // Start the dragging action with the given icon, transferable object
         // and listener to listen for the dropEnd event that will only occur in
         // the case of a successful drag and drop.
         e.startDrag(DragSource.DefaultCopyDrop, // cursor
                     new ConfigElementSelection((ConfigElement)temp), // transferable
                     this);  // drag source listener
      }
   }

   /**
    * Take appropriate actions after a drop has ended.
    */
   public void dragDropEnd(DragSourceDropEvent e) 
   {
      if(e.getDropAction() == DnDConstants.ACTION_COPY)
      {
         System.out.println("Copy has occured...");
      }
      else if(e.getDropAction() == DnDConstants.ACTION_MOVE)
      {
         System.out.println("Move has occured...");
      }
      else
      {
         System.out.println("Something else: " + e.getDropAction() + " has occured.");
      }    
      // If the drag was successful and it was not a copy action, then default
      // to a move action and remove the ConfigElement from our context.
      if(e.getDropSuccess() && (e.getDropAction() != DnDConstants.ACTION_COPY))
      {
         TreeModel model = this.getModel();
         if(model instanceof ConfigContextModel)
         {
            DataFlavor my_flavor = new DataFlavor(ConfigElement.class, 
                     "VR Juggler Config Element");
            try
            {
               // Get the ConfigElement that we are trying to transfer.
               // NOTE: We could get the selected ConfigElement from the JTree,
               // but this might be more error prone than getting it this way.
               ConfigElement elm = (ConfigElement)e.getDragSourceContext().getTransferable().getTransferData(my_flavor);
            
               ConfigContextModel config_model = (ConfigContextModel)model;
               ConfigBroker broker = new ConfigBrokerProxy();
               
               // Make sure this add goes through successfully
               if (!broker.remove(config_model.getContext(), elm))
               {
                  throw new Exception("Failed to remove ConfigElement from context after a copy action.");
               }
            }
            catch(Exception ex)
            {
               System.out.println(ex);
               ex.printStackTrace();
            }
         }
      }
   }
   public void dragEnter(DragSourceDragEvent e) 
   {}
   public void dragExit(DragSourceEvent e) 
   {}
   public void dragOver(DragSourceDragEvent e) 
   {}
   public void dropActionChanged(DragSourceDragEvent e) 
   {}

   /**
    * Attept to handle the dropping of a ConfigElement into this JTree.
    */
   public void drop(DropTargetDropEvent e)
   {
      if(e.getDropAction() == DnDConstants.ACTION_COPY)
      {
         System.out.println("Dropping a Copy...");
      }
      else if(e.getDropAction() == DnDConstants.ACTION_MOVE)
      {
         System.out.println("Dropping a Move...");
      }
      else
      {
         System.out.println("Dropping Something else: " + e.getDropAction());
      } 
      
      try
      {
         TreeModel model = this.getModel();
         ConfigContextModel config_model = (ConfigContextModel)model;
         DataFlavor my_flavor = new DataFlavor(ConfigElement.class, 
                  "VR Juggler Config Element");
         Transferable tr = e.getTransferable();
         
         // If this JTree has a valid JTreeModel and the incoming drop supports
         // the DataFlavor that we are trying to use.
         if(model instanceof ConfigContextModel && e.isDataFlavorSupported(my_flavor))
         {
            // Get the ConfigElement that we are transfering.
            ConfigElement elm = (ConfigElement)tr.getTransferData(my_flavor);

            // Make sure that we are not trying to add an element to ourselves.
            ConfigBroker broker = new ConfigBrokerProxy();
            java.util.List data_sources = config_model.getContext().getResources();
            for(Iterator itr = data_sources.iterator() ; itr.hasNext() ; )
            {
               java.util.List elm_list = broker.getElementsIn((String)itr.next());
               if(elm_list.contains(elm))
               {
                  System.out.println("You can not drag an Element into a "
                                   + "context in which it already exists.");
                  e.rejectDrop();
                  return;
               }
            }
            
            // Accept whatever action was sent to us.
            e.acceptDrop(e.getDropAction());
            
            // Make sure this add goes through successfully
            if (!broker.add(config_model.getContext(), elm))
            {
               e.rejectDrop();
               throw new Exception("Could not add dropped ConfigElement into context.");
            }
            System.out.println("Drop completed...");
            e.dropComplete(true);
         }
         else
         {
            e.rejectDrop();
         }
      }
      catch(Exception ex)
      {
         System.out.println(ex);
         ex.printStackTrace();
      }
   }
   
   public void dragEnter(DropTargetDragEvent e) 
   {;}
   public void dragExit(DropTargetEvent e) 
   {;}
   public void dragOver(DropTargetDragEvent e) 
   {;}
   public void dropActionChanged(DropTargetDragEvent e) 
   {;}
}

class ConfigContextCellRenderer
   extends DefaultTreeCellRenderer
{
   public ConfigContextCellRenderer()
   {
      ClassLoader loader = getClass().getClassLoader();
      try
      {
         // Get all the icons we'll ever need now so we can reuse them later
         mElementIcon = new ImageIcon(loader.getResource(
            "org/vrjuggler/jccl/editors/images/config_element.gif"));
         mPropertyIcon = new ImageIcon(loader.getResource(
            "org/vrjuggler/jccl/editors/images/property.gif"));
         mCategoryIcon = new ImageIcon(loader.getResource(
            "org/vrjuggler/jccl/editors/images/category.gif"));
      }
      catch (NullPointerException npe)
      {
         // Images aren't available ... oh well
      }
   }

   public Component getTreeCellRendererComponent(
                        JTree tree, Object node, boolean selected,
                        boolean expanded, boolean leaf, int row,
                        boolean focused)
   {
      // Get the default settings from the UI LAF
      super.getTreeCellRendererComponent(tree, node, selected,
                                         expanded, leaf, row, focused);

      Object value = ((DefaultMutableTreeNode)node).getUserObject();

      // Display the name of configuration elements
      if (value instanceof ConfigElement)
      {
         setText(((ConfigElement)value).getName());
         setFont(null);
         setIcon(mElementIcon);
      }
      // Display the name of properties
      else if (value instanceof PropertyDefinition)
      {
         setText(((PropertyDefinition)value).getName());
         setFont(tree.getFont().deriveFont(Font.ITALIC));
         setIcon(mPropertyIcon);
      }
      // Display the name of categories
      else if (value instanceof Category)
      {
         setText(((Category)value).getName());
         setFont(tree.getFont().deriveFont(Font.BOLD));
         setIcon(null);
      }

      return this;
   }
   private Icon mElementIcon;
   private Icon mPropertyIcon;
   private Icon mCategoryIcon;
}
