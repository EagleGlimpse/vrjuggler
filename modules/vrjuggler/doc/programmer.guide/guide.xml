<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="/home/users/patrick/src/Juggler/docs/stylesheet/docbook_ab.css" type="text/css"?>
<!DOCTYPE book SYSTEM "file:/home/users/patrick/XMLEditor-1.1.1a/examples/docbook/dtd/docbookx.dtd" [
]>
<book>
   <title>VR Juggler Programmer's Guide</title>
   <chapter id="ch1">
      <title>Introduction</title>
      <para>In this book, we present a "how-to" for writing VR Juggler applications. We will explain concepts used in VR Juggler and present carefully annotated example code whenever we can. There are two groups of people who should read this book:</para>
      <orderedlist>
         <listitem>
            <para>Those who are required to read it in order to do a project for work. To those in this category, fear not--VR Juggler is very simple to use after getting through the initial learning stages. It is a very powerful tool that will allow the creation of interesting and powerful applications very quickly.</para>
         </listitem>
         <listitem>
            <para>Those who are just interested in creating compelling, interesting VR applications. VR Juggler faciliates the construction of extremely powerful applications that will run on nearly any combination of hardware architecture and software platform.</para>
         </listitem>
      </orderedlist>
      <section>
         <title>Necessary Experience</title>
         <para>To help readers get the most from this book, recommendations follow to provide an idea of what previous experience is necessary. Various programming skills are needed, of course, but programming for VR requires more than just knowledge of a given programming language. VR Juggler takes advantage of many programming design patterns and advanced concepts to make it more powerful, more flexible, and more extensible. A good background in mathematics is helpful for performing the myriad of transformations that must be applied to three-dimensional geometry.</para>
         <section>
            <title>Required Background</title>
            <para>To get the most from this chapter, there are a few prerequisites:</para>
            <itemizedlist>
               <listitem>
                  <para>C++ programming experience</para>
               </listitem>
               <listitem>
                  <para>Some graphics programming background (e.g., OpenGL, OpenGL Performer, etc.)</para>
               </listitem>
               <listitem>
                  <para>Reasonable mathematical background (linear algebra knowledge is very useful)</para>
               </listitem>
            </itemizedlist>
            <para>For some of the advanced sections of this book, it is recommended that readers review the VR Juggler architecture book. This is optional, though it may be helpful in gaining a quicker understanding of some topics and concepts.</para>
         </section>
         <section>
            <title>Other VR Software Tools</title>
            <para>Readers who already have experience with other VR software development environments can easily skim through this book and find the relevant new information. The book is designed for easy skimming. Simply look at the headings to get a good determination of what should be read and what may be skipped.</para>
         </section>
         <section>
            <title>Organization</title>
            <para>This book is organized into five main chapters:</para>
            <orderedlist>
               <listitem>
                  <para>Introduction</para>
               </listitem>
               <listitem>
                  <para>Application basics: The introduction to the key VR Juggler application development concept, application objects. </para>
               </listitem>
               <listitem>
                  <para>Common helper classes: A description of useful classes provided to simplify writing applications.</para>
               </listitem>
               <listitem>
                  <para>Writing applications: The presentation of application development including how to get input from devices and how to write applications for each of the supported graphics application programmer interfaces (APIs).</para>
               </listitem>
               <listitem>
                  <para>Advanced topics: An extension of the previous chapters showing how to incorporate run-time reconfiguration into applications and how to write multithreaded applications.</para>
               </listitem>
            </orderedlist>
         </section>
      </section>
   </chapter>
   <chapter id="ch2">
      <title>Application Basics</title>
      <para>In VR Juggler, all applications are written as objects that are handled by the kernel. The objects are known as "application objects", and we will use that term frequently throughout this text. Application objects are introduced and explained within this section.</para>
      <section>
         <title>Application Object Overview</title>
         <para>VR Juggler uses the application object to create the VR environment with which the users interact. The application object implements interfaces needed by the VR Juggler virtual platform. (An interface is a collection of operations used to specify a service of a class or a component.)</para>
         <section>
            <title>No <function>main()</function> -- "Don't call me, I'll call you"</title>
            <para>Since VR Juggler applications are objects, developers do not write the traditional <function>main()</function> function. Instead, developers create an application object that implements a set of pre-defined interfaces. The VR Juggler kernel controls the application's processing time by calling the object's interface implementation methods.</para>
            <para>In common programs, the <function>main()</function> function defines the point where the thread of control enters the application. After the <function>main()</function> function is called, the application starts performing any necessary processing. When the operating system (OS) starts the program, it gives the <function>main()</function> function some unit of processing time. After the time unit (quantum) for the process expires, the OS performs what is called a "context switch" to change control to another process. VR Juggler accomplishes similar functionality but in a slightly different manner.</para>
            <para>The application objects correespond to processes in a normal OS. The kernel is the scheduler, and it allocations time to an application by invoking the methods of the application object. Because the kernel has additional information about the resources needed and used by the applications, it maintains a very strict schedule to define when the application is granted processing time. This is the basis to maintain coherence across the system.</para>
         </section>
         <section>
            <title>Application Objects Derive from Base Classes Specifc Graphics APIs</title>
            <para>The first step in defining an application object is to implement the basic interfaces defined by the kernel and the Draw Managers. There is a base class for the interface that the kernel expects (<classname>vjApp</classname>) and a base class for each Draw Manager interface (<classname>vjPfApp</classname>, <classname>vjGlApp</classname>, etc.). See <xref linkend="vjApp_hier_fig"/> for a visual representation of the application interface hierarchy. The kernel interface defined in <classname>vjApp</classname> specifies methods for initialization, shutdown, and execution of the application. The Draw Manager interfaces specified in the <classname>vj*App</classname> classes define the API-specific functions necessary to render the virtual environment. For example, a Draw Manager interface could have functions for drawing the scene and for initializing context-specific information.</para>
            <figure float="1" id="vjApp_hier_fig">
               <title><classname>vjApp</classname> hierarchy</title>
               <mediaobject>
                  <imageobject>
                     <imagedata fileref="myAppHierarchy.gif" format="GIF"/>
                  </imageobject>
               </mediaobject>
            </figure>
         </section>
         <section>
            <title>Writing an Application Means Filling in the Blanks</title>
            <para>To implement an application in VR Juggler, developers simply need to "fill in the blanks" of the appropriate interfaces. To simplify this process, there are default implementations of most methods in the interfaces. Hence, the user must only provide implementations for the aspects they want to customize. If an implementation is not provided in the user application object, the default is used, but it is important to know that in most cases, the default implementation does nothing.</para>
         </section>
      </section>
      <section>
         <title>Benefits of Application Objects</title>
         <para>The most common approach for VR application development is one where the application defines the <function>main()</function> function, and that <function>main()</function> function in turn calls library functions when needed. The library in this model only executes code when directed to do so by the application. As a result, the application developer is responsible for coordinating the execution of the different VR system components, and this can lead to complex applications.</para>
         <section>
            <title>Allow for Run-Time Changes</title>
            <para>As a virtual platform, VR Juggler does not use the model described above because VR Juggler needs to maintain control of the system components. This control is necessary to make changes to the virtual platform at run time. As the controller of the execution, the kernel always knows the current state of the applications, and therefore, it can manage safely the run-time reconfigurations of the virtual environment.With run-time reconfiguration, it is possible to switch applications, start new devices, reconfigure running devices, and send reconfiguration information to the application object.</para>
         </section>
         <section>
            <title>Low Coupling</title>
            <para>Application objects lead to a robust architecture as a result of low coupling and well-defined inter-object dependencies. The application interface defines the only communication path between the application and the virtual platform, and this allows restriction of inter-object dependencies. This decreased coupling allows changes in the system to be localized, and thus, changes to one object will not affect another unless the interface itself is changed. The result is code that is more robust and more extendable.</para>
            <para>Because the application is simply an object, it is possibly to load and unload applications dynamically. When the virtual platform initializes, it waits for an application to be passed to it. When the application is given to the VR Juggler kernel at run time, the kernel performs a few initialization steps and then executes the application.</para>
         </section>
         <section>
            <title>Allows Implementation Changes</title>
            <para>Since applications use a distinct interface to communicate with the virtual platform, changes to the implementation of the virtual platform do not affect the application. Changes could inlcude bug fixes, performance tuning, or new device support.</para>
         </section>
      </section>
      <section>
         <title>VR Juggler Startup</title>
         <para></para>
         <section>
            <title>No <function>main()</function>--Sort Of</title>
            <para>Previously, we explained how VR Juggler applications donot have a <function>main()</function> function. Further explanation is required. While it is true that user applications do not have a <function>main()</function> function because they areobjects, there must still be a <function>main()</function> somewhere that starts the system. This is because the operating system uses <function>main()</function> as the starting point for all applications. In simple VR Juggler applications, there is a <function>main()</function>, but it only starts the VR Juggler kernel and gives the kernel the application to run.</para>
         </section>
         <section>
            <title>Structure of a <function>main()</function> Function</title>
            <para>The following is a typical example of a <function>main()</function> function that will start the VR Juggler kernel and hand it an instance of a user application object. The specifics of what is happening in this code are described below.</para>
            <para><programlistingco>
                  <areaspec>
                     <area coords="5" id="simpleApp.main.body.create_kernel"/>
                     <area coords="6" id="simpleApp.main.body.app_instantiate"/>
                     <area coords="8" id="simpleApp.main.body.loadConfigFile"/>
                     <area coords="9" id="simpleApp.main.body.start"/>
                     <area coords="10" id="simpleApp.main.body.setApp"/>
                  </areaspec>
                  <programlisting>#include &lt;simpleApp.h&gt;

int main (int argc, char* argv[])
{
   vjKernel* kernel = vjKernel::instance();  // Get the kernel
   simpleApp* app   = new simpleApp();       // Create the app object

   kernel-&gt;loadConfigFile(...);              // Configure the kernel
   kernel-&gt;start();                          // Start the kernel thread
   kernel-&gt;setApplication(app);              // Give application to kernel

   while ( ! exit )
   {
     // sleep
   }
}</programlisting>
                  <calloutlist>
                     <callout arearefs="simpleApp.main.body.create_kernel">
                        <para>This line finds (and may create) the VR Juggler kernel. The kernel reference is stored in the handle so that we can use it later.</para>
                     </callout>
                     <callout arearefs="simpleApp.main.body.app_instantiate">
                        <para>We instantiate a copy of the user application object (simpleApp) here. Notice that we include the header file that defines the simpleApp class.</para>
                     </callout>
                     <callout arearefs="simpleApp.main.body.loadConfigFile">
                        <para>This statement represents the code that will be in the <function>main()</function> function for passing configuration files to the kernel's loadConfigFile() method. These config files may come from the command line or some other source. If reading the files from the command line, it can be as simple as looping through all the arguments and passing each one to the kernel.</para>
                     </callout>
                     <callout arearefs="simpleApp.main.body.start">
                        <para>As a result of this statement, the VR Juggler kernel begins running. It creates a new thread of execution for the kernel, and the kernel begins its internal processing. From this point on, any changes made reconfigure the kernel. These changes can come in the form of more configuration files or in the form of an application object to execute.At this point, it is important to notice that the kernel knows nothing about the application. Moreover, it needs to know nothing about the configuration files either. This demonstrates how the VR Juggler kernel executes independently from the user application. The kernel will simply work on its own controlling and configuring the system even without an application to run.</para>
                     </callout>
                     <callout arearefs="simpleApp.main.body.setApp">
                        <para>This statement finally tells the kernel what application it should run. The method call reconfigures the kernel so that it will now start invoking the application object's member functions. It is at this time that the application is now running in the VR system.</para>
                     </callout>
                  </calloutlist>
               </programlistingco><programlisting>#include &lt;simpleApp.h&gt;

int main (int argc, char* argv[])
{
   vjKernel* kernel = vjKernel::instance();  // Get the kernel
   simpleApp* app   = new simpleApp();       // Create the app object

   kernel-&gt;loadConfigFile(...);              // Configure the kernel
   kernel-&gt;start();                          // Start the kernel thread
   kernel-&gt;setApplication(app);              // Give application to kernel

   while ( ! exit )
   {
     // sleep
   }
}</programlisting></para>
            <section>
               <title>Get the kernel handle</title>
               <para><programlisting>vjKernel* kernel = vjKernel::instance();  // Get the kernel</programlisting></para>
               <para>This line finds (and may create) the VR Juggler kernel. The kernel reference is stored in the handle so that we can use it later.</para>
            </section>
            <section>
               <title>Create the application object</title>
               <para><programlisting>#include &lt;simpleApp.h&gt;
...
simpleApp* app = new simpleApp();    // Create the app object</programlisting></para>
               <para>We instantiate a copy of the user application object (simpleApp) here. Notice that we include the header file that defines the simpleApp class.</para>
            </section>
            <section>
               <title>Give onfiguration files to the kernel</title>
               <para><programlisting>kernel-&gt;loadConfigFile(...);         // Configure the kernel</programlisting></para>
               <para>This statement represents the code that will be in the <function>main()</function> function for passing configuration files to the kernel's <methodname>loadConfigFile()</methodname> method. These config files may come from the command line or some other source. If reading the files from the command line, it can be as simple as looping through all the arguments and passing each one to the kernel.</para>
            </section>
            <section>
               <title>Start the kernel thread</title>
               <para><programlisting>kernel-&gt;start();                    // Start the kernel thread</programlisting></para>
               <para>As a result of this statement, the VR Juggler kernel begins running. It creates a new thread of execution for the kernel, and the kernel begins its internal processing. From this point on, any changes made reconfigure the kernel. These changes can come in the form of more configuration files or in the form of an application object to execute.</para>
               <para>At this point, it is important to notice that the kernel knows nothing about the application. Moreover, it needs to know nothing about the configuration files either. This demonstrates how the VR Juggler kernel executes independently from the user application. The kernel will simply work on its own controlling and configuring the system even without an application to run.</para>
            </section>
            <section>
               <title>Give the kernel an application to run</title>
               <para><programlisting>kernel-&gt;setApplication(app);</programlisting></para>
               <para>This statement finally tells the kernel what application it should run. The method call reconfigures the kernel so that it will now start invoking the application object's member functions. It is at this time that the application is now running in the VR system.</para>
            </section>
         </section>
      </section>
      <section>
         <title>Kernel Loop</title>
         <para>Before proceeding into application object details, we must understand how VR Juggler calls the application, and we must know what a frame is. In the code above, the statement kernel-&gt;start() tells the kernel thread to start running. When the kernel begins its execution, it follows the sequence shown in <xref linkend="Kernel_seq_diag"/>. The specific methods being called are described in more detail in the following section. This diagram will be useful in understanding the order in which the application object methods are invoked.</para>
         <figure float="1" id="Kernel_seq_diag">
            <title>Kernel loop sequence</title>
            <mediaobject>
               <imageobject>
                  <imagedata fileref="AppInitAndMainLoop_modified.gif" format="GIF"/>
               </imageobject>
            </mediaobject>
         </figure>
         <section>
            <title>Definition of a Frame</title>
            <para>The VR Juggler kernel calls each of the methods in the application object based on a strictly scheduled <emphasis>frame of execution</emphasis>. The frame of execution is shown in <xref linkend="Kernel_seq_diag"/>; it makes up all the lines within the while(running) clause.</para>
            <para>During the frame of execution, the kernel calls the application methods and performs internal updates (the <methodname>updateAllData()</methodname> data call). Because the kernel has complete control over the frame, it can make changes at pre-defined "safe" times when the application is not doing any processing. At these times, the kernel can change the virtual platform configuration as long as the interface remains the same.</para>
            <para>The frame of execution also serves as a framework for the application. That is, the application can expect that when <methodname>preFrame()</methodname> is called, the devices have just been updated. Applications can rely upon the system being in well-defined stages of the frame when the kernel invokes the application object's methods.</para>
         </section>
      </section>
      <section>
         <title>Base Application Object Interface</title>
         <para>Within this chapter, we provide a brief overview of teh member functions from the base VR Juggler application interface. This interface is defined by <classname>vjApp</classname>, and the member functions are shown in <xref linkend="App_if_diag"/>. Refer to <xref linkend="Kernel_seq_diag"/> for a visual presentation of the order in which the methods are invoked.</para>
         <para>The base interface of the application object defines the following functions:</para>
         <itemizedlist>
            <listitem>
               <para><methodname>init()</methodname></para>
            </listitem>
            <listitem>
               <para><methodname>apiInit()</methodname></para>
            </listitem>
            <listitem>
               <para><methodname>preFrame()</methodname></para>
            </listitem>
            <listitem>
               <para><methodname>intraFrame()</methodname></para>
            </listitem>
            <listitem>
               <para><methodname>postFrame()</methodname></para>
            </listitem>
         </itemizedlist>
         <para>As previously descibed, the VR Juggler kernel calls these functions from its control loop to allocate processing time to them.These functions handle initialization and computation. Other member functions that can be used for reconfiguration, focus control, resetting, and exiting will be covered later in this book.</para>
         <figure id="App_if_diag">
            <title>Application object interface</title>
            <mediaobject>
               <imageobject>
                  <imagedata fileref="myAppHierarchy-highlightVjApp.gif" format="GIF"/>
               </imageobject>
            </mediaobject>
         </figure>
         <section>
            <title>Initialization</title>
            <para>The following is a description of the application objects related to the initialization of a VR Juggler application. The order of presentation is the same as the order of execution when the application is executed by the kernel.</para>
            <section>
               <title><methodname>vjApp::init()</methodname></title>
               <para>The <methodname>init()</methodname> method is called by the kernel to initialize any application data. When the kernel prepares to start a new application, it first calls <methodname>init()</methodname> to signal the application that it is about to be executed.</para>
               <section>
                  <title>Timing</title>
                  <para>This member function is called immediately after the kernel is told to start running the application and before any graphics API handling has been started by VR Juggler.</para>
               </section>
               <section>
                  <title>Uses</title>
                  <para>Typical applications will utilize this method to load data files, create lookup tables, or perform some steps that should only be done once per execution. In other words, this method is the place to perform any pre-processing steps needed by the application to set up its data structures.</para>
               </section>
            </section>
            <section>
               <title><methodname>vjApp::apiInit()</methodname></title>
               <para>This member function is for any graphics API-specific initialization required by the application. Data members that cannot be initialized until after the graphics API is started should be initialized here.<note>
                     <para>In OpenGL, there is no concept of initializing the API, so this method is not normally used in such applications.</para>
                  </note></para>
               <section>
                  <title>Timing</title>
                  <para>This member function is called after the graphics API has been started but before the kernel frame is started.</para>
               </section>
               <section>
                  <title>Uses</title>
                  <para>In most cases, scenegraph loading and other API-specific initialization should be done in this method.</para>
               </section>
            </section>
         </section>
         <section>
            <title>Frame Functions</title>
            <para>Once the application object has been initialized by the VR Juggler kernel, the kernel frame loop begins. Each frame, there are specific application object methods that are invoked, and understanding the timing and potential uses of these methods can improve the functionality of the immersive application. In some cases, it is possible to use these member functions to optimize the application to improve the frame rate and the level of interactivity.</para>
            <section>
               <title><methodname>vjApp::preFrame()</methodname></title>
               <para>The <methodname>preFrame()</methodname> method is called when the system is about to trigger drawing. This is the time that the application object should do any last-minute updates of data based on input device status. It is best to avoid doing any time-consuming computation in this method. The time used in this method contributes to the overall device latency in the system. The devices will not be resampled before rendering begins.</para>
               <section>
                  <title>Timing</title>
                  <para>This method is called immediately before triggering rendering of the current frame.</para>
               </section>
               <section>
                  <title>Uses</title>
                  <para>In general, this method should be reserved for "last-millisecond" data updates in response to device input (latency-critical code).</para>
               </section>
            </section>
            <section>
               <title><methodname>vjApp::intraFrame()</methodname></title>
               <para>The code in this method executes in parallel with the rendering method. That is, it executes while the current frame is being drawn. This is the place to put any processing that can be done in advance for the next frame. By doing parallel processing in this method, the application can increase its frame rate because drawing and computation can be parallelized. Special care must be taken to ensure that any data being used for rendering does not change while rendering is happening. One method for doing this is buffering. Use of synchronization primitives is not recommended because that technique could <emphasis>lower</emphasis> the frame rate.</para>
               <section>
                  <title>Timing</title>
                  <para>This method is invoked after rendering has been triggered but before the rendering has finished.</para>
               </section>
               <section>
                  <title>Uses</title>
                  <para>The primary use of this method is performing time-consuming computations, the results of which can be used in the next frame.</para>
               </section>
            </section>
            <section>
               <title><methodname>vjApp::postFrame()</methodname></title>
               <para>Finally, the <methodname>postFrame()</methodname> method is available for final processing at the end of the kernel frame loop. This is a good place to do any data updates that are not dependent upon input data and cannot be overlapped with the rendering process (see the discussion on <methodname>vjApp::intraFrame()</methodname> above).</para>
               <section>
                  <title>Timing</title>
                  <para>This method is invoked after rendering has completed but before VR Juggler updated devices and other internal data.</para>
               </section>
               <section>
                  <title>Uses</title>
                  <para>Some possible uses of this method include "cleaning up" after the frame has been rendered or synchronizing with external networkingor computational processes.</para>
               </section>
            </section>
         </section>
      </section>
      <section>
         <title>Draw Manager-Specific Application Classes</title>
         <para>Beyond the basic methods common to all applications, there are methods that are specific to a given Draw Manager. The application classes are extended for each of the specific Draw Managers. The graphics API-specific application classes derive from <classname>vjApp</classname> and extend this interface further. They adding extra "hooks" that support the abilities of that specific API.</para>
         <section>
            <title>OpenGL Application Class</title>
            <para>The OpenGL application base class adds several methods to the application interface that allow rendering of OpenGL graphics. The extensions to the base <classname>vjApp</classname> class are shown in <xref linkend="vjGlApp_class_diag"/>. In the following, we describe the method <methodname>vjGlApp::draw()</methodname>, the most important component of the interface. More details about the <classname>vjGlApp</classname> class are provided in a later chapter.</para>
            <figure float="1" id="vjGlApp_class_diag">
               <title><classname>vjGlApp</classname> interface extensions to <classname>vjApp</classname></title>
               <mediaobject>
                  <imageobject>
                     <imagedata fileref="myAppHierarchy-highlightVjOglApp.gif" format="GIF"/>
                  </imageobject>
               </mediaobject>
            </figure>
            <section>
               <title><methodname>vjGlApp::draw()</methodname></title>
               <para>The "draw function" is called by the OpenGL Draw Manager when it needs to render the current scene in an OpenGL graphics window.It is called for each active OpenGL context.</para>
            </section>
         </section>
         <section>
            <title>OpenGL Performer Application Class</title>
            <para>The OpenGL Performer application base class adds interface functions that deal with OpenGL Performer scenegraph. Some of the interface extensions are shown in <xref linkend="vjPfApp_class_diag"/>. The following is a description of only two methods in the <classname>vjPfApp</classname> interface. More detailed discussion on this clas is provided in later sections.</para>
            <figure id="vjPfApp_class_diag">
               <title><classname>vjPfApp</classname> interface extensions to <classname>vjApp</classname></title>
               <mediaobject>
                  <imageobject>
                     <imagedata fileref="myAppHierarchy-highlightVjPfApp.gif" format="GIF"/>
                  </imageobject>
               </mediaobject>
            </figure>
            <section>
               <title><methodname>vjPfApp::initScene()</methodname></title>
               <para>The <methodname>initScene()</methodname> member function is called when the application should create the scenegraph it will use.</para>
            </section>
            <section>
               <title><methodname>vjPfApp::getScene()</methodname></title>
               <para>The <methodname>getScene()</methodname> member function is called by the Performer Draw Manager when it needs to know what scenegraph it should render for the application.</para>
            </section>
         </section>
      </section>
   </chapter>
   <chapter id="ch3">
      <title>Helper Classes</title>
      <para>Within this chapter, we present information on some helper classes that are provided with VR Juggler. These classes are intended to make it easier for application programmers to write their code. Ultimately, we want application programmers to focus more on compelling immersive content and less on the many details that are involved with 3D graphics programming. The classes presented in this section focus on mathematical computations and on input from hardware devices. In particular, special attention is paid to the VR Juggler Input Manager device interfaces and proxies.</para>
      <section>
         <title><classname>vjVec3</classname> and <classname>vjVec4</classname></title>
         <para>This section is intended to provide an introduction to how the helper classes <classname>vjVec3</classname> and <classname>vjVec4</classname> work and how they can be used in VR Juggler applications. It begins with a high-level description of the classes which forms the necessary basis for understanding them in detail. Then, examples of how to use all the available operations in the interfaces for these classes are provided. It concludes with a description of the internal details of the classes. </para>
         <section>
            <title>High-Level Description</title>
            <para>The classes <classname>vjVec3</classname> and <classname>vjVec4</classname> are designed to work the same was as three- and four-dimensional mathematical vectors. That is, a <classname>vjVec3</classname> object can be thought of as a vector of the form &lt;x, y, z&gt;. Similarly, a <classname>vjVec4</classname> can be thought of as a vector of the form &lt;x, y, z, w&gt;. An existing understanding of mathematical vectors is sufficient to know how these classes can be used. The question then becomes, how are they used? We will get to that later, and you can skip ahead if you already understand such vectors. If vectors are an unfamiliar topic, you can also think of these classes as three- and four-element C++ arrays of floats respectively, but most benefits of the vector concept are lost with that simpler idea. Therefore, if you need to think of them as arrays, you should probably just use arrays until you feel more comfortable with vectors. Once you do, you are encouraged to come back and read further. </para>
            <para>Vectors are used typically to contain spatial data or something similar. For convenience, however, they can be visualized as a more general-purpose container for numerical data upon which well-defined operations can be performed. There is no need to constrain thinking of them as only holding the coordinates for some point in space or some other limited-scope use. VR Juggler's vectors retain this generality and can be used wherever vectors come in handy. </para>
            <para><classname>vjVec3</classname> and <classname>vjVec4</classname>, as specific implementations of mathematical vectors, hide vector operations on single-precision floating-point numbers (<type>float</type>) behind a simple-to-use interface. For a single vector, the following standard vector operations are available:</para>
            <itemizedlist>
               <listitem>
                  <para>Inversion (changing the sign of all elements)</para>
               </listitem>
               <listitem>
                  <para>Normalization</para>
               </listitem>
               <listitem>
                  <para>Calculation of length</para>
               </listitem>
               <listitem>
                  <para>Multiplication by a scalar</para>
               </listitem>
               <listitem>
                  <para>Division by a scalar</para>
               </listitem>
               <listitem>
                  <para>Conversion to a Performer vector</para>
               </listitem>
            </itemizedlist>
            <para>For two vectors, the following operations can be performed:</para>
            <itemizedlist>
               <listitem>
                  <para>Assignment</para>
               </listitem>
               <listitem>
                  <para>Equality/inequality comparison</para>
               </listitem>
               <listitem>
                  <para>Dot product</para>
               </listitem>
               <listitem>
                  <para>Cross product (<classname>vjVec3</classname> only)</para>
               </listitem>
               <listitem>
                  <para>Addition</para>
               </listitem>
               <listitem>
                  <para>Subtraction</para>
               </listitem>
            </itemizedlist>
            <para>Knowing this and keeping in mind that <classname>vjVec3</classname> and <classname>vjVec4</classname> can be thought of at this high level, using them should be a snap.</para>
         </section>
         <section>
            <title>Using <classname>vjVec3</classname> and <classname>vjVec4</classname></title>
            <para>With an understanding of these classes as standard mathematical vectors, it is time to learn how to deal with them at the C++ level. In some cases, the mathematical operators are overloaded to simplify user code; in other cases, a named method must be invoked on an object. Before any of that, however, make sure that the source file includes either <filename>Math/vjVec3.h</filename>, <filename>Math/vjVec4.h</filename>, or both as necessary. From here on, the available operations are presented in the order they were listed in the previous section. We begin with creating the objects and setting their values. </para>
            <section>
               <title>Creating Vectors and Setting Their Values</title>
               <para>Before doing anything with vectors, some must be created. The examples here use <classname>vjVec3</classname>s, but the example is equally applicable to <classname>vjVec4</classname>. To create a <classname>vjVec3</classname>, the default constructor which initializes the vector to &lt;0.0, 0.0, 0.0&gt;:</para>
               <programlisting>vjVec3 vec1;</programlisting>
               <para>After creating the vector <varname>vec1</varname>, its elements can be assigned values all at once as follows:</para>
               <programlisting>vec1.set(1.0, 1.5, -1.0);</programlisting>
               <para>or individually::</para>
               <programlisting>vec1[0] = 1.0;
vec1[1] = 1.5;
vec1[2] = -1.0;</programlisting>
               <para>Note that in the last example, the individual elements of the vector can be accessed exactly as with a normal array. To do the above steps all at once when the vector is created, give the element values when declaring the vector:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0);</programlisting>
               <para>All of the above code has exactly the same results but accomplishes them in different ways. This flexibility is just one of the ways that VR Juggler vectors are more powerful than C++ arrays (of the same size, of course).</para>
            </section>
            <section>
               <title>Inversion (Finding the Negative of a Vector)</title>
               <para>Once a vector is created, the simplest operation that can be performed on it is finding its inverse. The following code demonstrates just that:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2;

vec2 = -vec1;</programlisting>
               <para>The vector <varname>vec2</varname> now has the value &lt;-1.0, -1.5, 1.0&gt;. That is all there is to it. (Readers interested in details should node that the above does a copy operation to return the negative values.)</para>
            </section>
            <section>
               <title>Normalization</title>
               <para>Normalizing a vector is another simple operation (at the interface level anyway). The following code normalizes a vector:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0);

vec1.normalize();</programlisting>
               <para>The vector <varname>vec1</varname> is now normalized. Clean and simple.</para>
               <para>Besides normalizing a given vector, a vector can be tested to determine if it has already been normalized. This is done as follows (assuming the vector <varname>vec</varname> has already been declared before this point):</para>
               <programlisting>if ( vec.isNormalized() )
{
   // Go here if vec is normalized
}</programlisting>
               <para>This only works with <classname>vjVec3</classname>s, however.</para>
            </section>
            <section>
               <title>Length Calculation</title>
               <para>Part of normalizing a vector requires finding its length first. To get a vector's length, do the following:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0);
float length;

length = vec1.length();</programlisting>
               <para>In this case, <varname>length</varname> is assigned the value 2.061553 (or more accurately, the square root of 4.25). Finding the length of a vector appears simple from the programmer's perspective, but it has some hidden costs. Namely, it requires a square root calculation. For optimization purposes, the <classname>vjVec3</classname> class (but not <classname>vjVec4</classname>) provides a method called <methodname>lengthSquared()</methodname> that returns the length of the vector without calculating the square root.</para>
            </section>
            <section>
               <title>Multiplication by a Scalar</title>
               <para>The VR Juggler vector classes provide an easy way to multiply a vector by a scalar. There are several ways to do it depending on what is rquired. Examples of each method follow.</para>
               <para>To multiply a vector by a scalar and store the result in another vector, do the following:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2;

vec2 = 3 * vec1;</programlisting>
               <para>(The order of the factors in the multiplication can be swapped depending on preference or need.) Here, <varname>vec2</varname> gets the value &lt;3.0, 4.5, -3.0&gt;.</para>
               <para>To multiply a vectory by a scalar and store the result in the same vector, do the following:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0);

vec1 *= 3;</programlisting>
               <para>After this, <varname>vec1</varname> has the value &lt;3.0, 4.5, -3.0&gt;.</para>
            </section>
            <section>
               <title>Division by a Scalar</title>
               <para>Very similar to multiplying by a scalar, division by scalars is also possible. While the examples are almost identical, they are provided here for clarity.</para>
               <para>To divide a vector by a scalar and store the result in another vector, do the following:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2;

vec2 = vec1 / 3;</programlisting>
               <para>Here, <varname>vec2</varname> gets the value &lt;0.333333, 0.5, -0.333333&gt;. Note that the scalar must come after the vector because the operation would not make sense otherwise.</para>
               <para>To divide a vectory by a scalar and store the result in the same vector, do the following:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0);

vec1 /= 3;</programlisting>
               <para>After this, <varname>vec1</varname> has the value &lt;0.333333, 0.5, -0.333333&gt;.</para>
            </section>
            <section>
               <title>Converting to an OpenGL Performer Vector</title>
               <para>SGI's OpenGL Performer likes to work with its own <classname>pfVec3</classname> class, and to facilitate the use of it with <classname>vjVec3</classname>, two conversion functions are provided for converting a <classname>vjVec3</classname> to a <classname>pfVec3</classname> and vice versa. The first works as follows: </para>
               <programlisting>vjVec3 vj_vec;
pfVec3 pf_vec;

// Do stuff to vj_vec...

pf_vec = vjGetPfVec(vj_vec);</programlisting>
               <para> where <varname>vj_vec</varname> is passed by reference for efficiency. (<varname>pf_vec</varname> gets a copy of a <classname>pfVec3</classname>.) To convert a <classname>pfVec3</classname> to a <classname>vjVec3</classname>, do the following:</para>
               <programlisting>pfVec3 pf_vec;
vjVec3 vj_vec;

// Do stuff to pf_vec...

vj_vec = vjGetVjVec(pf_vec);</programlisting>
               <para>Here again, <varname>pf_vec</varname> is passed by reference for efficiency and <varname>vj_vec</varname> gets a copy of a <classname>vjVec3</classname>. Both of these functions are found in the header <filename>Kernel/Pf/vjPfUtil.h</filename>.</para>
            </section>
            <section>
               <title>Assignment</title>
               <para>We have already demonstrated vector assignment, though it was not pointed out explicitly. It works just as vector assignment in mathematics. The C++ code that does assignment is as follows:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2;

vec2 = vec1;</programlisting>
               <para>After the assignment, <varname>vec2</varname> has the value &lt;-1.0, -1.5, 1.0&gt;. Ta da! Note that this is a copy operation which is the case for all types of assignments of VR Juggler vectors.</para>
            </section>
            <section>
               <title>Equality/Inequality Comparison</title>
               <para>To compare the equality of two vectors, there are three available methods (one is just the complement of the other, though):</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1.equal(vec2) )
{
   // Go here if vec1 and vec2 are equal.
}</programlisting>
               <para>or</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1 == vec2 )
{
   // Go here if vec1 and vec2 are equal.
}</programlisting>
               <para>or</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1 != vec2 )
{
   // Go here if vec1 and vec2 are not equal.
}</programlisting>
               <para>Choose whichever method is most convenient.</para>
            </section>
            <section>
               <title>Dot Product</title>
               <para>Given two vectors, finding the dot product is often needed. VR Juggler's vectors provide a way to do this quickly so that programmers can save themselves the time of typing in the formula over and over. It works as follows:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);
float dot_product;

dot_product = vec1.dot(vec2);</programlisting>
               <para>Now, <varname>dot_prodcut</varname> has the value 4.0.</para>
            </section>
            <section>
               <title>Cross Product (<classname>vjVec3</classname> only)</title>
               <para>Besides the dot product of two vectors, the cross product is another commonly needed result. It is calculated thusly:</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1.cross(vec2);</programlisting>
               <para>The result is that <varname>vec3</varname> gets a copy of <varname>vec1</varname> cross <varname>vec2</varname>.</para>
            </section>
            <section>
               <title>Addition</title>
               <para>Adding two vectors can be done one of two ways. The first method returns a resulting vector, and the second method performs the addition and stores the result in the first vector. </para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1 + vec2;</programlisting>
               <para>Now, <varname>vec3</varname> has the value &lt;2.5, 2.5, -2.0&gt;.</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

vec1 += vec2;</programlisting>
               <para>This time, <varname>vec1</varname> has the value &lt;2.5, 2.5, -2.0&gt;.</para>
            </section>
            <section>
               <title>Subtraction</title>
               <para>Subtracting two vectors gives the same options as addition, and while the code is nearly identical, it is provided for the sake of clarity.</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1 - vec2;</programlisting>
               <para>Now, <varname>vec3</varname> has the value &lt;-0.5, 0.5, 0.0&gt;.</para>
               <programlisting>vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

vec1 -= vec2;</programlisting>
               <para>In this case, <varname>vec1</varname> has the value &lt;-0.5, 0.5, 0.0&gt;.</para>
            </section>
            <section>
               <title>Full Transformation by a Matrix</title>
               <para>It is often helpful to apply a transformation to a vector. Transformations are represented by a matrix, so it is necessary to multiply a matrix and a vector. The method <methodname>xformFull()</methodname> does this job. For the following example, assume that there is a<classname>vjMatrix</classname> transformation matrix <varname>xform_mat</varname>:</para>
               <programlisting>vjVec3 vec(1.0, 1.0, 1.0);

vec.xformFull(xform_mat);</programlisting>
               <para>Depending on the transformations contained within <varname>xform_mat</varname>, <varname>vec</varname> will be transformed fully. The operation as a mathematical equation would be:</para>
               <equation>
                  <alt>V' = M * V</alt>
                  <graphic/>
               </equation>
               <para>where <varname>V</varname> and <varname>V'</varname> are vectors and <varname>M</varname> is a 4x4 transformation matrix.</para>
            </section>
            <section>
               <title>Partial Transformation by a Matrix</title>
               <para>Besides full transformations, it is possible to apply all transformations in a matrix except translation. (The usefulness of this is left as an exercise for the reader.) Again assume that there is a <classname>vjMatrix</classname> transformation matrix <varname>xform_mat</varname>:</para>
               <programlisting>vjVec3 vec(1.0, 1.0, 1.0);

vec.xformVec(xform_mat);</programlisting>
               <para>In this case, all transformations in <varname>xform_mat</varname> except translation will be applied to <varname>vec</varname>. The naming convention here is not terribly helpful, but this documentation is intended to get around that.</para>
            </section>
            <section>
               <title>The Gory Details</title>
               <para>The details behind <classname>vjVec3</classname> and <classname>vjVec4</classname> really are not all that gory. Internally, they are represented as three- and four-element arrays of <type>float</type>s respectively. Access to these arrays is provided through the public member variable <varname>vec</varname>. For example, this access can be used in the following way:</para>
               <programlisting>vjVec3 pos(4.0, 1.0982, 10.1241);

glVertex3fv(pos.vec);</programlisting>
               <para>Granted, this particular example is rather silly and much slower than just listing the values as the individual arguments to <function>glVertex3f()</function>, but it should get the point across.</para>
               <para>In general, the <varname>vec</varname> member variable should be treated very carefully. Access to it is provided mainly so that operations similar to this example can be performed quickly. An example of abusing access to <varname>vec</varname> follows:</para>
               <programlisting>vjVec4 my_vec;

my_vec.vec[0] = 4.0;
my_vec.vec[1] = 1.0982;
my_vec.vec[2] = 10.1241;
my_vec.vec[3] = 1.0;</programlisting>
               <para>Do not do this. It can be confusing to readers of the code who do not necessarily need to know the details of the internal representation. Instead, use one of the methods described above for creating vectors and assigning the elements values.</para>
            </section>
         </section>
      </section>
      <section>
         <title>The <classname>vjMatrix</classname> Helper Class</title>
         <para>This document is intended to provide an introduction into how the helper class <classname>vjMatrix</classname> works and how it can be used in VR Juggler applications. It begins with a high-level description of the class, which forms the necessary basis for understanding it in detail. Then, examples of how to use all the available operations in the interfaces for the class are provided. It concludes with a description of the internal C++ details of <classname>vjMatrix</classname>.</para>
         <section>
            <title>High-Level Description</title>
            <para>Abstractly, <classname>vjMatrix</classname> represents a 4x4 matrix of single-precision floating-point values. The class includes implementations of the standard matrix operations such as transpose, scale, and multiply. More specifically, it is a mechanism to facilitate common matrix operations used in computer graphics, especially those associated with a transform matrix. On the surface, it is nearly identical to a 4x4 C++ array of <type>float</type>s, but there is one crucial difference: a <classname>vjMatrix</classname> keeps its internal matrix in column-major order rather than in row-major order. More detail on this is given below, but this is done because OpenGL maintains its internal matrices using the same memory layout. At the conceptual level, this does not matter--it is related only to the matrix representation in the computer's memory. Access to the elements is still in row-major order. In any case, understanding how C++ multidimensional arrays work means understanding 90% of what there is to know about <classname>vjMatrix</classname>. The class provides a degree convenience not found with a normal C++ array, especially when doing OpenGL programming. The complications surrounding the <classname>vjMatrix</classname> class are identical to those with OpenGL matrix handling, and with an understanding of that, then all that is left to learn is the interface of <classname>vjMatrix</classname>.</para>
            <para>As a representation of mathematical matrices, <classname>vjMatrix</classname> implements several common operations performed on matrices to relieve the users of the class of some tedious, repetitive effort. The general mathematical operations are:</para>
            <itemizedlist>
               <listitem>
                  <para>Assignment</para>
               </listitem>
               <listitem>
                  <para>Equality/inequality comparison</para>
               </listitem>
               <listitem>
                  <para>Transposing</para>
               </listitem>
               <listitem>
                  <para>Finding the inverse</para>
               </listitem>
               <listitem>
                  <para>Addition</para>
               </listitem>
               <listitem>
                  <para>Subtraction</para>
               </listitem>
               <listitem>
                  <para>Multiplication</para>
               </listitem>
               <listitem>
                  <para>Scaling by a scalar value</para>
               </listitem>
            </itemizedlist>
            <para>The operations well-suited for use with computer graphics are</para>
            <itemizedlist>
               <listitem>
                  <para>Creating an identity matrix quickly</para>
               </listitem>
               <listitem>
                  <para>Zeroing a matrix in a single step</para>
               </listitem>
               <listitem>
                  <para>Creating an XYZ, a ZYX, or a ZXY Euler rotation matrix</para>
               </listitem>
               <listitem>
                  <para>Constraining rotation about a specific axis or axes</para>
               </listitem>
               <listitem>
                  <para>Making a matrix using direction cosines</para>
               </listitem>
               <listitem>
                  <para>Making a matrix from a quaternion</para>
               </listitem>
               <listitem>
                  <para>Making a rotation transformation matrix about a single axis</para>
               </listitem>
               <listitem>
                  <para>Making a translation transformation matrix</para>
               </listitem>
               <listitem>
                  <para>Making a scale transformation matrix</para>
               </listitem>
               <listitem>
                  <para>Extracting specific transformation information</para>
               </listitem>
               <listitem>
                  <para>Converting to an OpenGL Performer matrix</para>
               </listitem>
            </itemizedlist>
            <para>What is presented here involves some complicated concepts that are far beyond the scope of this documentation. Without an understanding of matrix math (linear algebra) and an understanding of how transformation matrices work in OpenGL, this document will not be very useful. It is highly recommended that readers be familiar with these topics before proceeding. Otherwise, with this high-level description in mind, we now continue on to explain the <classname>vjMatrix</classname> class at the C++ level.</para>
         </section>
         <section>
            <title>Using <classname>vjMatrix</classname></title>
            <para>Keeping the idea of a normal mathematical matrix in mind, we are now ready to look at the C++ use of the <classname>vjMatrix</classname> class. Most of the interface is defined using methods, but there are a scant few cases where mathematical operators have been overloaded to make code easier to read. Before going any further, whenever using a <classname>vjMatrix</classname>, make sure to include <filename>Math/vjMatrix.h</filename> first. The operations presented above are now described in detail in the order in which they were listed above. We begin with creating the objects and setting their values.</para>
         </section>
         <section>
            <title>Creating Matrices and Setting Their Values</title>
            <para>Before doing anything with matrices, some must be created first. To create a <classname>vjMatrix</classname>, the default constructor can be used. Itinitializes the matrix to be an identity matrix:</para>
            <programlisting>vjMatrix mat1;</programlisting>
            <para>After creating this matrix <varname>mat1</varname>, its 16 elements can be assigned values all at once as follows:</para>
            <programlisting>mat1.set(0.0, 1.0, 2.3, 4.1,
         8.3, 9.0, 2.2, 1.0,
         5.6, 9.9, 9.7, 8.2,
         3.8, 0.9, 2.1, 0.1);</programlisting>
            <para>or with a <type>float</type>array:</para>
            <programlisting>float mat_vals[16] =
{
   0.0, 8.3, 5.6, 3.8,
   1.0, 9.0, 9.9, 0.9,
   2.3, 2.2, 9.7, 2.1,
   4.1, 1.0, 1.0, 0.1
};

mat1.set(mat_vals);</programlisting>
            <para>Note that when using the explicit listing of values to <methodname>set()</methodname>, they are specified in row-major order. When put into a 16-element array of <type>float</type>s, however, they must be ordered so that they can be copied into the <classname>vjMatrix</classname> in column-major order. This is the one exception in the interface where access is column-major (which probably means that the interface has a bug in it).</para>
            <para>To set all the values of a new matrix in one step, they can be given as arguments when you declare the matrix:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1,
              8.3, 9.0, 2.2, 1.0,
              5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);</programlisting>
            <para>All of the above code has exactly the same results but accomplishes those results in different ways.</para>
            <para>To read the elements in a <classname>vjMatrix</classname> object, programmers can use either the overloaded [] operator or the overloaded () operator. The overloaded [] operator returns the specified row of the <classname>vjMatrix</classname>, and an element in that row can then be read using [] again. The code looks exactly the same as with a normal C++ two-dimensional array:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
float val;

val = mat1[3][0];</programlisting>
            <para>Here, <varname>val</varname> is assigned the value 3.8. Using the overloaded () operator results in code that looks similar to the way the matrix element would be referenced in mathematics:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
float val;

val = mat1(3, 0);</programlisting>
            <para>Again, <varname>val</varname> is assigned the value 3.8. Both of these operations are row-major.</para>
         </section>
         <section>
            <title>Assignment</title>
            <para>Assigning one <classname>vjMatrix</classname> to another happens using the normal = operator as follows:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2;

mat2 = mat1;</programlisting>
            <para>This makes a <emphasis>copy</emphasis> of <varname>mat1</varname> in <varname>mat2</varname> which can be a slow operation.</para>
         </section>
         <section>
            <title>Equality/Inequality Comparison</title>
            <para>To compare the equality of two matrices, you have three available methods (one is just the complement of the other, though):</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

if ( mat1.equal(mat2) )
{
   // Go here if mat1 and mat2 are equal.
}</programlisting>
            <para>or</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

if ( mat1 == mat2 )
{
   // Go here if mat1 and mat2 are equal.
}</programlisting>
            <para>or</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

if ( mat1 != mat2 )
{
   // Go here if mat1 and mat2 are not equal.
}</programlisting>
            <para>Choose whichever method is most convenient.</para>
         </section>
         <section>
            <title>Transposing</title>
            <para>The transpose operation works conceptually as <equation>
                  <alt>matrix1 = transpose(matrix2)</alt>
                  <graphic/>
               </equation>. The code is then: </para>
            <programlisting>vjMatrix mat1;
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

mat1.transpose(mat2);</programlisting>
            <para>The result is stored in <varname>mat1</varname>. <varname>mat2</varname> is passed as a reference for efficiency.</para>
         </section>
         <section>
            <title>Finding the Inverse</title>
            <para>The transpose operation works conceptually as <equation>
                  <alt>matrix1 = inverse(matrix2)</alt>
                  <graphic/>
               </equation>. The code is then: </para>
            <programlisting>vjMatrix mat1;
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

mat1.invert(mat2);</programlisting>
            <para>The result is stored in <varname>mat1</varname>. <varname>mat2</varname> is passed as a reference for efficiency.</para>
         </section>
         <section>
            <title>Addition</title>
            <para>For the addition operation, the interface is defined so that the sum of two matrices is stored in a third. There are two ways to do addition with <classname>vjMatrix</classname>: using the add() method or using the overloaded + operator. Use of the former is recommended, but the latter can be used if one prefers that style of programming. Examples of both methods follow. The first block of code only declares the <classname>vjMatrix</classname> objects.</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat3;</programlisting>
            <para>Using the <methodname>add()</methodname> method:</para>
            <programlisting>mat3.add(mat1, mat2);</programlisting>
            <para>Using the overloaded + operator: </para>
            <programlisting>mat3 = mat1 + mat2;</programlisting>
            <para>The result is stored (via a copy) in <varname>mat3</varname>.</para>
         </section>
         <section>
            <title>Subtraction</title>
            <para>For the subtraction operation, the interface is defined so that the difference of two matrices is stored in a third. There are two ways to do subtraction with <classname>vjMatrix</classname>: using the <methodname>sub()</methodname> method or using the overloaded - operator. It is recommended that developers use the former, but the latter can be used for stylistic purposes. Examples of both methods follow. The first block of code only declares the <classname>vjMatrix</classname> objects. </para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat3;</programlisting>
            <para>Using the <methodname>sub()</methodname> method:</para>
            <programlisting>mat3.sub(mat1, mat2);</programlisting>
            <para>Using the overloaded - operator:</para>
            <programlisting>mat3 = mat1 - mat2;</programlisting>
            <para>The result is stored (via a copy) in <varname>mat3</varname>.</para>
         </section>
         <section>
            <title>Multiplication</title>
            <para>As in the case of addition and subtraction, the multiplication interface is defined so that the product of two matrices is stored in a third. This is likely to be the operation used most often since transformation matrices are constructed through multiplication of different transforms. For normal matrix multiplication, there are two ways to do multiplication with <classname>vjMatrix</classname>: using the <methodname>mult()</methodname> method or using the overloaded * operator. We recommend the use of the <methodname>mult()</methodname>method, but the overloaded * operator can be used by those who prefer that style of programming. Examples of both methods follow. The first block of code only declares the <classname>vjMatrix</classname> objects. </para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat3;</programlisting>
            <para>Using the <methodname>mult()</methodname> method:</para>
            <programlisting>mat3.mult(mat1, mat2);</programlisting>
            <para>Using the overloaded * operator:</para>
            <programlisting>mat3 = mat1 * mat2;</programlisting>
            <para>The result is stored (via a copy) in <varname>mat3</varname>.</para>
            <para>There are two more multiplication operations provided that help in handling the order of the matrices when they are multiplied. These two extra operations do post-multiplication and pre-multiplication of two matrices. An example of post-multiplication is: </para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

mat1.postMult(mat2);</programlisting>
            <para>Conceptually, the operation is <equation>
                  <alt>mat1 = mat1 * mat2</alt>
                  <graphic/>
               </equation> so that the second matrix (<varname>mat2</varname>) comes as the second factor. The same result can be achieved using the overloaded *= operator:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

mat1 *= mat2;</programlisting>
            <para>An example of pre-multiplication is:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

mat1.preMult(mat2);</programlisting>
            <para>Here, the conceptual operation is <equation>
                  <alt>mat1 = mat2 * mat1</alt>
                  <graphic/>
               </equation> so that the second matrix (<varname>mat2</varname>) comes as the first factor. In both cases, the result of the multiplication is stored in <varname>mat1</varname>.</para>
         </section>
         <section>
            <title>Scaling by a Scalar Value</title>
            <para>Scaling the values of a matrix by a scalar value can be done using two different methods: the <methodname>scale()</methodname> method or the overloaded * and / operators that take a single scalar value and returns a <classname>vjMatrix</classname>. As with the preceding operations, we recommend the use of the former, but the latter is available for those who want it. Examples of both methods follow. First, using the <methodname>scale()</methodname> method works as:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2;

mat2 = mat1.scale(3.0);</programlisting>
            <para>Using the overloaded * operator works as:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2;

mat2 = mat1 * 3.0;</programlisting>
            <para>or</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2;

mat2 = 3.0 * mat1;</programlisting>
            <para>Using the overloaded / operator works as:</para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);
vjMatrix mat2;

mat2 = mat1 / 3.0;</programlisting>
            <para>In all cases, the result of the scaling is stored (via a copy) in <varname>mat2</varname>.</para>
         </section>
         <section>
            <title>Creating an Identity Matrix Quickly</title>
            <para>In computer graphics, an identity matrix is often needed when doing transformations. Because of this, <classname>vjMatrix</classname> provides a method for converting a matrix into an identity matrix in a single step (at the user code level anyway): </para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

mat1.makeIdent();</programlisting>
            <para>Of course, simply declaring <varname>mat1</varname> with no arguments would achive the same result, but that is not such an interesting example.</para>
         </section>
         <section>
            <title>Zeroing a Matrix in a Single Step</title>
            <para>Before using a matrix, it is often helpful to zero it out to ensure that there is no pollution from previous use. With a <classname>vjMatrix</classname>, this can be done in one step: </para>
            <programlisting>vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
              3.8, 0.9, 2.1, 0.1);

mat1.zero();</programlisting>
            <para>The result is that all elements of <varname>mat1</varname> are now 0.0.</para>
         </section>
         <section>
            <title>Creating an XYZ, a ZYX, or a ZXY Euler Rotation Matrix</title>
            <para>All the rotation information for a transform can be contained in a single matrix using the methods for making an XYZ, a ZYX, or a ZXY Euler matrix. Code for all three follows:</para>
            <programlisting>vjMatrix mat1;
float x_rot = 0.4, y_rot = 0.541, z_rot = 0.14221;

mat1.makeXYZEuler(x_rot, y_rot, y_rot);
mat1.makeZYXEuler(z_rot, y_rot, x_rot);
mat1.makeZXYEuler(z_rot, x_rot, y_rot);</programlisting>
            <para>In every case, the matrix is zeroed before the rotation transformation is stored. The result of the above code is that <varname>mat1</varname> is a ZXY Euler rotation matrix. The previous two operations are destroyed.</para>
            <para>The rotation values can be read from a matrix that previously had one of the above operations applied to it. This is done as follows:</para>
            <programlisting>float x_rot, y_rot, z_rot;

mat1.makeXYZEuler(x_rot, y_rot, y_rot);
mat1.makeZYXEuler(z_rot, y_rot, x_rot);
mat1.makeZXYEuler(z_rot, x_rot, y_rot);</programlisting>
            <para>In real code, one would use only the call that is appropriate for extracting the rotation values from <varname>mat</varname>. The <type>float</type> variables are passed by reference to the method so that the rotation values can be returned in them.</para>
         </section>
         <section>
            <title>Constraining Rotation About a Specific Axis or Axes</title>
            <para>In a matrix that has rotations about more than one axis, it may be useful to get a transformation matrix that constrains the rotation to certain axes. A method is provided to do just this. It is called <methodname>constrainRotAxis()</methodname>, and it is used as follows (assume that <varname>old_mat</varname> is already defined as a transformation matrix with rotations about all three axes):</para>
            <programlisting>vjMatrix new_mat;

old_mat.constrainRotAxis(true, false, false, new_mat);</programlisting>
            <para>The result of this is that <varname>new_mat</varname> is a transformation matrix with all of <varname>old_mat</varname>'s transformations with the exception that rotation is constrained about the x-axis alone. The first three arguments are Boolean values that specify the axis constraints for the x-, y-, and z-axes respectively. <varname>new_mat</varname> is passed by reference, and the result of the constrained transformations are stored in it.</para>
         </section>
         <section>
            <title>Making a Matrix Using Direction Cosines</title>
            <para>Creating a direction cosine matrix is another part of the <classname>vjMatrix</classname> interface. The method requires values for the x-, y-, and z-axes of the secondary coordinate system in terms of the first. These must be passed as objects of type <classname>vjVec3</classname>. Use of the method is shown below (assuming that <varname>sec_x_axis</varname>, <varname>sec_y_axis</varname>, and <varname>sec_z_axis</varname> are already defined and have appropriate values):</para>
            <programlisting>vjMatrix mat;

mat.makeDirCos(sec_x_axis, sec_y_axis, sec_z_axis);</programlisting>
            <para>The result is that <varname>mat</varname> becomes a direction cosine matrix.</para>
         </section>
         <section>
            <title>Making a Matrix from a Quaternion</title>
            <para>Converting a quaternion to its corresponding matrix is possible with <classname>vjMatrix</classname> objects. Two methods are provided to do this, each taking a different type of argument as the quaternion to be converted. The first takes a four-element array of <type>float</type>s: </para>
            <programlisting>vjMatrix mat;
float quat[4];

// Fill in quat...

mat.makeQuaternion(quat);</programlisting>
            <para>Here, <varname>quat</varname> is assigned its values appropriately. The other version takes a reference to a <classname>vjQuat</classname> object:</para>
            <programlisting>vjMatrix mat;
vjQuat quat;

// Fill in quat...

mat.makeQuaternion(quat);</programlisting>
            <para>The result in both cases is that <varname>mat</varname> is the transformation matrix represented by the quaternion.</para>
         </section>
         <section>
            <title>Making a Rotation Transformation Matrix About a Single Axis</title>
            <para>To make a rotation matrix where the rotation is about a single axis, a simple method is provided as part of the <classname>vjMatrix</classname> interface. It takes the rotation about the axis in degrees and the axis vector as a <classname>vjVec3</classname> object. Its use is as follows:</para>
            <programlisting>vjMatrix mat;
vjVec3 axis(1.0, 0.0, 0.0);

mat.makeRot(45.0, axis);</programlisting>
            <para>The <methodname>makeRot()</methodname> method causes <varname>mat</varname> to become a transformation matrix with only the given rotation. This rather boring example therefore illustrates making a transformation matrix with only a 45° rotation about the x-axis.</para>
            <para>Further capabilities are available with the rotations. Similar to the <methodname>preMult()</methodname> and <methodname>postMult()</methodname> methods described earlier, onecan perform pre-rotations and post-rotations in degrees about a given axis on a matrix. To do a pre-rotation, the code would look similar to the following:</para>
            <programlisting>vjMatrix mat1, mat2;
vjVec3 axis(1.0, 0.0, 0.0):

// Perform various transformations on mat2...

mat1.preRot(45.0, axis, mat2);</programlisting>
            <para>where <varname>axis</varname> is passed by reference. The result is that <varname>mat1</varname> is a transformation matrix assigned the value of multiplying the given rotation by <varname>mat2</varname> in that order. <varname>mat2</varname> is passed by reference to improve efficiency.</para>
            <para>To do post-rotation, the code is similar:</para>
            <programlisting>vjMatrix mat1, mat2;
vjVec3 axis(1.0, 0.0, 0.0):

// Perform various transformations on mat2...

mat1.postRot(mat2, 45.0, axis);</programlisting>
            <para>where <varname>axis</varname> is passed by reference. The result in both cases is that <varname>mat1</varname> is a transformation matrix assigned the value of multiplying <varname>mat2</varname> by the given rotation in that order. <varname>mat2</varname> is passed by reference to improve efficiency. Note that for post-rotation, the matrix argument is given before the rotation arguments as a reminder that it comes first in the multiplication order.</para>
         </section>
         <section>
            <title>Making a Translation Transformation Matrix</title>
            <para>To make a translation matrix, there are two methods with each having two different types of arguments specifying the translation. The first makes a matrix with only the given translation (all other transformation information is destroyed):</para>
            <programlisting>vjMatrix mat;
vjVec3 trans(4.0, -4.231, 1.0);

mat.makeTrans(trans);</programlisting>
            <para>or</para>
            <programlisting>vjMatrix mat;

mat.makeTrans(4.0, -4.231, 1.0);</programlisting>
            <para>The only difference between these two is that the first takes a reference to a <classname>vjVec3</classname> object specifying the translation.</para>
            <para>To <emphasis>change</emphasis> the translation of a transformation matrix without completely obliterating all other transformations, use the following instead:</para>
            <programlisting>vjVec3 trans(4.0, -4.231, 1.0);

mat.setTrans(trnas);</programlisting>
            <para>or</para>
            <programlisting>mat.setTrans(4.0, -4.231, 1.0);</programlisting>
            <para>There are further extensions to translations. Similar to the <methodname>preMult()</methodname> and <methodname>postMult()</methodname> methods described earlier, one can perform pre-translations and post-translations on a matrix. To do a pre-translation, the code would look similar to the following: </para>
            <programlisting>vjMatrix mat1, mat2;
vjVec3 trans(4.0, -4.231, 1.0):

// Perform various transformations on mat2...

mat1.preTrans(trans, mat2);</programlisting>
            <para>(where <varname>trans</varname> is passed by reference) or</para>
            <programlisting>vjMatrix mat1, mat2;

// Perform various transformations on mat2...

mat1.preTrans(4.0, -4.231, 1.0, mat2);</programlisting>
            <para>The result in both cases is that <varname>mat1</varname> is a transformation matrix assigned the value of multiplying the given translation by <varname>mat2</varname> in that order. <varname>mat2</varname> is passed by reference to both methods to improve efficiency.</para>
            <para>To do post-translation, the code is similar:</para>
            <programlisting>vjMatrix mat1, mat2;
vjVec3 trans(4.0, -4.231, 1.0):

// Perform various transformations on mat2...

mat1.postTrans(mat2, trans);</programlisting>
            <para>(where <varname>trans</varname> is passed by reference) or</para>
            <programlisting>vjMatrix mat1, mat2;

// Perform various transformations on mat2...

mat1.postTrans(mat2, 4.0, -4.231, 1.0);</programlisting>
            <para>The result in both cases is that <varname>mat1</varname> is a transformation matrix assigned the value of multiplying <varname>mat2</varname> by the given translation in that order. <varname>mat2</varname> is passed by reference to both methods to improve efficiency. Note that for post-translation, the matrix argument is given before the translation argument(s) as a reminder that it comes first in the multiplication order.</para>
         </section>
         <section>
            <title>Making a Scale Transformation Matrix</title>
            <para>To make a transformation matrix that only scales, a simple method is provided. It works as follows:</para>
            <programlisting>vjMatrix mat;

mat.makeScale(1.5, 1.5, 1.5);</programlisting>
            <para>The result is that <varname>mat</varname> is a transformation matrix that will perform a scale operation. In this specific case, the scaling happens uniformly for x, y, and z.</para>
            <para>As with the previous operations, more advanced changes can be made. Similar to the <methodname>preMult()</methodname> and <methodname>postMult()</methodname> methods described earlier, pre-scale and post-scale operations can be performed on a matrix. To do a pre-scale, the code would look similar to the following: </para>
            <programlisting>vjMatrix mat1, mat2;

// Perform various transformations on mat2...

mat1.preScale(1.5, 1.5, 1.5, mat2);</programlisting>
            <para>The result in both cases is that <varname>mat1</varname> is a transformation matrix assigned the value of multiplying the given scaling factors by <varname>mat2</varname> in that order. <varname>mat2</varname> is passed by reference to both methods to improve efficiency.</para>
            <para>To do a post-scale, the code is similar:</para>
            <programlisting>vjMatrix mat1, mat2;

// Perform various transformations on mat2...

mat1.postScale(mat2, 1.5, 1.5, 1.5);</programlisting>
            <para>The result in both cases is that <varname>mat1</varname> is a transformation matrix assigned the value of multiplying <varname>mat2</varname> by the given scale factors in that order. <varname>mat2</varname> is passed by reference to both methods to improve efficiency. Note that for post-scaling, the matrix argument is given before the scale factor arguments as a reminder that it comes first in the multiplication order.</para>
         </section>
         <section>
            <title>Extracting Specific Transformation Information</title>
            <para>Finally, methods are provided for extracting transformations from a given matrix. The individual rotations and the translation can be read. For the following examples, assume that <varname>mat</varname> is a <classname>vjMatrix</classname> object representing arbitrary translation, rotaiton, and scaling transformations. To get the roll information, use the following:</para>
            <programlisting>float roll = mat.getRoll();</programlisting>
            <para>or</para>
            <programlisting>float z_rot = mat.getZRot();</programlisting>
            <para>The value return is in the range -180.0° to 180.0°. To get the pitch information, use:</para>
            <programlisting>float pitch = mat.getPitch();</programlisting>
            <para>or</para>
            <programlisting>float x_rot = mat.getXRot();</programlisting>
            <para>Again, the value return is in the range -180.0° to 180.0°. Finally, to get the yaw information, use:</para>
            <programlisting>float yaw = mat.getYaw();</programlisting>
            <para>or</para>
            <programlisting>float y_rot = mat.getYRot();</programlisting>
            <para>Though it may not need to be restated, the value return is in the range -180.0° to 180.0°.</para>
            <para>Getting translations is even simpler since translations are easily collected into a single vector. There are two forms for getting the translation. The first takes three floats by reference:</para>
            <programlisting>float x, y, z;

mat.getTrans(x, y, z);</programlisting>
            <para>After this, the translation in <varname>mat</varname> is stored in x, y, and z. The second form returns a copy of a <classname>vjVec3</classname> object:</para>
            <programlisting>vjVec3 trans;

trans = mat.getTrans();</programlisting>
            <para>That is all there is to reading translations.</para>
         </section>
         <section>
            <title>Converting to an OpenGL Performer Matrix</title>
            <para>SGI's OpenGL Performer likes to work with its own <classname>pfMatrix</classname> class, and to facilitate the use of it with <classname>vjMatrix</classname>, two conversion functions are provided for making conversions. The first works as follows:</para>
            <programlisting>vjMatrix vj_mat;
pfMatrix pf_mat;

// Perform operations on vj_mat...

pf_mat = vjGetPfMatrix(vj_mat);</programlisting>
            <para>where <varname>vj_mat</varname> is passed by reference for efficiency. (<varname>pf_mat</varname> gets a copy of a <classname>pfMatrix</classname> which is a slow operation.) To convert a <classname>pfMatrix</classname> to a <classname>vjMatrix</classname>, do the following:</para>
            <programlisting>pfMatrix pf_mat;
vjMatrix vj_mat;

// Perform operations on pf_mat...

vj_mat = vjGetVjMatrix(pf_mat);</programlisting>
            <para>Here again, <varname>pf_mat</varname> is passed by reference for efficiency, and <varname>vj_mat</varname> gets a copy of a <classname>vjMatrix</classname>. Both of these functions are found in the header <filename>Kernel/Pf/vjPfUtil.h</filename>.</para>
         </section>
         <section>
            <title>The Gory Details</title>
            <para>Now it is time for the really nasty part. Reading this could cause difficulty in understanding the overwhelming amount of information just presented. Do not read any further unless you absolutely have to or you just like to confuse yourself.</para>
            <para>C, C++, and mathematics use matrices in row-major order. Access indices are shown in <xref linkend="Row_maj_table"/></para>
            <table id="Row_maj_table">
               <title>Row-major access indices</title>
               <tgroup align="left" cols="4" colsep="1" rowsep="1">
                  <tbody>
                     <row>
                        <entry>(0,0)</entry>
                        <entry>(0,1)</entry>
                        <entry>(0,2)</entry>
                        <entry>(0,3)</entry>
                        <entry>&lt;--- Array</entry>
                     </row>
                     <row>
                        <entry>(1,0)</entry>
                        <entry>(1,1)</entry>
                        <entry>(1,2)</entry>
                        <entry>(1,3)</entry>
                        <entry>&lt;--- Array</entry>
                     </row>
                     <row>
                        <entry>(2,0)</entry>
                        <entry>(2,1)</entry>
                        <entry>(2,2)</entry>
                        <entry>(2,3)</entry>
                        <entry>&lt;--- Array</entry>
                     </row>
                     <row>
                        <entry>(3,0)</entry>
                        <entry>(3,1)</entry>
                        <entry>(3,2)</entry>
                        <entry>(3,3)</entry>
                        <entry>&lt;--- Array</entry>
                     </row>
                  </tbody>
               </tgroup>
            </table>
            <para>OpenGL ordering specifies that the matrix has to be column-major in memory. Thus, to provide programmers with a way to pass a transformation matrix to OpenGL in one step (via <function>glMultMatrixf()</function>), the <classname>vjMatrix</classname> class maintains its internal matrix in column-major order. Note that in the following table, the given indices are what the cells have to be called in C/C++ notation because we are putting them back-to-back. This is illustrated in <xref linkend="Col_maj_table"/></para>
            <table id="Col_maj_table">
               <title>Column-major access indices</title>
               <tgroup align="left" cols="5" colsep="1" rowsep="1">
                  <tbody>
                     <row>
                        <entry>(0,0)</entry>
                        <entry>(1,0)</entry>
                        <entry>(2,0)</entry>
                        <entry>(3,0)</entry>
                     </row>
                     <row>
                        <entry>(0,1)</entry>
                        <entry>(1,1)</entry>
                        <entry>(2,1)</entry>
                        <entry>(3,1)</entry>
                     </row>
                     <row>
                        <entry>(0,2)</entry>
                        <entry>(1,2)</entry>
                        <entry>(2,2)</entry>
                        <entry>(3,2)</entry>
                     </row>
                     <row>
                        <entry>(0,3)</entry>
                        <entry>(1,3)</entry>
                        <entry>(2,3)</entry>
                        <entry>(3,3)</entry>
                     </row>
                     <row>
                        <entry align="center">^</entry>
                        <entry align="center">^</entry>
                        <entry align="center">^</entry>
                        <entry align="center">^</entry>
                     </row>
                     <row>
                        <entry align="center">Array</entry>
                        <entry align="center">Array</entry>
                        <entry align="center">Array</entry>
                        <entry align="center">Array</entry>
                     </row>
                  </tbody>
               </tgroup>
            </table>
            <para>As mentioned, all of this is done so that a given <classname>vjMatrix</classname> that acts as a full transformation matrix can be passed to OpenGL directly (more or less). For example, with a given <classname>vjMatrix</classname> object <varname>mat</varname> upon which painstaking transformations have been performed, the following can be done: </para>
            <programlisting>glMultMatrixf(mat.getFloatPtr());</programlisting>
            <para>That could not be simpler. All the transformation efforts have culminated into one statement.</para>
            <para>For further information, the best possible source of information, especially for this class, is the header file. Read it; understand it; love it. </para>
         </section>
      </section>
      <section>
         <title>The <classname>vjDeviceInterface</classname> Helper Class</title>
         <para>The concept of device interfaces in VR Juggler is one which often causes confusion for new users. Two object-oriented design patterns are combined by <classname>vjDeviceInterface</classname>: smart pointers and proxies. Within this section, we aim to explain VR Juggler device interfaces clearly and simply. We begin with a high-level description and then move right into using the class.</para>
         <section>
            <title>High-Level Description</title>
            <para>Physical devices are never accessed directly by VR Juggler applications. Instead, the applications are granted access to the device through a <emphasis>proxy</emphasis>. A proxy is nothing more than an intermediary who forwards information between two parties. In this case, the two parties are a VR Juggler application and an input device. The application makes requests on the input device through the proxy.</para>
            <para>The class <classname>vjDeviceInterface</classname> is designed to be a wrapper class around the proxies. Applications could use the proxy classes directly, but <classname>vjDeviceInterface</classname> and its subclasses simplify use of the proxy object they contain. Thus, typical VR Juggler application objects will have one or more device interface member variables.</para>
            <para>In the application object, a device interface member variable is used as a <emphasis>smart pointer</emphasis> to the proxy. In C++, a smart pointer is not usually an actual object pointer. Instead, the class acting as a smart pointer overloads the dereference operator -&gt; so that a special action can be taken when the "pointer" is dereferenced. The derference operator is just another opertor like the addition and subtraction operators, and overloading the derference operator allows some "magic" to occur behind the scenes. On the surface, the code looks exactly the same as a normal pointer dereference, and in most cases, people reading and writing the code can think of the smart pointer as a standard pointer. It may be convenient to think of a smart pointer as a handle.</para>
            <para>With that background, we can move on to explain how <classname>vjDeviceInterface</classname> uses these concepts. First, know that <classname>vjDeviceInterface</classname> is a base class for all other device interface classes such as digital interfaces (wand buttons), position interfaces (wands, a user's head), etc. In user code, there will be instances of objects such as <classname>vjDigitalInterface</classname>, <classname>vjPosInterface</classname>, <classname>vjKeyboardInterface</classname>, and the like. Once they are properly initialized, device interface objects (whatever their types may be) will act as smart pointers to the actual VR Juggler proxy objects they wrap.</para>
            <para>All the subclasses of <classname>vjDeviceInterface</classname> encapsulate a pointer to a VR Juggler proxy object. (Remember that these proxy objects act as an intermediary between the application and an input device.) The subclasses also overload the dereference operator -&gt; which allows them to act as smart pointers. The dereference operator on a device interface object gives access to the object's hidden proxy pointer. With that access, the methods of the encapsulated proxy object can be invoked, usually to read data. The end result is that user applications get access to the proxy objects they need but through a simpler interface than using the proxies directly.</para>
            <para>At this point, it is perfectly reasonable to wonder why VR Juggler uses a concept that requires all sorts of documentation and explanation. The extra effort is worth it because it allows VR Juggler to hide the actual type of the device being used. There is no need to know that some specific VR system uses a wireless mouse connected to a PC reading bytes from a PS/2 port that represent button presses. All that matters is knowing which buttons are pressed at a given instant. The class<classname>vjDigialInterface</classname> gives exactly that information, and it quietly hides the messiness of dealing with that crazy mouse, its ugly driver, and its overly complex protocol.</para>
         </section>
         <section>
            <title>Using <classname>vjDeviceInterface</classname></title>
            <para>VR Juggler applications do not usually use <classname>vjDeviceInterface</classname> directly. Instead, the subclasses mentioned above will be used. Within this section, we will refer to subclasses of <classname>vjDeviceInterface</classname> as "device interfaces". The high-level description has already made use of this convention.</para>
            <para>Before using a device interface, some must be declared. Programmers must choose the type that is appropriate for the type of devices relevant to a given application. All device interface objects must be initialized in the application object's <methodname>init()</methodname> method. Each device interface object inherits a method called <methodname>init()</methodname> from <classname>vjDeviceInterface</classname>. This method takes a single string argument naming the proxy to which the interface will connect. Example names are "VJHead", "VJWand", and "VJButton0". These are all symbolic names specified in VR Juggler configuration files. This makes them easier to remember, and it also contributes to hiding the details about the physical device. With this system, no one needs to care how transformation information from the user's head is generated. VR Juggler cares, but there is no need for it to tell anyone else. All developers care about is the head transformation matrix. An example of initializing a <classname>vjPosInterface</classname> that connects with the user head proxy is:<programlisting>vjPosInterface head;

head.init("VJHead");</programlisting></para>
            <para>Remember that this is to be done in an application object's <classname>init()</classname> method. The actual object used would be a member variable of the application class. Note that here, the normal syntax for calling the method of a C++ object is used rather than using the dereference operator. Until it is initialized, the device interface object cannot act as a smart pointer.</para>
            <para>Once device interface objects are all initialized and ready to use, it is time to start using them as smart pointers. This is best part! VR Juggler is already working hard in the background to update device proxies, and the application is free to access them. (It is usually best to reference them in the <methodname>preFrame()</methodname> method, but this may not necessarily be true for all proxies.) Continuing with our example of a <classname>vjPosInterface</classname> to the user head proxy, the following code shows how to read the transformation matrix for the user's head: <programlisting>vjMatrix* head_mat;

head_mat = head-&gt;getData();</programlisting></para>
            <para>But wait, that was easy! The code really is that simple, though. Simply use the overloaded dereference operator to get access to the position proxy object hidden in <classname>vjPosInterface</classname> to read data from the proxy. Of course, we have not explained the <methodname>getData()</methodname> method at all yet. That comes from the position proxy class, and that is documented elsewhere.</para>
         </section>
         <section>
            <title>The Gory Details</title>
            <para>What is truly amazing about VR Juggler device interfaces is, despite their seeming complexity, there is really nothing to them. Trying to trace through the source code is a little tricky, but conceptually, it is all about pointers. Keep in mind that all this documentation is written using nothing more than the header files as a reference.</para>
            <para>As mentioned, the class <classname>vjDeviceInterface</classname> is a base class for all the specific types of device interfaces such as positional interfaces, digital interfaces, and analog interfaces. This class maintains the name of the proxy and the proxy index, and it provides the all-important <methodname>init()</methodname> method, but it is up to the inheriting classes to handle the proxy pointer and overloading the dereference operator.</para>
            <para>Subclasses of <classname>vjDeviceInterface</classname> are used to provide the wrapper to a specific type of proxy. They each contain a pointer to a proxy object of the same conceptual type (positional, digital, and so on). The way in which the dereference operator is overloaded can vary from class to class, but the end result is always the same: a pointer to the proxy is returned so that the calling code has access to that proxy.</para>
            <para>The beauty of it all is that the proxy object being pointed to by the device interface can be changed without affecting the execution of the user application. In other words, the proxies can be changed at run time to point to different physical devices. All the while, the user code is still using the smart pointer interface and getting data of some sort. This flexibility is one of the most important features of VR Juggler, and it is important to understand.</para>
         </section>
      </section>
      <section>
         <title>The <classname>vjProxy</classname> Helper Class</title>
         <para>This whole proxy scheme can be confusing. We admit that it makes the learning curve for VR Juggler a little steeper, but once you get it, you will know it all. An alternate title for this section is ``Horton Hears a Proxy.'' In this case, Horton is VR Juggler (it is rather elephant-like at times), and the complexity of dealing with these ethereal, ubiquitous proxies causes VR Juggler to take a lot of guff. This document presents the <classname>vjProxy</classname> class, the base class for the input proxies making it the one that is used the most. It should be noted, however, that the concept is spreading to other parts of VR Juggler because it is so useful. While this is only the introduction, we'll give you the moral of the story now: proxies are important concepts, and you should not step on them.</para>
         <section>
            <title>High-Level Description</title>
            <para>The class <classname>vjProxy</classname> is the base class for all the proxies in the VR Juggler Input Manager. A better name would be <classname>vjInputProxy</classname>, and it may help to think of it with that name. As a programmer of VR Juggler applications, knowledge of such proxies does not have to be terribly in-depth. The fact is, most VR Juggler programmers will probably never need to know more about a specific device proxy's interface than the return type of its <methodname>getData()</methodname> method. Most of the apparent complexity in the specific device proxy classes is only important to VR Juggler's internal maintenance of the active proxies.</para>
            <para>That said, this document is relatively short. As a programmer, the important thing to know is that a proxy is a pointer to a physical device. You use the higher level device interface as the mechanism to read data in some form from the device. The device interface encapsulates some type of proxy that in turn points to an input device. That device can be a wand, a keyboard, a light sensor, or a home-brewed device that reads some input and returns it to VR Juggler in a meaningful way. That is a lot of indirection, but it makes the handling of physical devices by VR Juggler incredibly powerful.</para>
         </section>
         <section>
            <title>Using <classname>vjProxy</classname></title>
            <para>To be blunt, application programmers do not use <classname>vjProxy</classname>. Instead, access to a subclass of <classname>vjProxy</classname> is given through a device interface acting as a smart pointer. The <methodname>getData()</methodname> method of that subclass is used. That method is the window into the soul of an input device. The device interface allows calling <methodname>getData()</methodname> for the specific proxy object it encapsulates, and the current state of the device pointed to by the proxy is returned.</para>
            <para>Therefore, what must be known is the return type of the specific proxy to which access is granted through the device interface. The naming conventions for the proxies and their interfaces makes it relatively simple to determine which proxy object is being encapsulated by which device interface. For example, a <classname>vjDigitalInterface</classname> holds a <classname>vjDigitalProxy</classname> pointer. In that case, refer to the documentation for the <classname>vjDigitalProxy</classname> class and find the return type of <methodname>getData()</methodname> (<type>int</type> in this case). The proxy header files have the information, too. These are located in <filename>$VJ_BASE_DIR/Input/InputManager</filename>. Just search for the <methodname>getData()</methodname> methods therein.</para>
         </section>
         <section>
            <title>The Gory Details</title>
            <para>The gory details of <classname>vjProxy</classname> and its subclasses are not really relevant to this particular document. The subclasses look complicated, and they can be. It is important to note, however, that the complication is part of the interface used <emphasis>internally</emphasis> by VR Juggler rather than the interface used by the application programmer. Because of that and because each device proxy class is different, those details will not be addressed here. It is sufficient to deal with <methodname>getData()</methodname> alone in applications. Leave the ugliness up to VR Juggler; it can handle it.</para>
         </section>
      </section>
   </chapter>
</book>
