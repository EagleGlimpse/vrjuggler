<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">

<head>
</head>

<body>
<h2>How To Add a Device Driver To Juggler</h2>

<!-- install-web toc-begin -->
Table of Contents:
<ul>
   <li> <a href="#indepth">In Depth Driver Guide</a></li>
   <ul>
      <li> <a href="#impl">Implementation</a></li>
      <li> <a href="#register">Registration of the device driver</a></li>
   </ul>
   <li> <a href="#config">Configuration</a></li>
   <ul>
      <li> <a href="#config-files">Files</a></li>
      <li> <a href="#config-code">Code</a></li>
   </ul>
   <li> <a href="#code">Driver Code example </a></li>
</ul>
<!-- install-web toc-end -->

<h3><a name="indepth">In Depth Driver Guide for VR Juggler</a></h3>

<p>
To create a new device, you must declare a new class that derives 
from one (or more!) of these types:
</p>

<ul>
   <li>vjInput <i>(base class of all device drivers)</i>
   <li>vjDigital, vjSimDigital
   <li>vjAnalog, vjSimAnalog
   <li>vjPosition, vjSimPosition
   <li>vjGlove, vjSimDigitalGlove, vjGloveGesture
</ul>

<p>
For example, if you wanted to make a driver that registers button presses, 
you would derive from vjDigital:
</p>

<pre>
   class MyNewButtonDevice : public vjDigital
</pre>

<p>
Supposed you wanted to write a joystick driver, you would realize that
you need to have an analog component as well (X and Y axes).  You realize
that your device is both digital and analog, so you must derive from both
vjDigital and vjAnalog using multiple inheritance:
</p>

<pre>
   class MyNewJoystickDevice : public vjDigital, public vjAnalog
</pre>

<p>
<b>NOTE</b>: to use your joystick in place of a tracker, you should derive instead from vjPosition.  This way you
can replace real trackers with your joystick pseudo tracker.  Basically if you ever want one device to be able to
replace another device, then you need to make sure it derives from the same base classes as that device..
</p>

<h4> <a name="impl">Implementing the device driver</a> </h4>

<p>
With this class definition, you also need to define 6 member functions:
</p>

<ul>
   
   <li><tt> virtual int   startSampling()</tt><BR>
      <p>
      This function starts a new thread with code that looks something like: 
      <pre>myThread = new <a href="broken thread link 1of3">vjThread</a>( ::sampleFunction, (void*)this, 0 );</pre> 
      which then calls within the newly spawned thread <tt> ::threadedSampleFunction </tt> which is 
      defined in the global scope like this:
      </p>

<pre>
   void threadedSampleFunction( void* classPointer )
   {
      MyNewJoystickDevice* this_ptr = static_cast&lt;MyNewJoystickDevice*&gt;( classPointer );

      // spin until someone kills "myThread"
      while (1)   
      {
        this_ptr-&gt;sample();
        sleep(1); //specify some time here, so you don't waste CPU cycles
      }
   }
</pre>

      <p>
      NOTE: you can test if the thread creation was successful with
      <tt>myThread-&gt;valid()</tt><BR>
      See <a href="broken thread link 2of3">this page</a> for more information on creating threads in VR Juggler.
      </p>

   <li><tt> virtual int   stopSampling()</tt><BR>
      <p>
      This function just kills off the sample thread with a command something like: <tt>myThread-&gt;kill()</tt>
      See <a href="broken thread link 3of3">this page</a> for more information on creating threads in VR Juggler.
      </p>

   <li><tt> virtual int   sample()</tt><BR>
      <p>
      You write this function to read data from your device, then store it to be later read by getDigitalData.<BR>

      NOTE: It is wise to use <a href="${GLOSSARY}#triple buffered data">triple buffered data</a> here, 
      so that you are not writing to the data as it is being read.  
      vjInput class defines 3 variables to help you keep track of which of the 3 buffers you're 
      writting to:
      </p>

      <ul>
         <li><TT>vjInput::current</TT>
         <li><TT>vjInput::progress</tt>
         <li><tt>vjInput::valid</TT>
      </ul>

      <p>
      For example, create an array to hold your sampled data:<BR>
      <tt> int mSampledDigitalData[3]; // triple-buffered data (3x the data)</tt><BR>
      <BR>
      Then when writing your sampled data to this buffer use <tt>vjInput::progress</tt>:<BR>
      <tt> mSampledDigitalData[vjInput::progress] = whatever_was_sampled_from_the_joystick;</tt><BR>
      </p>

   <li><tt> virtual void  updateData()</tt><BR>
      <p>
      This function swaps the data and vjInput:: tri-buffered data indicies, you usually write the function this way:<BR>
      </p>

<pre>
   void MyNewJoystickDevice::updateData()
   {
      vjGuard&lt;vjMutex&gt; updateGuard( lock );

      // Copy the valid data to the current data so that both are valid
      mSampledDigitalData[current] = mSampledDigitalData[valid];   

      // swap the indicies for the tri-buffer pointers
      vjInput::swapCurrentIndexes();
   }
</pre>

   <li><tt> static std::string  MyButtonDevice::getChunkType() </tt><BR>
      <p>
      In the getChunkType function you need to return the <i>chunk type</i> of your device as it to appears 
      in the .desc file.
      
      <tt>return "MyNewJoystickDevice";</tt>
      </p>
      
      <p>
      <img border=0 src="${IMAGES}/Icons/24x24_Images/Inform.gif">Every VR Juggler device needs a <i>chunk type</i> 
      associated with it.  A <i>chunk type</i> is kind of like a struct in C/C++.  This data structure is 
      defined in a .desc file.  Then, you can use this new type inside of your .config files to specify to 
      Juggler that you want to include that type in the active configuration.
      </p>
      
   <li><tt> virtual int   getDigitalData( int devNum = 0 )</tt><BR>
      <p>
      NOTE: It is wise to use <a href="${GLOSSARY}#triple buffered data">triple buffered data</a> here, 
      so that you are not writing to the data as it is being read.  
      vjInput class defines 3 variables to help you keep track of which of the 3 buffers you're 
      writting to.  When reading the data use <tt>vjInput::current</tt>:
      </p>

<pre>
   int MyNewJoystickDevice::getDigitalData( int d )
   {
       return mSampledDigitalData[current];
   }
</pre>

   <li><tt> virtual float   getAnalogData(int devNum = 0)</tt><BR>
     For our joystick, this is the function that the client would use to get the values for the X and Y axes.
     Our data here is a little more complex, it is a 2D (for 2 axes) 
     <a href="${GLOSSARY}#triple buffered data">triple buffered</a> float.  NOTE: to use your joystick in place of
a tracker, you should derive instead from vjPosition.  This way you can replace real trackers with your
joystick pseudo tracker.  Basically if you ever want one device to be able to replace another device, then you
need
to make sure it derives from the same base classes as that device..

<pre>
   float MyNewJoystickDevice::getAnalogData( int axis )
   {
       assert( axis >= 0 && axis <=1 && "only 2 - x and y - axes available" );
       return mSampledAnalogData[current][axis]; // 
   }
</pre>
</ul>

<h3> <a name="register">Register your device driver with Juggler</a> </h3>

<p>
Device driver registration is done through a templated constructor called 
vjDeviceConstructor.  
</p>

<pre>
   #include &lt;Input/InputManager/vjDeviceFactory.h&gt;
   vjDeviceConstructor&lt;MyButtonDevice&gt;* this_ptr_not_used = new vjDeviceConstructor&lt;MyButtonDevice&gt;;
</pre>

<p>
You can compile your device driver code along with the vjDeviceConstructor call
into a library (.a .so .lib or .dll for example) that you then link 
with your applications.  This way you don't need to modify the juggler source 
code to add a new driver, plus you can centralize all your driver code into
a single neat driver module that you can then distribute as a "plugin".<BR>
<BR>
<img border=0 src="${IMAGES}/Icons/24x24_Images/Caution.gif"><B>Make sure you tell your compiler to include <i>all</i> library symbols.  <BR>
             For example on IRIX you'll need a -all option, check your compiler documentation for more info.  <a href="${FAQ}#dash-all">See the FAQ for more info...</a></b><BR>
</p>

<h3> <a name="config">Configure your device driver</a> </h3>
To configure your device, you will need 2 things:
<ul>
<li><a href="#config-files">Configuration Files</a>
<li><a href="#config-code">To write code in your driver to accept the config info</a>
</ul>
See also: <a href="${PROGRAMMERGUIDE}/adv.topics/run.time.config/run-time-how-to.html">Detailed description of adding runtime reconfiguration to VR Juggler applications</a>

<ul>
   <a name="config-files"><h4>Configuration Files</h4>

   Before configuring your device you will need to first create 
   a new <b>configuration chunk description</b>.  We recommend you create the 
   new configuration chunk description using <a href="${VJCONTROL}">VJControl</a>.<BR>
   <BR>
   For the button device your chunk will look something like this:<BR>
   <br>
   File mybuttondevice.desc:
   <pre>
   chunk MyButtonDevice "MyButtonDevice" "Configuration for my one button thingie"
     Name String 1 "Name" "Unique name of an instance of this chunk type"
     port String 1 "Port" "Serial port this device is connected to"
     baud Int 1 "Baud Rate" "Serial port speed"
     end
   </pre>
   Of course, depending on your hardware configuration, 
   you may or may not need all these parameters. 
   (currently vjInput requires baud and port though, 
    but this will change in future versions)<BR><BR>
    <B>NOTE: <i>The PosProxy chunk within your chunk description file has to be modified
      to include new position devices.  
      Since MyButtonDevice is a position device, you'll need to do this.
    </i></b><BR>
   <BR>
   Next, you need to configure your device by creating a <b>configuration chunk</b>:
   (like before, we suggest you use <a href="${VJCONTROL}">VJControl</a> to 
   create this configuration file)<BR>
   <BR>
   File mybutton.config:
   <pre>
   vjincludedescfile
      Name "mybuttondevice.desc"
     end
   MyButtonDevice
     Name "buttonthingie"
     port { "/dev/ttyd4" }
     baud { "9600" }
     end
   </pre>

   <a name="config-code"><h4>How to write the code in your driver that accepts configuration</h4>

   In your driver, overload these functions: <BR>
   <ul>
   
   
      <li><tt>static std::string  MyButtonDevice::getChunkType();</tt>
      When the VR system configuration changes (for example, when you
      load a new config file into the kernel), the system asks every registered
      driver for their chunk type, and if it matches the new config chunk passed
      into the system, then the system calls your driver's config(...) method...<BR>
      <BR>
      To implement, just return your device's name as it appears in the config 
      chunk description - this way, juggler can match the configuration chunk with the driver.
      
      <p>
      <img border=0 src="${IMAGES}/Icons/24x24_Images/Inform.gif">Every VR Juggler device needs a 
      <i>chunk type</i> associated with it.  A <i>chunk type</i> is kind of like a struct in C/C++.  
      This data structure is defined in a .desc file.  Then, you can use this new 
      type inside of your .config files to specify to Juggler that you want to include that type in the 
      active configuration.
      </p>
      

      <li><tt>virtual bool vjInput::config( vjConfigChunk* c );</tt>
      When the system detects a configuration change for your driver, it will
      pass the new vjConfigChunk into this function.  See the documentation
      on config chunks, for information on how to access them.<BR>
      <BR>
      Example:<BR>
      <pre>
      bool MyButtonDevice::config( vjConfigChunk *c )
      {
        if (!vjDigital::config(c))
           return false;

        port_id = c->getProperty( "port" );
        baudRate = c->getProperty( "baud" );

        return true;
      }
      </pre>
   </ul>
</ul>

<h3> <a name="code">Code Example</a> </h3>

<p>
Lets take a look at a simple device driver for reading a button press from 
some ficticious piece of hardware that only has one button...
</p>

<pre>
#include &lt;Input/vjInput/vjDigital.h&gt;
#include &lt;Input/InputManager/vjDeviceFactory.h&gt;

class MyButtonDevice : public vjDigital
{
public:
   MyButtonDevice() : mSampleThread( NULL ) {}
   virtual ~MyButtonDevice() { this-&gt;stopSampling(); }
   virtual void  getData();
public:
   virtual void  startSampling();
   virtual void  sample();
   virtual void  stopSampling();
   static std::string getChunkType();
private:
   static void   threadedSampleFunction( void* classPointer );
   int           mDigitalData;
   vjThread*     mSampleThread;
   
   // configuration data set by config()
   int           mPortId, mBaud;
};

vjDeviceConstructor&lt;MyButtonDevice&gt;* this_ptr_not_used = new vjDeviceConstructor<MyButtonDevice>;

//: What is the name of this device?
//  This function returns a string that should match this device's 
//  configchunk name.
static std::string  MyButtonDevice::getChunkType() 
{ 
   return std::string( "MyButtonDevice" );
}

// spawn a sample thread, 
// which calls MyButtonDevice::sample() repeatedly
void MyButtonDevice::startSampling()
{
   mSampleThread = new vjThread( threadedSampleFunction, (void*)this, 0 );
   if (!mSampleThread-&gt;valid())
      return 0; // thread creation failed
   else 
      return 1; // thread creation success
}
   
//: Record (or sample) the current data
// this is called repeatedly by the sample thread created by startSampling()
void MyButtonDevice::sample()
{
   // here you would add your code to 
   // sample the hardware for a button press:
   mDigitalData[progress] = rand_number_0_or_1();
}

// kill sample thread
int MyButtonDevice::stopSampling()
{
   if (mSampleThread != NULL)
   {
      mSampleThread-&gt;kill();
      delete mSampleThread;
      mSampleThread = NULL;
   }
   return 1;
}

//: function for users to get the digital data.
//  here we overload vjDigital::getDigitalData
int MyButtonDevice::getDigitalData(int d)
{
   // only one button, so we ignore "d"
   return mDigitalData[current];
}

// Our threaded sample function
// This function is declared as a <b>static</b> member of MyButtonDevice
// just spins... calling sample() over and over.
void MyButtonDevice::threadedSampleFunction( void* classPointer )
{
   MyButtonDevice* this_ptr = static_cast&lt;MyButtonDevice*&gt;( classPointer );

   // spin until someone kills "mSampleThread"
   while (1)   
   {
     this_ptr-&gt;sample();
     sleep(1); //specify some time here, so you don't waste CPU cycles
   }
}

//: When the system detects a configuration change for your driver, it will
//  pass the new vjConfigChunk into this function.  See the documentation
//  on config chunks, for information on how to access them.
bool MyButtonDevice::config( vjConfigChunk *c )
{
  if (!vjDigital::config(c))
     return false;

  mPortId = c->getProperty( "port" );
  mBaud = c->getProperty( "baud" );

  return true;
}
</pre>
</body>
