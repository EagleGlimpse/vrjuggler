<head>
</head>

<body>

<h2>Porting to VR Juggler from CAVElib(TM)</h2>

<p>
<b>Table of Contents</b>
<ul>
   <li><a href="#idf">Init, Draw, and Frame routines</a>
   <li><a href="#input">Input</a>
   <li><a href="#context">OpenGL Context Data</a>
   <li><a href="#memory">Memory</a>
   <li><a href="#config">Configuration Files</a>
   <li><a href="#code">Source Code</a>
   <ul>
      <li><a href="#CaveCode">Form of a basic CAVELib program</a>
      <li><a href="#JugglerCode">Form of a basic VRJuggler program</a>
   </ul>
</ul>
<b>NOTE</b>: This document explains OpenGL versions of Juggler and CAVElib
</p>

<h3><a name="idf">Draw, frame, and init routines</a></h3>
<p>
In CAVElib(TM) these routines are "called-back" using function pointers (C-style).
In VR Juggler, these routines are "called-back" using an application object, a C++ class which defines these
methods to encapsulate the functionality of the application within one C++ class object.<BR>
</p>
<ul>
  <h4> In CAVElib(TM) </h4>
  <ul>
  <li>Draw: An application's display callback function is defined by passing a function pointer to CAVEDisplay(). 
  <li>Frame: The frame function is defined with CAVEFrameFunction(). 
  <li>Init: The initialization callback is defined using CAVEInitApplication(). 
  </ul>
  
  <h4>In VR Juggler</h4>
   <p>
    No C-style function pointers are nessesary, you only pass Juggler a pointer to your "application class", so
     you first derive a new application class from vjGlApp:<BR> <TT>class YourApplication : public vjGlApp { ... };</TT> then...<BR>
   </p>
   <ul>
      <li>Draw: an application's display callback function is defined by simply defining a new method/function draw() in
         your derived class. This is where you put OpenGL rendering commands such as glBegin, glVertex, glWhatever...)
      <li>Frame: This is where you put your calculations such as navigation, collision, physics, AI, nurbs surface
         sampling, etc...  <BR>
         The frame function is split across 3 functions:
      <ul>
         <li>YourApplication::preFrame (called before draw)
         <li>YourApplication::intraFrame (called during draw)
         <li>YourApplication::postFrame (called after draw)
      </ul>
      <li>Init: One initialization function for data, and one initialization function for 
            where you create <a href="${GLOSSARY}#context data">context specific data</a> 
            (such as displaylists and texture objects) for each 
            <a href="${GLOSSARY}#display context">display context</a> in the system.<BR>
          The initialization callback is split across 2 functions
      <ul>
         <li>YourApplication::init()         (called once per application startup)
         <li>YourApplication::contextInit()  (called once per <a href="${GLOSSARY}#display context">display context</a>)
      </ul>
   </ul>
</ul>

<h3><a name="input">Getting input from devices</a></h3>
<ul>
   <h4>In CAVElib(tm)</h4>
   For trackers you used these functions:
   <ul>
   <li>CAVEGetPosition(id,pos) 
   <li>CAVEGetOrientation(id,or) 
   <li>CAVEGetVector(id,vec) 
   <li>CAVEGetSensorPosition(sensor,coords,pos) 
   <li>CAVEGetSensorOrientation(sensor,coords,or) 
   <li>CAVEGetSensorVector(sensor,id,vec) 
   </ul>

   For buttons you used these MACROS:
   <ul>
   <li>CAVEBUTTON1, CAVEBUTTON2, CAVEBUTTON3, CAVEBUTTON4, CAVE_JOYSTICK_X, and CAVE_JOYSTICK_Y
   <li>CAVEButtonChange()
   </ul>

   <h4>In VR Juggler:</h4>
   You use the vjDevinceInterface derived classes such as:<BR>
   <ul>
      <li>vjPositionInterface&nbsp;(for trackers and other positional devices)
      <li>vjDigitalInterface&nbsp;&nbsp;(for buttons and other on/off devices)
      <li>vjAnalogInterface&nbsp;&nbsp;&nbsp;(for Ibox/potentiometers and other multi range data devices)
   </ul>
</ul>

<h3><a name="context">OpenGL Context Data</a></h3>
<p>
IMPORTANT!  Read this:<BR>
VR Juggler, unlike the CAVElib, can handle drawing multiple displays in one process, so it's nessesary to
manage "<a href="${GLOSSARY}#context data">context specific data</a> ".  
A <a href="${GLOSSARY}#display context">display context</a> is where the OpenGL rendering commands render to.
Compiled OpenGL commands such as displaylists do not get shared
across muiltiple contexts (or windows), so you will need to initialize them once per display context.  
vjGlApp::contextInit is the place to put these OpenGL initializations since it is called once per display context 
after each has become active.
</p>


<h3><a name="memory"> Memory </a></h3>
<p>
   VR Juggler, unlike the CAVElib, has no need to manage <a href="${GLOSSARY}#shared memory">shared memory</a> with
   other Juggler instances.  Instead, running other Juggler instances and syncing them together does not work at this
   time.  So all you need to do is create your memory as you normally would in a C or C++ application using new or
   malloc (we would suggest new).
</p>

<h3><a name="config">Configuration</a></h3>
<ul>
   <h4>In CAVElib(tm):</h4>
   <p>
   You had all setable parameters in one file called .caverc<BR>
   CAVElib's configuration mechanism is proprietary and useless outside of the VR system software.  
   For example an application could not store its configuration information within the .caverc file.
   </p>

   <h4>In VRJuggler:</h4>
   <p>
   All settable parameters could be in one or many files of any name that you want.  
   For some examples see sample configuration files that come with Juggler in juggler/Data/configFiles.<BR>
   <BR>
   VR Juggler has a completly extensible configuration system, that 
   theoretically you could use outside of VRJuggler or even outside of any 
   sort of VR paradigm.  <BR>
   <BR>
   See <a href="${VJCONTROL}/index.html">VJCONTROL documentation</a> for more instruction.
   </p>
</ul>

<h3><a name="code"> Source Code </a></h3>
<ul>
   <h4><a name="CaveCode">Form of a basic CAVELib program</a></h4>
   <pre>
   void app_shared_init();
   void app_compute_init();
   void app_init_gl();
   void app_draw();
   void app_compute();

   main(int argc,char **argv)
   {
      CAVEConfigure(&argc,argv,NULL);
      app_shared_init(argc,argv);
      CAVEInit();
      CAVEInitApplication(app_init_gl,0);
      CAVEDisplay(app_draw,0);
      app_compute_init(argc,argv);
      while (!getbutton(ESCKEY))
      {
          app_compute();
      }
      CAVEExit();
   }
   </pre>

   <h4><a name="JugglerCode">Form of a basic VRJuggler program</a></h4>
   <pre>
   class MyApplication
   {
      virtual void init();
      virtual void draw();
      virtual void preFrame();
      virtual void postFrame();
      virtual void intraFrame();
   };

   int main(int argc, char* argv[]) 
   {
      // configure kernel with *.config files
      vjKernel* kernel = vjKernel::instance(); // Get the kernel
      for(int i=1;i&lt;argc;i++)
      {
         // loading config file passed on command line...
         kernel-&gt;loadConfigFile(argv[i]);
      }

      // start the kernel
      kernel-&gt;start();

      // set the application for the kernel to run
      MyApplication* application = new MyApplication();
      kernel-&gt;setApplication(application);

      // hit CTRL-C to exit.
      while (1)
      {
         // Juggler executes within other threads, so sleep here.
         usleep( 100000 );
      }
   }
   </pre>
</ul>

</body>
