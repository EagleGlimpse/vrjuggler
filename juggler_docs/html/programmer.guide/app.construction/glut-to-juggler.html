<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">

<head>
</head>

<body>

<!--NewPage-->
<h2>Porting to VR Juggler from GLUT</h2>

<p>
<!-- install-web toc-begin -->
<b>Table of Contents</b>
<ul>
   <li><a href="#windows">Window Creation/Managment</a>
   <li><a href="#idf">Init, Draw, and Frame routines</a>
   <li><a href="#input">Input</a>
   <li><a href="#context">OpenGL Context Data</a>
   <li><a href="#memory">Memory</a>
   <li><a href="#config">Configuration Files</a>
   <li><a href="#code">Source Code</a>
   <ul>
      <li><a href="#CaveCode">Form of a basic GLUT program</a>
      <li><a href="#JugglerCode">Form of a basic VRJuggler program</a>
   </ul>
</ul>
<!-- install-web toc-end -->

<b>NOTE</b>: This document explains OpenGL versions of Juggler and GLUT
</p>

<h3><a name="windows">Window Creation/Managment</a></h3>
<p>
   In Juggler, window creation is done for you based on your configuration file settings.
   There are two window types, <b>Surface</b>, and <b>Simulator</b>.  
   
   A <a href="${GLOSSARY}#surface window">Surface Window</a> can be put into <tt>stereo</tt>, <tt>right eye</tt>, or 
   <tt>left eye</tt> display modes.  Most interesting is the stereo mode since it requires 
   special hardware to display stereo, and creates the most immersive experience.  
   
   A <a href="${GLOSSARY}#simulator window">Simulator Window</a> is special because 
   it simulates/visualizes the active VR system. It can show the all active user's 
   head position and orientation, any active devices such as Glove or Wand, 
   as well as visualize the display surfaces themselves.  The simulator window is 
   nice for debugging tracking systems, and to visually see the activly configured
   <a href="${GLOSSARY}#surface window">Surface Window</a>.
</p>   

<h3><a name="idf">Init, Draw, and Frame routines</a></h3>
<p>
In GLUT(TM) these routines are "called-back" using function pointers (C-style).
In VR Juggler, these routines are "called-back" using an application object, a C++ class which defines these
methods to encapsulate the functionality of the application within one C++ class object.<BR>
   <ul>
     <h4> In a typical GLUT application </h4>
     <dl>
     <dt>Draw: This is where you put OpenGL commands.  <BR>
     <dd>      An application's display callback function is defined by passing a function pointer to glutDisplayFunc(). 
     </dl>
     <dl>
     <dt>Frame: This is where you put operations on your application data (no OpenGL commands here since the display window is undefined at this point).  <BR>
     <dd>       The frame function is defined with glutIdleFunc(), this function generally does a glutPostRedisplay() to cause your display callback to be executed.
     </dl>
     <dl>
     <dt>Init: (no callbacks for initialization)<BR>
     <dd>      Data Init: Your data initialization is usually done before the app starts<BR>
               Context Init: Your OpenGL context initialization is done during the first run of the function set with glutDisplayFunc() (once for each window opened).
     </dl>
   </ul>
  
  <h4>In VR Juggler</h4>
   <p>
    No C-style function pointers are nessesary, you only pass Juggler a pointer to your "application class", so
     you first derive a new application class from vjGlApp:<BR> <TT>class YourApplication : public vjGlApp { ... };</TT> then...<BR>
   </p>
   <ul>
      <dl>
      <dt>Draw: This is where you put OpenGL rendering commands such as glBegin, glVertex, glWhatever...
      <dd>an application's draw() callback function is defined by simply defining a new method/function draw() in
          your derived class: <BR>
          <tt> class MyApp : public vjGlApp { public: virtual void draw(); }; </tt>
      </dl>
      
      <dl>
      <dt>Frame: This is where you put your data operations (non-OpenGL) such as navigation, collision, physics, AI, nurbs surface sampling, etc...  <BR>
      <dd>The frame function is split across 3 functions:
            <ul>
               <li>YourApplication::preFrame (called before draw)
               <li>YourApplication::intraFrame (called during draw)
               <li>YourApplication::postFrame (called after draw)
            </ul>
      </dl>
      
      <dl>
      <dt>Init: 
      <dd>One initialization function for data, and one initialization function for 
            where you create <a href="${GLOSSARY}#context data">context specific data</a> 
            (such as displaylists and texture objects) for each 
            <a href="${GLOSSARY}#display context">display context</a> in the system.<BR>
          The initialization callback is split across 2 functions
         <ul>
            <li>YourApplication::init()         (called once per application startup)
            <li>YourApplication::contextInit()  (called once per <a href="${GLOSSARY}#display context">display context</a>)
         </ul>
      </dl>

   </ul>
</p>

<h3><a name="input">Getting input from devices</a></h3>
<ul>
   <h4>In GLUT(tm)</h4>
   For keyboard input you used these functions:
   <ul>
   <li>::glutKeyboardFunc( OnKeyboardDown );
   <li>::glutKeyboardUpFunc( OnKeyboardUp );
   <li>::glutSpecialFunc( OnSpecialKeyboardDown );
   <li>::glutSpecialUpFunc( OnSpecialKeyboardUp );
   <li>
   For mouse input you used these functions:
   <ul>
   <li>::glutMouseFunc( OnMouseButton );
   <li>::glutMotionFunc( OnMousePosition );
   <li>::glutPassiveMotionFunc( OnMousePosition );
   </ul>

   <h4>In VR Juggler:</h4>
   For input, you use a vjDevinceInterface derived class such as:<BR>
   <ul>
      <li>vjPositionInterface&nbsp;(for <a href="${GLOSSARY}#tracker">tracker</a>s and other positional devices)
      <li>vjDigitalInterface&nbsp;&nbsp;(for buttons and other on/off devices)
      <li>vjAnalogInterface&nbsp;&nbsp;&nbsp;(for Ibox/potentiometers and other multi range data devices)
   </ul>
</ul>

<h3><a name="context">OpenGL Context Data</a></h3>
<p>
IMPORTANT!  Read this:<BR>
VR Juggler, like GLUT, can handle drawing multiple displays in one process.  Most people don't use multiple windows
in GLUT, so often don't engineer their application for this.  
With the potential for multiple windows it is nessesary to manage "<a href="${GLOSSARY}#context data">context specific data</a> ".  
A <a href="${GLOSSARY}#display context">display context</a> is where the OpenGL rendering commands render to.
Compiled OpenGL commands such as displaylists do not get shared across muiltiple contexts (or windows), 
so you will need to initialize them once per display context.  vjGlApp::contextInit is the place to put these OpenGL
initializations since it is called once per display context after each has become active.
</p>


<h3><a name="memory"> Memory </a></h3>
<p>
   VR Juggler is written fully in C++, as such you'll need to use <tt>new</tt> and <tt>delete</tt> 
   instead of <tt>malloc()</tt> or <tt>free()</tt>.
</p>

<h3><a name="config">Configuration</a></h3>
<ul>
   <h4>In GLUT(tm):</h4>
   <p>
   There is no built-in configuration system...
   </p>

   <h4>In VRJuggler:</h4>
   <p>
   Uses configuration files to <a href="broken link">reconfigure</a> a running VR Juggler system.
   All settable parameters could be in one or many files of any name that you want.  
   For some examples see sample configuration files that come with Juggler in juggler/Data/configFiles.<BR>
   <BR>
   VR Juggler has a completly extensible configuration system, that 
   theoretically you could use outside of VRJuggler or even outside of any 
   sort of VR paradigm.  <BR>
   <BR>
   See <a href="${VJCONTROL}/index.html">VJCONTROL documentation</a> for more instruction.
   </p>
</ul>

<h3><a name="code"> Source Code </a></h3>
<ul>
   <h4><a name="CaveCode">Form of a basic GLUT program</a></h4>
   <pre>
   void main(int argc, char* argv[])
   {
      // initialize the application data here
      OnApplicationInit();

      // create a window to render graphics in
      // In Juggler, window creation is done for you based on your configuration file settings.
      ::glutInitWindowSize( 640, 480 );
      ::glutInit( &argc, argv );
      ::glutInitDisplayMode( GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE );
      ::glutCreateWindow( "GLUT application" );

      // display callbacks.
      // NOTE: the first time OnIdle is called is when you should initialize each display context
      //       this is analogous to VR Juggler's <b>vjGlApp::contextInit()</b> function
      ::glutReshapeFunc( OnReshape );
      ::glutIdleFunc( OnIdle );
      ::glutDisplayFunc( OnIdle );

      // tell glut to not call the keyboard callback repeatedly 
      // when holding down a key. (uses edge triggering, like the mouse does)
      ::glutIgnoreKeyRepeat( 1 );

      // keyboard callback functions.
      ::glutKeyboardFunc( OnKeyboardDown );
      ::glutKeyboardUpFunc( OnKeyboardUp );
      ::glutSpecialFunc( OnSpecialKeyboardDown );
      ::glutSpecialUpFunc( OnSpecialKeyboardUp );

      // mouse callback functions...
      ::glutMouseFunc( OnMouseClick );
      ::glutMotionFunc( OnMousePos );
      ::glutPassiveMotionFunc( OnMousePos );

      // start the application loop, your callbacks will now be called
      // time for glut to sit and spin.  In Juggler this is the same as the while(1) (see below)
      ::glutMainLoop();
   }
   </pre>

   <h4><a name="JugglerCode">Form of a basic VRJuggler program</a></h4>
   <pre>
   class MyApplication
   {
   public:
   // Data callbacks  (Do not put OpenGL code here)
      virtual void init();
      virtual void preFrame();
      virtual void intraFrame();
      virtual void postFrame();
      
   // OpenGL callbacks (put only OpenGL code here)
      virtual void contextInit();
      virtual void draw();
   };

   int main(int argc, char* argv[]) 
   {
      // configure kernel with *.config files
      vjKernel* kernel = vjKernel::instance(); // Get the kernel
      for(int i=1;i&lt;argc;i++)
      {
         // loading config file passed on command line...
         kernel-&gt;loadConfigFile(argv[i]);
      }

      // start the kernel
      kernel-&gt;start();

      // set the application for the kernel to run
      MyApplication* application = new MyApplication();
      kernel-&gt;setApplication(application);

      // hit CTRL-C to exit.
      while (1)
      {
         // Juggler executes within other threads, so sleep here.
         usleep( 100000 );
      }
   }
   </pre>
</ul>

</body>
