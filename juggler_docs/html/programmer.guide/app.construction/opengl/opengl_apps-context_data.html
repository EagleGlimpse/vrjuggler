<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>OpenGL App Interface</title>
<!-- <link rel="stylesheet" type="text/css" href="../../../../style/base_style.css"> -->
</head>

<body>

<h2>Context specific data&nbsp;</h2>
<h3>What is an OpenGL context</h3>
<p>As you probably already know, the OpenGL graphics API operates using a state
machine that tracks the current settings and attributes that the OpenGL code has
set.&nbsp; Each window that we are drawing in using OpenGL has a state machine
associated with it.&nbsp; The state machines associated with these windows are referred
to as OpenGL rendering contexts.</p>
<h3>Examples of context specific data</h3>
<p>Each context stores the current state of on instance of an OpenGL
renderer.&nbsp; This includes the things such as</p>
<ul>
  <li>Current color</li>
  <li>Current shading mode</li>
  <li>Current texture</li>
  <li>Display lists</li>
  <li>Texture objects</li>
</ul>
<h3>Why do you need it</h3>
<p>As outlined in previous sections, VR Juggler uses a single memory area for
all application data.&nbsp; All threads can see the same memory area and thus
share the same copy of all variables.&nbsp; This makes programming normal
application code very easy because you never have to worry about which thread
can see which variables.&nbsp; But in the case of context specific data, it
presents a problem.</p>
<p>To understand the problem, consider an environment where we are using a
single display list.&nbsp; That display list is created to draw some object in
the scene.&nbsp; We would like to be able to just call the display list in out <tt>draw()</tt>
function and have it draw the primitives that we captured in it.</p>
<p>The following class shows an outline of the idea we are talking about.&nbsp;
Don't worry for now that we don't show the code where we allocate the display
list, that will be covered late.&nbsp; For now all we need to see is that we
have a variable that stores the display list id and we use it in the draw
function.</p>
<pre>class userApp : public vjGlApp
{
public:
  draw();
public:
  int mDispListId;
};

myApp::draw()
{
   glCallList(mDispListId);
}</pre>

<p>The problem that occurs is imagine that we have a VR system configured that
needs more than one display window (a CAVE for example).&nbsp; There is a thread
for each display, and all the display threads are calling <tt>draw()</tt> in
parallel.</p>

<p>The problem is that since all threads share the same copy of the variables,
they are all using the same mDispListId in the glCallList.&nbsp; This is an
error because we are calling draw from multiple windows (ie. multiple OpenGL
rendering contexts).&nbsp; The display list id is <b>not</b> the same in each
context.</p>

<p>This means that what we really need is a way to use a different display list
id depending upon what context we are currently drawing within.</p>
<p>That is where context specific data comes to the rescue.&nbsp; Context
specific data provides us with just that; it is a way to have a variable that
has a separate copy for each OpenGL rendering context.&nbsp; The best part about
it is that VR Juggler manages the variable in such a way that it looks just like
a normal variable, and the developer never has to deal with contexts
directly.&nbsp; VR Juggler just transparently makes sure that the correct copy
of the variable is being used.</p>

<h3>What do context specific variables look like?</h3>

<p>A context specific variable looks like this...</p>

<pre>class userApp : public vjGlApp
{
public:
  draw();
public:
  vjGlContextData&lt;int&gt; mDispListId;
};

myApp::draw()
{
   glCallList(*mDispListId);
}</pre>
<p>This code looks nearly exactly the same as the previous example, except that
the mDispListId is treated like a pointer, and it has a special template based
type that tells VR Juggler it is context specific data.</p>
<p>When defining a context specific data member, you just have to use the <tt>vjGlContextData&lt;&gt;</tt>
template and pass the &quot;true&quot; type of the variable to the template
definition.&nbsp; From then on, you can just treat it like a normal pointer.</p>
<p>Note: The types that are used use for context specific data <b>must</b>
provide default constructors.&nbsp; The user can not directly call the
constructor for the data item because VR Juggler has to dynamically allocate new
items on the fly as new contexts are created.</p>
<h3>How do they work?</h3>
<p>So, you may be wondering how this all works.&nbsp; Well, here is the brief
description.</p>
<p>The context data items are allocated using a template based smart pointer
class (<tt>vjGlContextData&lt;&gt;</tt>).&nbsp; Then behind the scene VR Juggler
keeps a list of currently allocated variables for each context.&nbsp; When the
application wants to use a context data item, the smart pointer looks in the
list and returns a reference to the correct copy for the current context.</p>
<p>This is all done in a fairly lightweight manner.&nbsp; It all boils down to
one memory lookup and a couple of pointer dereferences.&nbsp; Not bad for all
the power it gives.<br>
&nbsp;</p>

</body>

</html>
