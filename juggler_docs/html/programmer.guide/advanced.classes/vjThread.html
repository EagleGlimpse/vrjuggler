<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HEAD>
<TITLE>vjThread Interface</TITLE>
</HEAD>

<BODY>

<H2>Using the <TT>vjThread</TT> Interface</H2>

<!-- install-web toc-begin -->
<H3>Table of Contents</H3>

  <OL>
    <LI>
      <A HREF="#intro">Introduction</A>
    </LI>
    <LI>
      <A HREF="#reading">Recommended Reading</A>
    </LI>
    <LI>
      <A HREF="#high-level">High-Level Description</A>
    </LI>
    <LI>
      <A HREF="#use">Using <TT>vjThread</TT></A>
      <OL TYPE="i">
	<LI>
	  <A HREF="#creating">Creating <TT>vjThread</TT>s</A>
	</LI>
	<LI>
	  <A HREF="#join">Waiting for a Thread to Complete</A>
	</LI>
	<LI>
	  <A HREF="#suspend">Suspending and Resuming a Thread's Execution</A>
	</LI>
	<LI>
	  <A HREF="#priority">Getting and Setting a Thread's Priority</A>
	</LI>
	<LI>
	  <A HREF="#signal">Sending Signals to a Thread</A>
	</LI>
	<LI>
	  <A HREF="#cancel">Cancelling a Thread's Execution</A>
	</LI>
	<LI>
	  <A HREF="#self">Requesting the Current Thread's Identifier</A>
	</LI>
      </OL>
    </LI>
    <LI>
      <A HREF="#details">The Gory Details</A>
    </LI>
  </OL>
<!-- install-web toc-end -->

<H3><A NAME="intro">Introduction</A></H3>

  <P>
    When considering multithreaded programming, Spider-Man would most
    certainly think, ``With great power comes great responsibility.''
    The power is being able to provide multiple
    <A HREF="${GLOSSARY}#thread">threads</A> of control in a single
    application, and the responsibility is making sure those threads get
    along with each other and do not step on each other's data.  VR Juggler
    is a multithreaded library which makes it very powerful and very
    complex.
  </P>

  <P>
    As a cross-platform framework, VR Juggler uses an internal threading
    abstraction that provides a uniform interface to platform-specific
    threading implementations.  That cross-platform interface is available
    to you as a programmer to make your applications multithreaded without
    tying them to a specific type of threading implementation.  This
    section describes the interface and how to use it.  Further sections
    explain more details such as
    <A HREF="${GLOSSARY}#semaphore">semaphores</A> and
    <A HREF="${GLOSSARY}#mutex">mutexes</A>.
  </P>

<H3><A NAME="reading">Recommended Reading</A></H3>

  <P>
    Before reading this sections, it is assumed that you already know the
    basics of multithreaded programming including what a thread is.  What
    is described here is how to use the VR Juggler thread interface,
    <TT>vjThread</TT>, not how to write multithreaded software.  For that
    reason, it is recommended that you read the following publications
    before continuing:

    <UL>
      <LI>
	<A HREF="http://www.oreilly.com/catalog/pthread/"><I>Pthreads
	Programming</I></A> by Bradford Nichols, Dick Buttlar &amp;
	Jacqueline Proulx Farrell.
      </LI>
      <LI>
	The <TT>sproc</TT>(2) manual page on IRIX or on SGI's
	<A HREF="http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&db=man&fname=/usr/share/catman/p_man/cat2/standard/nsproc.z&srch=sproc">technical
	publications site</A>.
      </LI>
      <LI>
	The <TT>pthread</TT>(3) manual page for your operating system.  The
	pthread functions are part of a POSIX standard and will be the same
	across platforms.
      </LI>
<!-- XXX: Need a Win32 thread reference!
      <LI>
	Win32 ...
      </LI>
-->
    </UL>
  </P>

<H3><A NAME="high-level">High-Level Description</A></H3>

  <P>
    The threading interface in VR Juggler is modeled after the POSIX
    thread specification of POSIX.4.  The main difference is that VR
    Juggler's interface is object-oriented while POSIX threads (pthreads)
    are procedural.  The basic principles are exactly the same, however.
    A function (or class method) is provided to the <TT>vjThread</TT>
    class, and that function is executed in a thread of control that is
    independent of the creating thread.
  </P>

  <P>
    Threads are spawned (initialized and begin execution) when the
    <TT>vjThread</TT> constructor is called.  That is, when you instantiate
    a <TT>vjThread</TT> object, a new thread of execution is created.  The
    semantics of threads says that a thread can begin execution at any time
    after being created, and this is true with <TT>vjThread</TT>s.  Do not
    make any assumptions about when the thread will begin running.  It may
    happen before or after the constructor returns the <TT>vjThread</TT>
    object.
  </P>

  <P>
    To pass arguments to threads, the common mechanism of encapsulating
    them in a C++ <TT>struct</TT> must be used.  The function executed by
    the thread takes only a single argument of type <TT>void*</TT>.  An
    argument is not required, of course, but if you want to pass more than
    one argument to your thread, the best way to do this is to create a
    structure and pass a pointer to it to the <TT>vjThread</TT> constructor.
  </P>

  <P>
    Once you have your <TT>vjThread</TT> object, it acts as an interface
    into controlling the thread it encapsulates.  You can send the thread
    signals, suspend its execution, change its priority, etc.  This
    interface is the focus of this section.
  </P>

<H3><A NAME="use">Using <TT>vjThread</TT></A></H3>

  <P>
    Use of <TT>vjThread</TT> is intended to be easy.  Multithreaded
    programming has enough complications without having a difficult API as
    well.  In almost all cases, all you need to do to create a thread is
    pass a function pointer to the <TT>vjThread</TT> constructor and give
    it a pointer to any arguments that should be passed to the function
    when the thread is created.  You can deal with the priority, stack
    size and other unpleasantness, but the defaults for the constructor
    are quite reasonable.
  </P>

  <P>
    A minor issue with creating a <TT>vjThread</TT> is the concept of
    <A HREF="${GLOSSARY}#functor}">functors</A>.  (Yes, that is a real word
    if you were curious.  If it's in the dictionary, it must be a real
    word, ain't that right?)  The topic of functors will be put off until
    <A HREF="${PROGRAMMERGUIDE}/advanced.classes/vjBaseThreadFunctor.html">another
    section</A>.  For now, just think of them as wrappers around function
    pointers.
  </P>

  <P>
    Before writing code that uses <TT>vjThread</TT>s, make sure that your
    file includes the header <TT>Thread/vjThread.h</TT>.  Never include
    the platform-specific headers such as <TT>Thread/vjThreadPosix.h</TT>.
    The single file <TT>Thread/vjThread.h</TT> is all you ever need.
  </P>

<H4><A NAME="creating">Creating <TT>vjThread</TT>s</A></H4>

  <P>
    On with the code examples!  The following example illustrates how to
    create a thread that will execute a function called <TT>run()</TT>
    that takes no arguments.  The prototype for <TT>run()</TT> is:

<PRE>
    void run(void* args);
</PRE>

    This will be the same across all platforms.  The thread creation code
    is then:

<PRE>
    vjThread* thread;

    thread = new vjThread(run);
</PRE>

    At this point, a newly spawned thread is executing the code in
    <TT>run()</TT>.  You will probably want to hang onto the variable
    <TT>thread</TT> so that you can control the thread as necessary.
  </P>

  <P>
    Well, that was pretty easy.  What if you want to pass one or more
    arguments to <TT>run()</TT> so that its behavior can be modified based
    on some variables?  Not surprisingly, that is fairly easy too.  As
    mentioned above, if you have more than one argument to pass to the
    thread function, you will need to collect them into a <TT>struct</TT>
    and pass a pointer to that struct.  A common way to do this is as
    follows:

<PRE>
    struct _thread_args {
        int id;
        char name[40];
        // And so on...
    };

    typedef struct _thread_args thread_args_t;

    void
    someFunc () {
        // Other code ...

        thread_args_t* args;
        vjThread* thread;

        args = new thread_arg_t();

        // Fill in the elements of args ...

        thread = new vjThread(run, (void*) args);
    }
</PRE>

    When creating a single thread, this works beautifully.  If you want to
    create multiple threads all taking the same type of argument, you will
    need to make separate argument structure instances for each one.  You
    can either declare a bunch of pointers or reuse the same one over and
    over.  The address passed to each thread will be unique either way.
    Using this method requires that you be careful to free the memory
    allocated for the argument structure before the thread exits, of course.
  </P>

<H4><A NAME="join">Waiting for a Thread to Complete</A></H4>

  <P>
    Once we have a thread running, it is often useful to synchronize
    another thread so that its execution halts until the running thread
    has completed.  This is called ``joining threads''.  The following
    example illustrates how this can be done:

<PRE>
    vjThread* thread;

    thread = new vjThread(run);

    // Do other things while the thread is going ...

    thread-&gt;join();

    // Now that the thread is done, continue.
</PRE>

    Here, the creator of <TT>thread</TT> can be another <TT>vjThread</TT>,
    or it can be the main thread of execution (though it probably won't
    be in VR Juggler).  In other words, any thread can create more threads
    and control them.  What happens in this example is that <TT>thread</TT>
    is created and begins running.  Meanwhile, the creator thread continues
    to do some more work and then needs to wait for <TT>thread</TT> to
    finish its work before continuing.  It calls the <TT>join()</TT>
    method, a blocking call, and it will not return until <TT>thread</TT>
    has completed.
  </P>

  <P>
    While it is not demonstrated here, the <TT>join()</TT> method can take
    a single argument of type <TT>void**</TT>.  It is a pointer to a
    pointer where the exit status of the joined thread is stored.  The
    operating system fills the pointed to pointer with the exit status
    when the thread does exit.
  </P>

  <P>
    It is very important to note that the implementation of thread joining
    is incomplete for some thread implementations, most notably, <B>IRIX
    sproc threads</B>.  This will be completed and will be available to all
    platforms in a future release.
  </P>

<H4><A NAME="suspend">Suspending and Resuming a Thread's Execution</A></H4>

  <P>
    Sometimes, you may want to suspend a running thread's execution and
    resume it again later.  There are two methods in the <TT>vjThread</TT>
    interface that do just this.  Assuming that you already have a running
    thread pointed to by the object <TT>thread</TT>, that thread can be
    suspended as follows:

<PRE>
    thread-&gt;suspend();
</PRE>

    Resuming that suspended thread's execution is just as easy:

<PRE>
    thread-&gt;resume();
</PRE>

    On successful completion, both methods return 0.  If the operation
    could not be performed for some reason, -1 is returned to indicate
    error status.
  </P>

<H4><A NAME="priority">Getting and Setting a Thread's Priority</A></H4>

  <P>
    Changing the priority of a thread tells the underlying operating
    system how important a thread is and gives it hints about how to
    schedule the threads.  If no value for the priority is given to the
    constructor, all <TT>vjThread</TT>s are created with the default
    priority for all threads.  Values higher than 0 for the priority
    request a higher priority when the thread is created.
  </P>

  <P>
    Besides being able to set the priority when the thread is created, it
    is possible to query and to adjust the priority of a running thread.
    Assuming that you already have a running thread pointed to by the
    object <TT>thread</TT>, that thread's priority can be requested as
    follows:

<PRE>
    int prio;

    thread-&gt;getPrio(&amp;prio);
</PRE>

    The thread's priority is stored in <TT>prio</TT> and returned via the
    pointer passed to the <TT>getPrio()</TT> method.  Setting that
    thread's priority is also easy:

<PRE>
    int prio;

    // Assign some priority value to prio ...

    thread-&gt;setPrio(prio);
</PRE>

    On successful completion, both methods return 0.  If the operation
    could not be performed for some reason, -1 is returned to indicate
    error status.
  </P>

<H4><A NAME="signal">Sending Signals to a Thread</A></H4>

  <P>
    On UNIX systems, a signal is sent to a process using the
    <TT>kill</TT>(2) system call.  With POSIX threads, signals are sent
    using <TT>pthread_kill</TT>(3).  VR Juggler's thread interface
    implements these ideas using a <TT>kill()</TT> method.  There are two
    ways to call this method: with an argument naming the signal to be
    delivered to the thread or without an argument which cancels the
    thread's execution.  The first of these is described in this section,
    and the second is described in the <A HREF="#cancel">next section</A>.
  </P>

  <P>
    A problem does arise here, unfortunately.  Signals are not supported
    on all operating systems (notably, Win32).  The interface is
    consistent, but your code written on IRIX will not compile on Win32 if,
    for example, it sends a <TT>SIGHUP</TT> to a thread.  An improved
    thread interface is being designed to overcome problems such as this
    one.  For now, we describe this part of the interface as though it is
    supported completely on all platforms.
  </P>

  <P>
    As usual, assume that you have a running thread, a pointer to which
    is stored in <TT>thread</TT>.  To send it a signal (<TT>SIGINT</TT>
    let's say), you would write the following:

<PRE>
    thread-&gt;kill(SIGINT);
</PRE>

    The signal will be delivered to the thread by the operating system,
    and the thread is expected to handle it properly.  This version of
    the <TT>kill()</TT> method returns 0 if the signal is sent
    successfully.  Otherwise, -1 is returned to indicate that an error
    occurred.
  </P>

<H4><A NAME="cancel">Cancelling a Thread's Execution</A></H4>

  <P>
    As described in the <A HREF="#signal">previous section</A>, using the
    <TT>kill()</TT> method with no argument cancels the execution of the
    thread.  When using POSIX threads, this is actually implemented using
    <TT>pthread_cancel</TT>(3).  On IRIX with sproc threads, a
    <TT>SIGKILL</TT> is sent to the thread to end its execution forcibly.
    The syntax for using this method is basically the same as in the
    previous section, but it is repeated to make that clear.  Again
    assuming that you have a running thread with a pointer to its
    <TT>vjThread</TT> object stored in <TT>thread</TT>, you would do the
    following:

<PRE>
    thread-&gt;kill();
</PRE>

    Unlike the syntax used to send a signal to a thread, this version of
    <TT>kill()</TT> does not have a return value.
  </P>

  <P>
    Users of POSIX threads may be wondering if the <TT>vjThread</TT> API
    provides a way to set cancellation points in the code.  Unfortunately,
    it does not at this time.  Extending the interface in this way is
    being considered, but cancellation points do not have meaning with all
    thread implementations.
  </P>

<H4><A NAME="self">Requesting the Current Thread's Identifier</A></H4>

  <P>
    Lastly, it is common to request the currently running thread's
    identifier.  This only makes sense when called from a point on that
    thread's flow of execution.  (In POSIX threads, this is the notion of
    ``self''.  For IRIX sproc threads, this means getting the process ID.)
    The <TT>vjThread</TT> API provides a static method that can be called
    at any time in the thread that is currently running.  It returns a
    pointer to a <TT>vjBaseThread</TT> (the basic type from which
    <TT>vjThread</TT> inherits its interface).  The syntax is as follows:

<PRE>
    vjBaseThread* my_id;

    my_id = vjThread::self();
</PRE>

    The returned pointer can then be used to perform all of the previously
    described operations on the current thread.
  </P>

<H3><A NAME="details">The Gory Details</A></H3>

  <P>
    The current threading implementation in VR Juggler is a little
    difficult to understand.  The code is not complicated at all, but
    because all platform-specific implementations are referred to as
    <TT>vjThread</TT>s, the details can get lost in the shuffle.  To
    begin, the current list of platform-specific thread implementation
    wrapper classes are:
    
    <UL>
      <LI>
	<TT>vjThreadSGI</TT>: A wrapper around IRIX sproc threads (refer
	to the <TT>sproc</TT>(2) manual page for more information)
      </LI>
      <LI>
	<TT>vjThreadPosix</TT>: A wrapper around POSIX threads (both Draft
	4 and Draft 10 of the standard are supported)
      </LI>
      <LI>
	<TT>vjThreadWin32</TT>: A wrapper around Win32 threads
      </LI>
    </UL>

    The interface itself is defined in <TT>vjBaseThread</TT>, and all of
    the above classes inherit from <TT>vjBaseThread</TT>.
  </P>

  <P>
    The threading implementation used is chosen when VR Juggler is
    compiled.  If you want to use a certain type of thread system or have
    specific requirements, you must be sure that the version of VR Juggler
    you are using was compiled with the type of threads you need.  When the
    VR Juggler build is configured, preprocessor <TT>#define</TT> statements
    are made in <TT>vjDefines.h</TT> that describe the threading system to
    use.  Based on that, the header file <TT>Threads/vjThread.h</TT> makes
    several <TT>typedef</TT>s that set up one of the platform-specific
    thread implementations to act as the <TT>vjThread</TT> interface.
    For example, if compiling on Win32, the class <TT>vjThreadWin32</TT>
    is <TT>typedef</TT>'d to be <TT>vjThread</TT>.  Since the interface is
    consistent among all the wrappers, everything works as though that was
    the way it was written to behave.
  </P>

  <P>
    The current implementation is modeled after the POSIX thread API for
    the most part.  When designing it, we approached it with the idea that
    having a more complete API was more important than having a
    ``lowest-common-denominator'' API.  That is, just because not all
    threading implementations support a specific feature does not mean that
    the API should suffer by not having that feature.  Whether this was a
    good approach or not is an open debate.
  </P>

  <P>
    As mentioned in the previous section, changes are in the pipeline that
    could dramatically change the way the threading subsystem in VR Juggler
    is implemented.  Instead of writing our own wrappers for all necessary
    threading implementations, we plan to write a single wrapper around the
    <A HREF="http://www.mozilla.org/projects/nspr/index.html" TARGET="_top">Netscape
    Portable Runtime's</A> threads.  Doing this will offload much of our
    efforts onto the NSPR.  Most of what has been described in the
    <TT>vjThread</TT> interface will remain consistent after this change,
    but the NSPR threads do not support all the features we have because
    they took the lowest-common-denominator approach.  As with all
    technology, there is a trade-off in relieving some of our work load by
    using an existing cross-platform thread implementation: our interface
    becomes limited to what features that implemenation provides.  Since
    this is still off in the future, it remains to be seen exactly how VR
    Juggler's threading subsystem will change, and those programmers who
    choose to use it should be careful to watch the
    <A HREF="${CONTACT}/writeUs.html">mailing lists</A> for discussions and
    announcements about changes.
  </P>

</BODY>
