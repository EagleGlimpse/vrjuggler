<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HEAD>
<TITLE>vjMutex Interface</TITLE>
</HEAD>

<BODY>

<H2>Using the <TT>vjMutex</TT> Interface</H2>

<!-- install-web toc-begin -->
<H3>Table of Contents</H3>

  <OL>
    <LI>
      <A HREF="#intro">Introduction</A>
    </LI>
    <LI>
      <A HREF="#high-level">High-Level Description</A>
    </LI>
    <LI>
      <A HREF="#use">Using <TT>vjMutex</TT></A>
      <OL TYPE="i">
	<LI>
	  <A HREF="#creating">Creating a <TT>vjMutex</TT></A>
	</LI>
	<LI>
	  <A HREF="#acquire">Locking a Mutex</A>
	</LI>
	<LI>
	  <A HREF="#tryacquire">Attempting to Lock a Mutex</A>
	</LI>
	<LI>
	  <A HREF="#test">Testing the State of a Mutex</A>
	</LI>
	<LI>
	  <A HREF="#release">Releasing a Locked Mutex</A>
	</LI>
      </OL>
    </LI>
    <LI>
      <A HREF="#details">The Gory Details</A>
    </LI>
  </OL>
<!-- install-web toc-end -->

<A NAME="intro"><H4>Introduction</H4></A>

  <P>
    In addition to cross-platform
    <A HREF="${GLOSSARY}#semaphore">semaphores</A>, VR Juggler provides an
    abstraction for cross-platform <A HREF="${GLOSSARY}#mutex">mutexes</A>.
    Mutexes are a special type of semaphore known as a ``binary semaphore''.
    Exactly one thread can hold the lock at any time.  This very short
    section, however, is not about mutexes but rather about the
    <TT>vjMutex</TT> interface provided with and used by VR Juggler.
  </P>

<A NAME="high-level"><H4>High-Level Description</H4></A>

  <P>
    The cross-platform mutex abstraction in VR Juggler is critical for
    properly synchronizing access to shared data.  If you have read the
    <A HREF="${PROGRAMMERGUIDE}/advanced.classes/vjSemaphore.html">section
    on <TT>vjSemaphore</TT>s</A>, you will find this section very, very
    familiar.  The interface for <TT>vjMutex</TT> is a subset of that for
    <TT>vjSemaphore</TT> since mutexes are binary semaphores.  You can
    lock them and unlock them.  That's all there is to know.  The
    <TT>vjMutex</TT> interface does include some methods for read/write
    mutexes, but this implementation is incomplete and is not documented
    here for that reason.  When the implementation is finished, this
    documentation will be expanded.
  </P>

<A NAME="use"><H4>Using <TT>vjMutex</TT></H4></A>

  <P>
    At this point, if you have read the preceding sections in the
    Advanced Classes chapter, you know what is coming: the header file
    to include for using <TT>vjMutex</TT>!  Woo hoo!  This time, it's
    <TT>Sync/vjMutex.h</TT>.  I bet you didn't see that coming.
  </P>

<A NAME="creating"><H5>Creating a <TT>vjMutex</TT></H5></A>

  <P>
    When you create a <TT>vjMutex</TT> object, there are no special
    parameters to pass or considerations to be made.  You simply create
    the object, and you are ready to go.  An example of creating a mutex
    is as follows:

<PRE>
    vjMutex mutex;
</PRE>

    There is nothing more to say this time.
  </P>

<A NAME="acquire"><H5>Locking a Mutex</H5></A>

  <P>
    When a thread needs to acquire access to shared data, it can lock a
    mutex.  In the <TT>vjMutex</TT> interface, this is accomplished using
    the <TT>acquire()</TT> method:

<PRE>
    mutex.acquire();
</PRE>

    This assumes that you have an existing <TT>vjMutex</TT> object called
    <TT>mutex</TT>.  As expected, <TT>acquire()</TT> is a blocking
    call, so if the mutex is already locked by another thread, the thread
    requesting the lock will block until the mutex is released by the
    other thread.
  </P>

  <P>
    Note that the return value of <TT>acquire()</TT> is a little different
    than most calls.  If the lock is acquired, 1 is returned.  If the
    attempt to lock the semaphore fails for some reason, -1 is returned.
  </P>

<A NAME="tryacquire"><H5>Attempting to Lock a Mutex</H5></A>

  <P>
    If you want to lock a mutex only when the call would not block, a method
    is provided to do this.  It is called <TT>tryAcquire()</TT>, and it will
    not block if the mutex is already locked.  It works as follows (again
    assuming an existing mutex called <TT>mutex</TT>):

<PRE>
    mutex.tryAcquire();
</PRE>

    If the mutex is locked, 1 is returned.  Otherwise, 0 is returned.
  </P>

<A NAME="test"><H5>Testing the State of a Mutex</H5></A>

  <P>
    In addition to conditionally locking, you can test the state of a mutex
    to see if it is locked or unlocked.  This is done using the
    <TT>test()</TT> method as follows:

<PRE>
    int state;

    state = mutex.test();
</PRE>

    If the mutex is <I>not</I> locked, 0 is returned.  Otherwise, 1 is
    returned.
  </P>

<A NAME="release"><H5>Releasing a Locked Mutex</H5></A>

  <P>
    When you are done accessing the shared data, you release the lock you
    had been holding using the <TT>release()</TT> method:

<PRE>
    mutex.release();
</PRE>

    If the locked semaphore is released successfully, 0 is returned.
    Otherwise, -1 is returned.
  </P>

<A NAME="details"><H4>The Gory Details</H4></A>

  <P>
    If you have read the Gory Details sections for
    <A HREF="${PROGRAMMERGUIDE}/advanced.classes/vjThread.html#details"><TT>vjThread</TT>s</A>
    or for
    <A HREF="${PROGRAMMERGUIDE}/advanced.classes/vjSemaphore.html#details"><TT>vjSemaphore</TT>s</A>,
    you will find this section very familiar (and probably uninteresting at
    this point).  As with <TT>vjThread</TT>s and <TT>vjSemaphore</TT>s,
    there are several platform-specific mutex implementation wrapper
    classes:
    
    <UL>
      <LI>
	<TT>vjMutexSGI</TT>: A wrapper around IRIX shared-arena
	mutexes (refer to the <TT>usnewlock</TT>(3P) and related manual
	pages for more information)
      </LI>
      <LI>
	<TT>vjThreadPosix</TT>: A wrapper around POSIX thread mutexes (both
	Draft 4 and Draft 10 of the standard are supported)
      </LI>
      <LI>
	<TT>vjMutexWin32</TT>: A wrapper around Win32 mutexes
      </LI>
    </UL>

    Similar to <TT>vjSemaphore</TT>, there is no base interface from which
    these implementations inherit since there is no real need for this.
    Performance issues caused by virtual functions are avoided by doing
    this.
  </P>

  <P>
    The mutex implementation used is chosen when VR Juggler is compiled and
    will <I>always</I> match the thread implementation being used.  When the
    VR Juggler build is configured, preprocessor <TT>#define</TT> statements
    are made in <TT>vjDefines.h</TT> that describe the threading system and
    thus the mutexes to use.  Based on that, the header file
    <TT>Sync/vjMutex.h</TT> makes several <TT>typedef</TT>s that set up one
    of the platform-specific thread implementations to act as the
    <TT>vjMutex</TT> interface.  For example, if compiling on Solaris, the
    class <TT>vjMutexPosix</TT> is <TT>typedef</TT>'d to be
    <TT>vjMutex</TT>.  Since the interface is consistent among all the
    wrappers, everything works as though that was the way it was written to
    behave.
  </P>

</BODY>
