<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HEAD>
<TITLE>vjSemaphore Interface</TITLE>
</HEAD>

<BODY>

<H2>Using the <TT>vjSemaphore</TT> Interface</H2>

<!-- install-web toc-begin -->
<H3>Table of Contents</H3>

  <OL>
    <LI>
      <A HREF="#intro">Introduction</A>
    </LI>
    <LI>
      <A HREF="#high-level">High-Level Description</A>
    </LI>
    <LI>
      <A HREF="#use">Using <TT>vjSemaphore</TT></A>
      <OL TYPE="i">
	<LI>
	  <A HREF="#creating">Creating a <TT>vjSemaphore</TT></A>
	</LI>
	<LI>
	  <A HREF="#acquire">Locking a Sempahore</A>
	</LI>
	<LI>
	  <A HREF="#tryacquire">Attempting to Lock a Sempahore</A>
	</LI>
	<LI>
	  <A HREF="#release">Releasing a Locked Semaphore</A>
	</LI>
      </OL>
    </LI>
    <LI>
      <A HREF="#details">The Gory Details</A>
    </LI>
  </OL>
<!-- install-web toc-end -->

<H3><A NAME="intro">Introduction</A></H3>

  <P>
    The most important part of multithreaded programming is properly
    synchronizing the threads so that access to shared data is controlled
    resulting in consistency among all threads.
    <A HREF="${GLOSSARY}#semaphore">Semaphores</A> are a very common
    synchronization mechanism and have been used widely in concurrent
    systems.  This short section describes the cross-platform semaphore
    interface provided with and used by VR Juggler.  It does not explain
    what semaphores are or how to use them--it is assumed that you
    already know that or you probably wouldn't be reading this chapter on
    advanced classes at all.
  </P>

<H3><A NAME="high-level">High-Level Description</A></H3>

  <P>
    As with threads, a cross-platform abstraction layer has been written
    into VR Juggler to provide a consistent way to use semaphores on all
    supported platforms.  The primary goal behind the interface design is
    to provide the common <I>P</I> (acquire) and <I>V</I> (release)
    operations.  The interface does include methods for read/write
    semaphores, but as of this writing, that part of the interface is not
    complete.  Because of that, the use section does not cover that part
    of the interface.  When the implementation is complete, this section
    will be expanded.
  </P>

<H3><A NAME="use">Using <TT>vjSemaphore</TT></A></H3>

  <P>
    If you have been reading all of the sections in this chapter
    faithfully, you know that this is the point where you are told which
    header file to include in your code to use <TT>vjSemaphore</TT>s.
    This time around, the file is <TT>Sync/vjSemaphore.h</TT>.  You do
    not want to include any of the platform-specific implementation files.
    That is all handled appropriately within <TT>Sync/vjSemaphore.h</TT>.
  </P>

<H4><A NAME="creating">Creating a <TT>vjSemaphore</TT></A></H4>

  <P>
    When you create a <TT>vjSemaphore</TT> object, you give the initial
    value that represents the number of resources being controlled by the
    semaphore.  If no value is given, the default value is 1 which of
    course gives a binary semaphore, better known as a
    <A HREF="${GLOSSARY}#mutex">mutex</A> (see the
    <A HREF="${PROGRAMMERGUIDE}/advanced.classes/vjMutex.html">section on
    <TT>vjMutex</TT></A> for more information about that).  An example of
    creating a simple semaphore to control access to 5 resources is as
    follows:

<PRE>
    vjSemaphore sema(5);
</PRE>

    You now have a semaphore capable of controlling concurrent access to
    5 resources.  Easy, no?  Should you at some point need to change the
    number of resources, a method called <TT>reset()</TT> is provided to
    do this.  You pass the new number of resources, and the semaphore
    object is updated appropriately:

<PRE>
    sema.reset(4);
</PRE>

    As you can guess, the semaphore <TT>sema</TT> now controls access to
    4 resources instead of 5.
  </P>

<H4><A NAME="acquire">Locking a Semaphore</A></H4>

  <P>
    When a thread needs to acquire access to shared data, it locks a
    semaphore.  In the <TT>vjSemaphore</TT> interface, this is
    accomplished using the <TT>acquire()</TT> method:

<PRE>
    sema.acquire();
</PRE>

    This assumes that you have an existing <TT>vjSemaphore</TT> object
    called <TT>sema</TT>.  As expected, <TT>acquire()</TT> is a blocking
    call, so if the semaphore's value is less than or equal to 0, the
    thread requesting the lock will block until the semaphore's value is
    greater than 0.
  </P>

  <P>
    Note that the return value of <TT>acquire()</TT> is a little different
    than most calls.  If the lock is acquired, 1 is returned.  If the
    attempt to lock the semaphore fails for some reason, -1 is returned.
  </P>

<H4><A NAME="tryacquire">Attempting to Lock a Semaphore</A></H4>

  <P>
    If you want to lock a semaphore only when the call would not block, a
    method is provided to do this.  It is called <TT>tryAcquire()</TT>,
    and it will not block if the semaphore cannot be locked.  It works as
    follows (again assuming an existing semaphore called <TT>sema</TT>):

<PRE>
    sema.tryAcquire();
</PRE>

    If the semaphore is locked, 1 is returned.  Otherwise, 0 is returned,
    and you can try again later.
  </P>

<H4><A NAME="release">Releasing a Locked Semaphore</A></H4>

  <P>
    Finally, when you are done accessing the shared data, you release
    the lock you had been holding using the <TT>release()</TT> method:

<PRE>
    sema.release();
</PRE>

    If the locked semaphore is released successfully, 0 is returned.
    Otherwise, -1 is returned.
  </P>

<H3><A NAME="details">The Gory Details</A></H3>

  <P>
    If you have read the
    <A HREF="${PROGRAMMERGUIDE}/advanced.classes/vjThread.html#details">Gory
    Details section for <TT>vjThread</TT>s</A>, you will find this section
    very familiar.  As with <TT>vjThread</TT>s, there are several
    platform-specific semaphore implementation wrapper classes:
    
    <UL>
      <LI>
	<TT>vjSemaphoreSGI</TT>: A wrapper around IRIX shared-arena
	semaphores (refer to the <TT>usnewsema</TT>(3P) and related manual
	pages for more information)
      </LI>
      <LI>
	<TT>vjSemaphorePosix</TT>: A wrapper around POSIX real-time
	semaphores (POSIX.4)
      </LI>
      <LI>
	<TT>vjSemaphoreWin32</TT>: A wrapper around Win32 semaphores
      </LI>
    </UL>

    Unlike <TT>vjThread</TT>, however, there is no base interface from
    which these implementations inherit since there is no real need for
    this.  Performance decreases caused by virtual functions are avoided
    this way.
  </P>

  <P>
    The semaphore implementation used is chosen when VR Juggler is
    compiled and will <I>always</I> match the thread implementation being
    used.  When the VR Juggler build is configured, preprocessor
    <TT>#define</TT> statements are made in <TT>vjDefines.h</TT> that
    describe the threading system and thus the semaphores to use.  Based on
    that, the header file <TT>Sync/vjSemaphore.h</TT> makes several
    <TT>typedef</TT>s that set up one of the platform-specific thread
    implementations to act as the <TT>vjSemaphore</TT> interface.  For
    example, if compiling on Linux, the class <TT>vjSempahorePosix</TT>
    is <TT>typedef</TT>'d to be <TT>vjSemaphore</TT>.  Since the interface
    is consistent among all the wrappers, everything works as though that
    was the way it was written to behave.
  </P>

</BODY>
