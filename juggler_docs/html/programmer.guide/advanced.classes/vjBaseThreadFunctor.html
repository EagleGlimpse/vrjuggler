<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HEAD>
<TITLE>vjBaseThreadFunctor Interface</TITLE>
</HEAD>

<BODY>

<H2>Using the <TT>vjBaseThreadFunctor</TT> Interface</H2>

<H3>Table of Contents</H3>

  <OL>
    <LI>
      <A HREF="#intro">Introduction</A>
    </LI>
    <LI>
      <A HREF="#high-level">High-Level Description</A>
    </LI>
    <LI>
      <A HREF="#use">Using <TT>vjBaseThreadFunctor</TT></A>
      <OL TYPE="i">
	<LI>
	  <A HREF="#member"><TT>vjThreadMemberFunctor</TT></A>
	</LI>
	<LI>
	  <A HREF="#non-member"><TT>vjThreadNonMemberFunctor</TT></A>
	</LI>
      </OL>
    </LI>
    <LI>
      <A HREF="#details">The Gory Details</A>
    </LI>
  </OL>

<A NAME="intro"><H4>Introduction</H4></A>

  <P>
    To begin, let us review the following poem:

    <BLOCKQUOTE>
      Functors, functors<BR>
      Roly poly functors<BR>
      Functors, functors<BR>
      Eat them up, yum!
    </BLOCKQUOTE>

    Stunning.  Just what is a functor, though?  As with much of VR Juggler,
    a functor is a high-level concept that encapsulates something quite
    simple.  A functor is defined as ``something that performs an
    operation or a function.''  While this is not very detailed, it is
    clear and concise.  In VR Juggler, functors can be used as the code
    executed by a thread (refer to the section on
    <A HREF="${PROGRAMMERGUIDE}/advanced.classes/vjThread.html"><TT>vjThread</TT>s</A>
    for more detail on that topic).  This section describes how you can
    use functors for exactly that purpose.
  </P>

<A NAME="high-level"><H4>High-Level Description</H4></A>

  <P>
    As mentioned, a functor is used in VR Juggler with <TT>vjThread</TT>s.
    VR Juggler's threads can execute two types of functions: normal C/C++
    functions and static class methods or functors.  The former was
    described in the section about
    <A HREF="${PROGRAMMERGUIDE}/advanced.classes/vjThread.html">using
    <TT>vjThread</TT>s</A>, and the latter is described here.  The use
    of functors is given more attention because the concept may be foreign
    to some programmers.  Those who already know about functors can skip
    this short description and go straight to the section on
    <A HREF="#use">using functors</A>.
  </P>

  <P>
    In VR Juggler, a functor is simply another object type that happens
    to encapsulate a user-defined function.  The details on how this is
    done are not important here, but they are <A HREF="#details">provided
    later</A> for those who are interested.  What is important to know is
    that a functor can be thought of as a normal function.  When using
    them, you as a programmer simply implement a function and then pass
    the function pointer (and the function's optional argument) to the
    functor's constructor.  The object does the rest.
  </P>

  <P>
    You may have noticed that parenthetical phrase in the previous
    paragraph that mentions your function's optional argument.  Note that
    ``argument'' is singular meaning that only one parameter can be
    passed to your function.  The type of that argument is the
    wonderfully vague <TT>void*</TT>, an artifact of basing the threading
    subsystem on C libraries.  As discussed in the section on using
    <TT>vjThread</TT>s, if you want to pass multiple arguments, you will
    have to encapsulate them in a <TT>struct</TT> or comparable object.
  </P>

  <P>
    Ultimately, once you have your functor object, you pass it to the
    <TT>vjThread</TT> constructor, and the new thread will execute your
    functor (which knows about your function).  The end result is the
    same as using a normal C/C++ function or a static class member function,
    but there is one special benefit: with functors, you can pass a
    non-static class member function.  What often happens when writing
    multithreaded C++ code is that you want to run some function in a class
    in a separate thread, and you would normally have to make that function
    a static member.  To get access to the class, you have to pass our
    lovely friend <TT>this</TT> as an argument to the thread function.  If
    you use a VR Juggler functor, that is all handled behind the scenes so
    that you can pass your non-static member function without a second
    thought.  Read on to find out how you too can join this exciting
    society of multithreaded programmers who pass member functions to
    their threads!
  </P>

<A NAME="use"><H4>Using <TT>vjBaseThreadFunctor</TT></H4></A>

  <P>
    The first step, as always, is to make sure that you have the necessary
    header file included in your code.  In this case, the header is
    <TT>Threads/vjThreadFunctor.h</TT>.  Within this header, you will
    notice that <TT>vjBaseThreadFunctor</TT> is an abstract base class
    with two subclasses <TT>vjThreadMemberFunctor</TT> and
    <TT>vjThreadNonMemberFunctor</TT> that implement the interface.
  </P>

<A NAME="member"><H5><TT>vjThreadMemberFunctor</TT></H5></A>

  <P>
    This implementation of <TT>vjBaseThreadFunctor</TT> is for all
    functions that fall into the rather elite category of being non-static
    class member functions.  To be more specific, those member functions
    (heretofore referred to as ``methods'') must have the following
    prototype:

<PRE>
    void methodName(void* arg);
</PRE>

    Those readers with experience in multithreaded programming will
    recognize this prototype instantly.  It is no different than that
    used in common threading implementations.  Constructing the functor
    to use this method, however, is quite different than what you may
    have seen before.
  </P>

  <P>
    Say you have a class <TT>MyObject</TT> with a method <TT>run()</TT>
    having the appropriate prototype that will be executed by a
    <TT>vjThread</TT> object.  In this case, <TT>run()</TT> takes an
    argument that is a pointer to a pre-defined type <TT>thread_args_t</TT>.
    Also assume that you have an instance of
    <TT>MyObject</TT> pointed to by the variable <TT>my_obj</TT>.  The
    following code creates the <TT>vjThreadMemberFunctor</TT> object that
    will encapsulate your method:

<PRE>
    vjThreadMemberFunctor&lt;MyObject&gt;* my_functor;
    thread_args_t* args;
    vjThread* thread;

    args = new thread_args_t();

    // Fill in the arguments to be passed to the thread...

    my_functor = new vjThreadMemberFunctor&lt;MyObject&gt;(my_obj, MyObject::run, (void*) args);
    thread = new vjThread(my_functor);
</PRE>

    The important thing to note in this example is that
    <TT>vjThreadMemberFunctor</TT> is a template class.  You have to
    provide the class as the template parameter when creating the functor
    instance.  (If you do not understand this syntax, take a look at a
    C++ book that covers the current C++ standard.)  Also note that when
    you create the new <TT>vjThread</TT> object, you <I>do not</I> pass
    the argument structure to the constructor.  The argument to
    <TT>run()</TT> is packaged up with the function in the functor
    object <TT>my_functor</TT>.  Once this code has executed, a new thread
    is spawned that will run your <TT>run()</TT> method given the
    argument structure you provided.
  </P>

  <P>
    The <TT>vjBaseThreadFunctor</TT> interface defines an extra method
    <TT>setArg()</TT> that allows you to set your function's argument
    after the object is created.  The argument to the constructor providing
    your function's argument is optional and will default to <TT>NULL</TT>
    if you do not specify it.  At a later time, should you have an argument
    to provide, you can do the following:

<PRE>
    thread_args_t* args;

    args = new thread_args_t();

    // Fill in args ...

    my_functor-&gt;setArg(args);
</PRE>

    This of course assumes that you already have a functor object
    instantiated called <TT>my_functor</TT>.  Alternatively, you could use
    <TT>setArg()</TT> to remove a previously defined argument by passing
    <TT>NULL</TT>.
  </P>

  <P>
    The last thing to note is that a lot of memory is being allocated
    dynamically in the example code.  You should, as usual, be careful to
    deallocate it when you are done with it.  That part of the process is
    up to you, though.
  </P>

<A NAME="non-member"><H5><TT>vjThreadNonMemberFunctor</TT></H5></A>

  <P>
    This implementation of <TT>vjBaseThreadFunctor</TT> is the complement
    of the set contained by the previously discussed implementation.  It
    is used for normal C/C++ functions and for static class member
    functions.  There is nothing terribly interesting about this class,
    and its use is straightforward.  The following example, an adaptation
    of that presented in the previous section, shows how you can use this
    interface rather than passing your function pointer and argument to
    the <TT>vjThread</TT> constructor.  In this case, assume that the
    function <TT>run()</TT> is appropriately defined for use here.

<PRE>
    vjThreadNonMemberFunctor* my_functor;
    thread_args_t* args;
    vjThread* thread;

    args = new thread_args_t();

    // Fill in the arguments to be passed to the thread...

    my_functor = new vjThreadNonMemberFunctor(run, (void*) args);
    thread = new vjThread(my_functor);
</PRE>

    That's all there is to it.  You end up doing more work than if you
    had just passed the function pointer and the associated argument to
    the <TT>vjThread</TT> constructor directly, but you relieve the
    <TT>vjThread</TT> constructor of some work.  (The reason for this is
    described <A HREF="#details">below</A>.)  Thus, either way is equally
    efficient, and what you use is up to you.
  </P>

<A NAME="details"><H4>The Gory Details</H4></A>

  <P>
    The magic behind these functors is done by overloading
    <TT>operator()</TT> for <TT>vjBaseThreadFunctor</TT> objects.  Both
    implementations of the interface store the function pointer and
    optional argument pointer, and when
    <TT>vjBaseThreadFunctor::operator()</TT> is invoked, they call the
    function and pass the argument if there is one.  There is a little
    more magic with the <TT>vjThreadMemberFunctor</TT>, however, that
    allows it to work with the methods of a given class.
  </P>

  <P>
    The class <TT>vjThreadMemberFunctor</TT> works its extra special
    magic through the use of a template and one of C++'s dustier
    operators, <TT>::*</TT>.  This operator is used to point to a
    member of a class, in this case, the method that will be executed by
    the thread.  When used in conjunction with the provided class
    instance, the method can be invoked by the functor.
  </P>

  <P>
    One interesting thing to note about <TT>vjThread</TT>s is that they
    deal only in functors, or more specifically, in objects that subsume
    to <TT>vjBaseThreadFunctor</TT>.  If you pass a function pointer and
    its argument directly to the <TT>vjThread</TT> constructor, a
    <TT>vjThreadNonMemberFunctor</TT> object is created to package those
    arguments.  That functor is then used internally by the thread.
    Thus, whether you choose to create a non-member functor or to pass the
    function pointer and associated argument, the same code will be
    executed.
  </P>

</BODY>
