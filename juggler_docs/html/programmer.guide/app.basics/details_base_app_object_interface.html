<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Base application object interface</title>
</head>

<body>

<h2>Base application object interface</h2>
<table border="0" cellpadding="0" cellspacing="0" width="20">
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td></td>
    <td><img border="0" src="${PROGRAMMERGUIDE}/images/myAppHierarchy-highlightVjApp.gif" width="360" height="505"></td>
    <td><img border="0" src="${PROGRAMMERGUIDE}/images/AppInitAndMainLoop_modified.gif" width="473" height="491"></td>
    <td></td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
</table>
<p>This section gives a brief overview of the member functions from the base VR
Juggler interface.&nbsp; This interface is defined by <tt>vjApp</tt> and the
member functions are shown in the diagram above.</p>
<p>The diagram on the right is a sequence diagram that shows the calling order
of the base interface functions in relation to the entire VR Juggler
system.&nbsp; This will serve as a reference when discussing the order that the
member functions get called in.</p>
<p>The following functions are the main interface functions for the base vjApp
interface.&nbsp; These functions handle initialization and computation.&nbsp;
There are also other members of the interface that can be used for:
reconfiguration, resetting, exiting, and focus control.&nbsp; These will be
covered later in this manual.</p>
<h3><a name="init_funcs">Initialization</a></h3>
<table border="0" cellpadding="0" cellspacing="0" width="774">
  <tr>
    <td colspan="2" width="772">
<h4>vjApp::init()</h4>
    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">The init() method is called by the kernel to initialize any application data.
      &nbsp;When the 

kernel gets ready to startup a new application, it first calls the init() 

method to signal to the application that it is about to be executed.</td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">
<h5>Timing</h5>
    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

    Called immediately after the kernel is told to start running the application
    and before any graphic API handling has been started by VR Juggler.

    </td>
  </tr>
  
  <tr>
    <td width="5%"></td>
    <td width="95%">
<h5>Uses</h5>
    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<p>Loading data files, creating lookup tables.&nbsp; Basically and
pre-processing that the application needs to setup data structures.</p>
    </td>
  </tr>
</table>
<br>
<table border="0" cellpadding="0" cellspacing="0" width="774">
  <tr>
    <td colspan="2" width="772">
<h4>vjApp::apiInit()</h4>
    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">
<p>This function is for graphics API specific initialization. &nbsp;It is used to 

initialize any data members that cannot be initialized until the 

graphics API has been initialized.</p>

<p>NOTE: In OpenGL applications, there is no concept of initializing 

the API, so it is not normally used.</p>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<h5>Timing</h5>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

Called after the graphics API has been started up but before starting the kernel
frame.

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<h5>

Uses</h5>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<p>

Scene graph loading or other API specific initialization.</p>
    </td>
  </tr>
</table>

<h3>

<a name="frame_funcs">

Frame functions</a></h3>

<table border="0" cellpadding="0" cellspacing="0" width="774">
  <tr>
    <td colspan="2" width="772">
<h4>vjApp::preFrame()</h4>
    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

The preFrame() method is called when the system is about to trigger drawing. &nbsp;This is the 

time to do any last minute updates of data based on input 

device status. &nbsp;It is best to avoid doing any time-consuming computation in this method because 

the time use in this method contributes to the overall 

device latency in the system. &nbsp;The devices will not be resampled before rendering begins.

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<h5>Timing</h5>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

Called immediately before triggering rendering of current frame.

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<h5>

Uses</h5>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<p>

Last millisecond updating data in response to device input. (latency critical
code)</p>
    </td>
  </tr>
</table>

<br>

<table border="0" cellpadding="0" cellspacing="0" width="774">
  <tr>
    <td colspan="2" width="772">
<h4>vjApp::intraFrame()</h4>
    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">
The code in this method will be executing in parallel with the rendering method.
This is the method to put any processing that  can be done for the next frame in order to make use of the 
time that is being used for drawing. By putting processing in this method, it can increase frame 
rates because the application can parallelize drawing and computation.
Special care needs to be taken to ensure that the data is buffered to prevent it from changing
while it is being used to render.
    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<h5>Timing</h5>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

Called after rendering has been triggered, but before rendering has necessarily
finished.

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<h5>

Uses</h5>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<p>

Time consuming computation for the next frame.&nbsp; Parallel computation.</p>
    </td>
  </tr>
</table>

<br>

<table border="0" cellpadding="0" cellspacing="0" width="774">
  <tr>
    <td colspan="2" width="772">
<h4>vjApp::postFrame()</h4>
    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

    This is a good place to do any data 

updates that are not dependent upon input devices, but can not be overlapped with the rendering process.

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<h5>Timing</h5>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

    Called after rendering has completed but before VR Juggler updated devices
    and other internal data.

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<h5>

Uses</h5>

    </td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="95%">

<p>

Clean up, sync with external networking or computational processes.

</p>
    </td>
  </tr>
</table>

<!-- Space at bottom so that bookmarks actually jump to top of screen -->
<br><br><br><br><br><br>
<br><br><br><br><br><br>
<br><br><br><br><br><br>
<br><br><br><br><br><br>
<br><br><br><br><br><br>
<br><br><br><br><br><br>


</body>

</html>
