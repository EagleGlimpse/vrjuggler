<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Application Objects Overview</title>
<link rel="stylesheet" type="text/css" href="../../../style/base_style.css">
</head>

<body>

<h1>Application Objects Overview</h1>
<h2>All VR Juggler apps are objects</h2>
<p>In VR Juggler, all applications are objects. &nbsp;VR Juggler uses the 

application object to create the VR environment in which the user interacts. &nbsp;The 

application object implements interfaces needed by the virtual platform to create the virtual environment. &nbsp;(An interface is a collection of operations used 

to specify a service of a class or a component)</p>
<p>The kernel maintains control over the environment 

and calls the methods defined in the application 

interface. &nbsp;When the kernel calls the application's methods it gives up control to the application 

object so the application can execute the code needed to 

create the virtual environment.&nbsp;</p>
<h3>Don't call me, I'll call you</h3>
<p>There is no main() function, instead the VR Juggler kernel controls the
application's processing time by calling the application object's method
functions. &nbsp;Since VR Juggler applications are objects, developers do not write a main() function. &nbsp;Instead, developers create an application object that implement a set of pre-defined interfaces.</p>

<p>
In common programs, the main function signals the point where the thread of control enters the application.
After the main function is called, the application starts performing any application processing necessary. 
When the OS starts the program, it gives the main function some processing time.
After the process's quantum expires, the operating system switches to another process.</p>

<p>

In VR Juggler, we accomplish the same functionality. &nbsp;The kernel is the scheduler, and it allocates processing time to an application by 
invoking the methods of the application object. &nbsp;Because the kernel has additional information 
about the resources needed by the applications, it maintains a very strict scheduling about when the application is granted processing 
time. This is the basis to maintain coherence across each execution frame.</p>

<p>

Application objects can exist either linked in with the kernel startup code or alone as a dynamically 
loadable object.</p>

<img border="0" src="../images/VP_APP_sepLine.gif" width="231" height="226">
<p>&nbsp;</p>
<h3>Derive from gfx API base class</h3>
<p>This allows for dynamic binding at run-time.</p>
<p>Override methods of the base interfaces.</p>
<p>The first step in defining an application object is to derive from the base classes that define the 

kernel and draw manager interfaces the 

application needs to implement. &nbsp;There is a base class for the interface that the kernel expects 

and a base class for each draw manager 

interface (see the figure)</p>

<p><img border="0" src="../images/vj_app_hier_small.gif"></p>

<p>

The kernel interface specifies methods for initialization, shutdown, and to give the application processing 

time.</p>

<p>

The draw manager interface for this application specifies the functions that are necessary to render 

and OpenGL application. &nbsp;The interface 

has functions for drawing the scene and for initializing context-specific information.</p>

<p>

The system expects all applications to implement this set of methods that the kernel uses to interact 

with the application.</p>

<h3>Why are they application objects (what are the benefits)?</h3>

<p>The most common approach for VR application development is to have the application define the main function 

and have the application 

call library functions when needed. &nbsp;The library in this model only executes code when requested 

to do so by the application because the 

application is in control of the main thread of execution. This model makes the application developer 

responsible to coordinate the execution 

of the different components of the VR system and, therefore, responsible to create efficient, complex 

applications.</p>

<h4>Allow flexibility for run-time changes</h4>

<p>VR Juggler, being a virtual platform, does not use this model because it needs to maintain control over 

the different components to provide the 

flexibility needed to make changes to the virtual platform at run-time.</p>

<p>

By being in control of the execution, the kernel always knows the current state of the applications, 

therefore it can safely manage the run-time reconfigurations of the virtual environment. Under this 

model, nearly every parameter to configure the execution environment can be 

changed at run time. &nbsp;It is possible to switch applications, start new devices, reconfigure devices, 

and send reconfiguration information to the 

application object. &nbsp;</p>

<h4>Low coupling</h4>

<p>

Application objects lead to a robust architecture as a result of low coupling and well defined inter-object 

dependencies. &nbsp;The application interface defines 

the only communication path between the application and the virtual platform. By restricting interactions 

to the interfaces of the kernel, draw manager, 

and application, the system restricts object inter-dependencies to those few interfaces. &nbsp;This 

decreased coupling allows changes in the system to stay 

local. &nbsp;Changes to one object will not affect another unless the change involves a change of the 

interface of one of the objects. &nbsp;This leads to more robust 

and extendable code.</p>

<p>Because the application is simply an object, it is possible to dynamically load and unload applications 

at run-time. &nbsp;When the virtual 

platform starts up, it waits for an application to be passed to it. When the application is given to 

the VR Juggler kernel at run-time, the kernel 

performs a few initialization steps, and then executes the application.</p>

<h4>Allows implementation changes</h4>

<p>

Since applications use a distinct interface to communicate with the virtual platform, changes to the 

implementation of the virtual platform 

do not affect the application. &nbsp;This makes it simple to make significant changes to the implementation 

of the virtual platform without affecting 

any applications that currently run on the platform. &nbsp;These changes could include bug fixes, performance 

tuning, new device support, or any 

number of other changes.</p>

<p>

We believe that this ability to modify the system's behavior at run-time is one of the major strengths 

of VR Juggler.</p>

<h4>&nbsp;</h4>

<h2>Fill in the blank...</h2>

<h3>Fill in the method implementation</h3>
<h3>Users provide implementation for the 

things they want</h3>
<h3>Defaults if not impl provided</h3>

</body>

</html>
