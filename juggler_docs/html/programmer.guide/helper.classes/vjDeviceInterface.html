<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HEAD>
<TITLE>vjDeviceInterface Helper Class</TITLE>
</HEAD>

<BODY>

<H2>The <TT>vjDeviceInterface</TT> Helper Class</H2>

<!-- install-web toc-begin -->
<H3>Table of Contents</H3>

  <OL>
    <LI>
      <A HREF="#intro">Introduction</A>
    </LI>
    <LI>
      <A HREF="#high-level">High-Level Description</A>
    </LI>
    <LI>
      <A HREF="#use">Using <TT>vjDeviceInterface</TT></A>
    </LI>
    <LI>
      <A HREF="#details">The Gory Details</A>
    </LI>
  </OL>
<!-- install-web toc-end -->

<H3><A NAME="intro">Introduction</A></H3>

  <P>
    There is an interface beyond that which is known to man.  It is an
    interface as vast as space and as timeless as infinity.  It is the
    middle ground between light and shadow, between science and
    superstition, and it lies between the pit of man's fears and the
    summit of his knowledge.  This is the interface of imagination.  It
    is a class which we call... <TT>vjDeviceInterface</TT>!
  </P>

<H3><A NAME="high-level">High-Level Description</A></H3>

  <P>
    The class <TT>vjDeviceInterface</TT> is designed to be a wrapper
    class.  It provides an easy way to access VR Juggler
    <A HREF="${GLOSSARY}#proxy">proxy</A> objects from within user
    applications.  A local interface variable in a user's application
    class is used as a <A HREF="${GLOSSARY}#smart_pointer">smart pointer</A>
    to the proxy.
  </P>

  <P>
    So what does this mean?  Well, what it comes down to is that
    <TT>vjDeviceInterface</TT> is a base class for other device interface
    classes such as digital interfaces (wand buttons), position interfaces
    (wands, a user's head), etc.  In your code, you will make instances of
    objects such as <TT>vjDigitalInterface</TT>, <TT>vjPosInterface</TT>,
    <TT>vjKeyboardInterface</TT> and the like.  Once they are properly
    initialized, your device interface objects (whatever their types may
    be) will act as smart pointers to the actual VR Juggler proxy objects
    they are wrapping.
  </P>

  <P>
    Are you ready to run away screaming yet?  Don't fret, faithful
    reader, it really isn't that bad.  All the subclasses of
    <TT>vjDeviceInterface</TT> encapsulate a pointer to a VR Juggler proxy
    object.  They also overload the dereference operator <TT>-&gt;</TT>
    which helps them act as smart pointers.  What this means is that when
    you have a device interface object and use the dereference operator
    on it, the class has logic built in to give you access to its hidden
    proxy pointer.  Once you have that access, you can invoke the methods
    of the proxy object, usually to read data.
  </P>

  <P>
    Okay, that doesn't sound so nasty, does it?  But you're probably
    wondering why the heck we have implemented this concept that requires
    all sorts of documentation and explanation.  Well, we think it's worth
    it because it allows VR Juggler to hide the actual type of the device
    you are using.  You don't need to know that you're dealing with a
    wireless mouse connected to a PC reading bytes from a PS/2 port that
    represent button presses.  All you care about is knowing which buttons
    are pressed at a given instant.  <TT>vjDigialInterface</TT> gives you
    exactly that information, and it keeps the messiness of dealing with
    that crazy mouse, its ugly driver and its overly complex protocol
    far, far away.  All of this so you can sit back, relax, have some
    lemonade and read button presses to your heart's content.
  </P>

<H3><A NAME="use">Using <TT>vjDeviceInterface</TT></A></H3>

  <P>
    Okay, that's not really accurate.  You will be using subclasses of
    <TT>vjDeviceInterface</TT>, but since they are subclasses, they are
    all of type <TT>vjDeviceInterface</TT> as well.  Isn't object-oriented
    programming great?  To simplify things a little, this section will
    refer to subclasses of <TT>vjDeviceInterface</TT> as ``device
    interfaces''.
  </P>

  <P>
    As mentioned in the previous section, before you can use a device
    interface, you must of course declare one.  Choose the type that is
    appropriate for the type of device whose data you want to read.  All
    your device interface objects must be initialized in your application
    object's <TT>init()</TT> method.  Each device interface object
    inherits a method called <TT>init()</TT> from <TT>vjDeviceInterface</TT>.
    This method takes a single string argument naming the proxy to which
    the interface will connect.  Example names are ``VJHead'', ``VJWand'',
    and ``VJButton0''.  These are all symbolic names you specify in your
    configuration files.  This makes it easier to remember, and it also
    contributes to hiding the details about the physical device.  Who
    cares how transformation information from the user's head is
    generated?  VR Juggler cares, but there is no need for it to tell you.
    All you care about is that transformation matrix.  An example of
    initializing a <TT>vjPosInterface</TT> that connects with the user
    head proxy is:

<PRE>
    vjPosInterface head;

    head.init("VJHead");
</PRE>

    Remember that this is to be done in your application object's
    <TT>init()</TT> method and the actual variable would be a member
    variable of that class.  Note that here, you use the normal syntax
    for calling the method of a C++ object rather than using the
    dereference operator.  Until it is initialized, the device interface
    object cannot act as a smart pointer.
  </P>

  <P>
    Now that you have your device interface objects all initialized and
    ready to use, it's time to start using them as smart pointers.  This
    is what you've been waiting for!  VR Juggler is already working hard
    in the background to update your device proxies, and you are free to
    access them.  (It's usually best to reference them in the
    <TT>preFrame()</TT> method, but this may not necessarily be true for
    all proxies.)  Continuing with our example of a <TT>vjPosInterface</TT>
    to the user head proxy, the following code shows how to read the
    transformation matrix for the user's head:

<PRE>
    vjMatrix* head_mat;

    head_mat = head-&gt;getData();
</PRE>

    Wait a second!  That was easy!  Maybe you should rub your eyes and
    read that code snippet again.  Try pinching yourself, too.  The code
    really is that simple.  You use the overloaded dereference operator to
    get access to the position proxy object hidden in
    <TT>vjPosInterface</TT>, and you read data from it.  Of course, we
    haven't told you about the <TT>getData()</TT> method at all at this
    point.  That comes from the position proxy class, and that is
    documented
    <A HREF="${PROGRAMMERGUIDE}/helper.classes/vjProxy.html">elsewhere</A>.
  </P>

  <P>
    All right, take a second to catch your breath and slow your heart
    rate.  This is exciting stuff, and you shouldn't over exert yourself.
    You're probably wondering what else you can do with these amazing
    device interfaces.  Well, nothing really.  As mentioned earlier, the
    device interface classes are just wrappers.  They have next to no
    methods.  You can read the proxy name using the <TT>getProxName()</TT>
    method, and you can get the proxy index using the
    <TT>getProxyIndex()</TT> method.  Don't worry, though, we didn't get
    you all worked up just to leave you hanging.  The next document talks
    about those
    <A HREF="${PROGRAMMERGUIDE}/helper.classes/vjProxy.html">ubiquitous
    proxies</A> you have heard so much about.  Remember, the device
    interfaces give you full access to the proxies through that great
    dereference operator, so operations in the proxies are available to
    device interfaces through it.
  </P>

<H3><A NAME="details">The Gory Details</A></H3>

  <P>
    What is truly amazing about VR Juggler device interfaces is,
    despite their seeming complexity, there is really nothing to them.
    Trying to trace through the code in the source is a little tricky,
    but conceptually, it's all about pointers.  Keep in mind that all
    this documentation is written using nothing more than the
    <I>headers</I> as a reference.
  </P>

  <P>
    As mentioned, the class <TT>vjDeviceInterface</TT> is a base class
    for all the specific types of device interfaces such as positional
    interfaces, digital interfaces, and analog interfaces.  This class
    maintains the name of the proxy and the proxy index, and it provides
    the all-important <TT>init()</TT> method, but it is up to the
    inheriting classes to handle the proxy pointer and overloading the
    dereference operator.
  </P>

  <P>
    Subclasses of <TT>vjDeviceInterface</TT> are used to provide the
    wrapper to a specific type of proxy.  They each contain a pointer to
    a proxy object of the same conceptual type (positional, digital, and
    so on).  The way in which the dereference operator is overloaded can
    vary from class to class, but the end result is always the same.  A
    pointer to the proxy is returned so that the calling code has access
    to that proxy.
  </P>

  <P>
    The beauty of it all is that the proxy object being pointed to by
    the device interface can be changed without affecting the
    <I>execution</I> of the user application.  In other words, the proxies
    can be changed at run time to point to different physical devices.
    All the while, the user code is still using the smart pointer
    interface and getting data of some sort back.  Isn't it cool?
  </P>

</BODY>
