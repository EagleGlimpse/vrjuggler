<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HEAD>
<TITLE>vjVec3 and vjVec4 Helper Classes</TITLE>
</HEAD>

<BODY>

<H2>The <TT>vjVec3</TT> and <TT>vjVec4</TT> Helper Classes</H2>

<H3>Table of Contents</H3>

  <OL>
    <LI>
      <A HREF="#intro">Introduction</A>
    </LI>
    <LI>
      <A HREF="#high-level">High-Level Description</A>
    </LI>
    <LI>
      <A HREF="#use">Using <TT>vjVec3</TT> and <TT>vjVec4</TT></A>
    </LI>
    <LI>
      <A HREF="#details">The Gory Details</A>
    </LI>
  </OL>

<A NAME="intro"><H4>Introduction</H4></A>

  <P>
    This document is intended to provide an introduction into how the
    helper classes <TT>vjVec3</TT> and <TT>vjVec4</TT> work and how they
    can be used in your VR Juggler applications.  It begins with a
    high-level description of the classes which forms the necessary basis
    for understanding them in detail.  Then, examples of how to use all
    the available operations in the interfaces for these classes are
    provided.  It concludes with a description of the internal details of
    the classes.
  </P>

<A NAME="high-level"><H4>High-Level Description</H4></A>

  <P>
    The classes <TT>vjVec3</TT> and <TT>vjVec4</TT> are designed to work
    the same was as three- and four-dimensional mathematical
    <A HREF="${GLOSSARY}#vector">vectors</A>.  That is, a <TT>vjVec3</TT>
    object can be thought of as a vector of the form
    &lt;<I>x</I>,&nbsp;<I>y</I>,&nbsp;<I>z</I>&gt;.  Similarly, a
    <TT>vjVec4</TT> can be thought of as a vector of the form
    &lt;<I>x</I>,&nbsp;<I>y</I>,&nbsp;<I>z</I>,&nbsp;<I>w</I>&gt;.  If you
    understand mathematical vectors, then you already know how these classes
    can be used.  The question then becomes, how are they used?  We will get
    to that <A HREF="#use">later</A>, and you can skip ahead if you already
    understand such vectors.  If vectors are an unfamiliar topic, you can
    also think of these classes as three- and four-element C++ arrays of
    <TT>float</TT>s respectively, but most benefits of the vector concept
    are lost with that simpler idea.  Therefore, if you need to think of
    them as arrays, you should probably just use arrays until you feel
    more comfortable with vectors.  Once you do, you are encouraged to come
    back and read further.
  </P>

  <P>
    Vectors typically are used to contain spatial data or something
    similar, but they can be visualized as a more general-purpose container
    for numerical data upon which well-defined operations can be performed.
    Do not constrain yourself to thinking of them as only holding the
    coordinates for some point in space or some other limited-scope use.
    VR Juggler's vectors retain this generality and can be used wherever
    vectors come in handy.

  <P>
    <TT>vjVec3</TT> and <TT>vjVec4</TT>, as specific implementations of
    mathematical vectors, hide vector operations on single-precision
    floating-point numbers (<TT>float</TT>s) behind a simple-to-use
    interface.  For a single vector, the following standard vector
    operations are available:

    <UL>
      <LI>
	Inversion (changing the sign of all elements)
      </LI>
      <LI>
	Normalization
      </LI>
      <LI>
	Length calculation
      </LI>
      <LI>
	Multiplication by a scalar
      </LI>
      <LI>
	Division by a scalar
      </LI>
      <LI>
	Conversion to a Performer vector
      </LI>
    </UL>

    For two vectors, the following operations can be performed:

    <UL>
      <LI>
	Assignment
      </LI>
      <LI>
	Equality/inequality comparison
      </LI>
      <LI>
	Dot product
      </LI>
      <LI>
	Cross product (<TT>vjVec3</TT> only)
      </LI>
      <LI>
	Addition
      </LI>
      <LI>
	Subtraction
      </LI>
    </UL>

    Knowing this and keeping in mind that <TT>vjVec3</TT> and <TT>vjVec4</TT>
    can be thought of at this high level, using them should be a snap.
  </P>

<A NAME="use"><H4>Using <TT>vjVec3</TT> and <TT>vjVec4</TT></H4></A>

  <P>
    Now that you are familiar with these classes as standard mathematical
    vectors, it's time to learn how to deal with them at the C++ level.
    In some cases, the mathematical operators are overloaded to simplify
    your code, and in other cases, a named method must be invoked on your
    object.  Before any of that, however, make sure that your source file
    includes either <TT>Math/vjVec3.h</TT>, <TT>Math/vjVec4.h</TT> or
    both as necessary.  From here on, the available operations are
    presented in the order they were listed in the previous section.
    We begin with creating the objects and setting their values.
  </P>

<A NAME="inversion"><H5>Creating Vectors and Setting Their Values</H5></A>

  <P>
    Before you can do anything with vectors, you will need to create
    some first.  The examples here will use <TT>vjVec3</TT>s, but the
    example is equally applicable to <TT>vjVec4</TT>.  To create a
    <TT>vjVec3</TT>, you can use the default which initializes the vector
    to &lt;0.0,&nbsp;0.0,&nbsp;0.0&gt;:

<PRE>
    vjVec3 vec1;
</PRE>

    After creating this vector <TT>vec1</TT>, you can assign its elements
    values all at once as follows:

<PRE>
    vec1.set(1.0, 1.5, -1.0);
</PRE>

    or individually:

<PRE>
    vec1[0] = 1.0;
    vec1[1] = 1.5;
    vec1[2] = -1.0;
</PRE>

    Note that in the last example, you can access the individual elements
    of the vector exactly as you would with a normal array.  If you want
    to do all of the above steps at once when the vector is created, give
    the element values when you declare your vector:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0);
</PRE>

    All of the above code has exactly the same results but accomplishes them
    in different ways.  This flexibility is just one of the ways that
    VR Juggler vectors are more powerful than C++ arrays (of the same size
    of course).
  </P>

<A NAME="inversion"><H5>Inversion (Finding the Negative of a Vector)</H5></A>

  <P>
    Once you have your vector created, the simplest operation you can
    perform on it is to find the negative of it.  The following code
    demonstrates doing just that:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2;

    vec2 = -vec1;
</PRE>

    The vector <TT>vec2</TT> now has the value
    &lt;-1.0,&nbsp;-1.5,&nbsp;1.0&gt;.  That's all there is to it.  (If you
    are already interested in details, it is important to note that the
    above does a copy operation to return the negatives.)
  </P>

<A NAME="normalization"><H5>Normalization</H5></A>

  <P>
    Normalizing a vector is another simple operation (at the interface
    level anyway).  The following code normalizes a vector:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0);

    vec1.normalize();
</PRE>

    <TT>vec1</TT> is now normalized.  Whee, this is fun!
  </P>

  <P>
    Besides being able to normalize a given vector, you can also test to
    see if a vector is already normalized.  This is done as follows
    (assuming the vector <TT>vec</TT> has been declared before this point):

<PRE>
    if ( vec.isNormalized() ) {
        // Go here if vec is normalized
    }
</PRE>

    This only works with <TT>vjVec3</TT>s, though.
  </P>

<A NAME="length"><H5>Length Calculation</H5></A>

  <P>
    Part of normalizing a vector requires finding its length first.  To
    get a vector's length, do the following:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0);
    float length;

    length = vec1.length();
</PRE>

    In this case, length is assigned the value 2.061553 (or more accurately,
    the square root of 4.25).  Finding the length of a vector appears
    simple from the programmer's perspective, but it has some hidden
    nastiness.  Namely, it requires a square root calculation.  For
    optimization purposes, the <TT>vjVec3</TT> class (but not <TT>vjVec4</TT>)
    provides a method called <TT>lengthSquared()</TT> that returns the
    length of the vector without calculating the square root.
  </P>

<A NAME="scalar_mult"><H5>Multiplication by a Scalar</H5></A>

  <P>
    The VR Juggler vector classes provide an easy way to multiply a
    vector by a scalar.  There are several ways to do it depending on
    what you want.  Examples of each method follow.
  </P>

  <P>
    To multiply a vector by a scalar and store the result in another
    vector, do the following:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2;

    vec2 = 3 * vec1;
</PRE>

    (You can swap the order of the factors in the multiplication if you
    like.)  Here, <TT>vec2</TT> gets the value
    &lt;3.0,&nbsp;4.5,&nbsp;-3.0&gt;.
  </P>

  <P>
    To multiply a vector by a scalar and store the result in the same
    vector, do the following:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0);

    vec1 *= 3;
</PRE>

    After this, <TT>vec1</TT> has the value &lt;3.0,&nbsp;4.5,&nbsp;-3.0&gt;.
  </P>

<A NAME="scalar_div"><H5>Division by a Scalar</H5></A>

  <P>
    Very similar to multiplying by a scalar, division by scalars is also
    possible.  While the examples are almost identical, they are provided
    here for clarity.
  </P>

  <P>
    To divide a vector by a scalar and store the result in another
    vector, do the following:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2;

    vec2 = vec1 / 3;
</PRE>

    Here, <TT>vec2</TT> gets the value
    &lt;0.333333,&nbsp;0.5,&nbsp;-0.333333&gt;.  Note that the scalar must
    come after the vector because the operation would not make sense
    otherwise.
  </P>

  <P>
    To multiply a vector by a scalar and store the result in the same
    vector, do the following:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0);

    vec1 /= 3;
</PRE>

    After this, <TT>vec1</TT> has the value
    &lt;0.333333,&nbsp;0.5,&nbsp;-0.333333&gt;.
  </P>

<A NAME="pfVec3"><H5>Converting to a Performer Vector</H5></A>

  <P>
    SGI's OpenGL Performer likes to work with its own <TT>pfVec3</TT>
    class, and to facilitate the use of it with <TT>vjVec3</TT>, two
    conversion functions are provided for converting a <TT>vjVec3</TT>
    to a <TT>pfVec3</TT> and vice versa.  The first works as follows:

<PRE>
    vjVec3 vj_vec;
    pfVec3 pf_vec;

    // Do stuff to vj_vec...

    pf_vec = vjGetPfVec3(vj_vec);
</PRE>

    where <TT>vj_vec</TT> is passed by reference for efficiency.
    (<TT>pf_vec</TT> gets a copy of a <TT>pfVec3</TT>.) To convert a
    <TT>pfVec3</TT> to a <TT>vjVec3</TT>, do the following:

<PRE>
    pfVec3 pf_vec;
    vjVec3 vj_vec;

    // Do stuff to pf_vec...

    vj_vec = vjGetVjVec3(pf_vec);
</PRE>

    Here again, <TT>pf_vec</TT> is passed by reference for efficiency
    and <TT>vj_vec</TT> gets a copy of a <TT>vjVec3</TT>.  Both of these
    functions are found in the header <TT>Kernel/Pf/vjPfUtil.h</TT>.
  </P>

<A NAME="assign"><H5>Assignment</H5></A>

  <P>
    You have already seen vector assignment in action above whether you
    realized it or not.  It works just as vector assignment in mathematics,
    so you may have missed it.  The C++ code for doing it is as follows:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2;

    vec2 = vec1;
</PRE>

    After the assignment, <TT>vec2</TT> has the value
    &lt;-1.0,&nbsp;-1.5,&nbsp;1.0&gt;.  Ta da!  Note that this is a
    copy operation which is the case for all types of assignments of
    VR Juggler vectors.
  </P>

<A NAME="equality"><H5>Equality/Inequality Comparison</H5></A>

  <P>
    To compare the equality of two vectors, you have three available
    methods (one is just the complement of the other, though):

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

    if ( vec1.equal(vec2) ) {
        // Go here if vec1 and vec2 are equal.
    }
</PRE>

    or

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

    if ( vec1 == vec2 ) {
        // Go here if vec1 and vec2 are equal.
    }
</PRE>

    or

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

    if ( vec1 != vec2 ) {
        // Go here if vec1 and vec2 are <I>not</I> equal.
    }
</PRE>

    You can use whichever method is most convenient for your needs.
  </P>

<A NAME="dot"><H5>Dot Product</H5></A>

  <P>
    Given two vectors, finding the dot product is often needed.  VR
    Juggler's vectors give you a way to do this quickly so you can save
    yourself the time of typing in the formula over and over.  It works
    as follows:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);
    float dot_product;

    dot_product = vec1.dot(vec2);
</PRE>

    Now, <TT>dot_product</TT> has the value 4.0.
  </P>

<A NAME="cross"><H5>Cross Product (<TT>vjVec3</TT> only)</H5></A>

  <P>
    Besides the dot product of two vectors, the cross product is another
    commonly needed result.  It is calculated thusly:

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

    vec3 = vec1.cross(vec2);
</PRE>

    The result is that <TT>vec3</TT> gets a copy of <TT>vec1</TT> cross
    <TT>vec2</TT>.
  </P>

<A NAME="addition"><H5>Addition</H5></A>

  <P>
    Adding two vectors can be done one of two ways.  The first method
    returns a resulting vector, and the second method performs the
    addition and stores the result in the first vector.

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

    vec3 = vec1 + vec2;
</PRE>

    Now, <TT>vec3</TT> has the value &lt;2.5,&nbsp;2.5,&nbsp;-2.0&gt;.

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

    vec1 += vec2;
</PRE>

    Now, <TT>vec1</TT> has the value &lt;2.5,&nbsp;2.5,&nbsp;-2.0&gt;.
  </P>

<A NAME="subtraction"><H5>Subtraction</H5></A>

  <P>
    Subtracting two vectors gives the same options as addition, and while
    the code is nearly identical, it is provided for the sake of clarity.

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

    vec3 = vec1 - vec2;
</PRE>

    Now, <TT>vec3</TT> has the value &lt;-0.5,&nbsp;0.5,&nbsp;0.0&gt;.

<PRE>
    vjVec3 vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

    vec1 -= vec2;
</PRE>

    Now, <TT>vec1</TT> has the value &lt;-0.5,&nbsp;0.5,&nbsp;0.0&gt;.
  </P>

<A NAME="details"><H4>The Gory Details</H4></A>

  <P>
    The details behind <TT>vjVec3</TT> and <TT>vjVec4</TT> really aren't
    all that gory.  Internally, they are represented as three- and
    four-element arrays of <TT>float</TT>s respectively.  Access to these
    arrays is provided through the public member variable <TT>vec</TT>.
    For example, you can use this access in the following way:

<PRE>
    vjVec3 pos(4.0, 1.0982, 10.1241);

    glVertex3fv(pos.vec);
</PRE>

    Yes, this particular example is rather silly and much slower than
    just listing the values as the individual arguments to
    <TT>glVertex3f</TT>(), but it should get the point across.
  </P>

  <P>
    In general, the <TT>vec</TT> member variable should be treated very
    carefully.  Access to it is provided mainly so that operations similar
    to this example can be performed quickly.  An example of an abuse of
    access to <TT>vec</TT> is the following:

<PRE>
    vjVec4 my_vec;

    my_vec.vec[0] = 4.0;
    my_vec.vec[1] = 1.0982;
    my_vec.vec[2] = 10.1241;
    my_vec.vec[3] = 1.0;
</PRE>

    Don't do this.  It can be confusing to readers of your code who do
    not necessarily need to know the details of the internal representation.
    Instead, use one of the methods described above for creating vectors
    and assigning the elements values.
  </P>

</BODY>
