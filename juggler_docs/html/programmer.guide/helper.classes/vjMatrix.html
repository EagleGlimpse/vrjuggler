<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HEAD>
<TITLE>vjMatrix Helper Class</TITLE>
</HEAD>

<BODY>

<H2>The <TT>vjMatrix</TT> Helper Class</H2>

<H3>Table of Contents</H3>

  <OL>
    <LI>
      <A HREF="#intro">Introduction</A>
    </LI>
    <LI>
     <A HREF="#high-level">High-Level Description</A>
    </LI>
    <LI>
      <A HREF="#use">Using <TT>vjMatrix</TT></A>
      <OL TYPE="i">
	<LI>
	  <A HREF="#creating">Creating Matrices and Setting Their Values</A>
	</LI>
	<LI>
	  <A HREF="#assignment">Assignment</A>
	</LI>
	<LI>
	  <A HREF="#equality">Equality/Inequality Comparison</A>
	</LI>
	<LI>
	  <A HREF="#transpose">Transposing</A>
	</LI>
	<LI>
	  <A HREF="#invert">Finding the Inverse</A>
	</LI>
	<LI>
	  <A HREF="#add">Addition</A>
	</LI>
	<LI>
	  <A HREF="#sub">Subtraction</A>
	</LI>
	<LI>
	  <A HREF="#mult">Multiplication</A>
	</LI>
	<LI>
	  <A HREF="#scale">Scaling by a Scalar Value</A>
	</LI>
	<LI>
	  <A HREF="#makeIdent">Creating an Identity Matrix Quickly</A>
	</LI>
	<LI>
	  <A HREF="#zero">Zeroing a Matrix in a Single Step</A>
	</LI>
	<LI>
	  <A HREF="#euler">Creating an XYZ, a ZYX or a ZXY Euler Rotation
	  Matrix</A>
	</LI>
	<LI>
	  <A HREF="#constrain">Constraining Rotation About a Specific Axis or
	  Axes Matrix</A>
	</LI>
	<LI>
	  <A HREF="#dircos">Making a Matrix Using Direction Cosines</A>
	</LI>
	<LI>
	  <A HREF="#makeQuat">Making a Matrix from a Quaternion</A>
	</LI>
	<LI>
	  <A HREF="#makeRot">Making a Rotation Transformation Matrix About a
	  Single Axis</A>
	</LI>
	<LI>
	  <A HREF="#makeTrans">Making a Translation Transformation Matrix</A>
	</LI>
	<LI>
	  <A HREF="#makeScale">Making a Scale Transformation Matrix</A>
	</LI>
	<LI>
	  <A HREF="#extract">Extracting Specific Transformation Information</A>
	</LI>
	<LI>
	  <A HREF="#pfMatrix">Converting to a Performer Matrix</A>
	</LI>
      </OL>
    </LI>
    <LI>
      <A HREF="#details">The Gory Details</A>
    </LI>
  </OL>

<A NAME="intro"><H4>Introduction</H4></A>

  <P>
    This document is intended to provide an introduction into how the
    helper class <TT>vjMatrix</TT> works and how it can be used in your VR
    VR Juggler applications.  It begins with a high-level description of
    the class which forms the necessary basis for understanding it in
    detail.  Then, examples of how to use all the available operations in
    the interfaces for the class are provided.  It concludes with a
    description of the internal C++ details of <TT>vjMatrix</TT>.
  </P>

<A NAME="high-level"><H4>High-Level Description</H4></A>

  <P>
    Abstractly, <TT>vjMatrix</TT> represents a 4x4
    <A HREF="${GLOSSARY}#matrix">matrix</A> of single-precision
    floating-point values and defines implements of the standard matrix
    manipulation operations such as transpose, scale and multiply.  More
    specifically, it is a mechanism to facilitate common matrix operations
    used in computer graphics, especially those associated with a transform
    matrix.  On the surface, it is nearly identical to a 4x4 C++ array of
    <TT>float</TT>s, but there is one large difference: a <TT>vjMatrix</TT>
    keeps its internal matrix in column-major order rather than in row-major
    order.  More detail on this is given <A HREF="#details">below</A>, but
    this is done because OpenGL maintains its internal matrices using the
    same memory layout.  At the conceptual level, this does not matter--it
    is related only to their representation in the computer's memory, and
    access to the elements is still in row-major order.  In any case, if you
    know how C++ multidimensional arrays work, you already understand 90%
    of what there is to know about <TT>vjMatrix</TT>.  The class provides a
    degree convenience not found with a normal C++ array, especially when
    doing OpenGL programming.  The complications surrounding the
    <TT>vjMatrix</TT> class are identical to those with OpenGL matrix
    handling, and if you understand that, then all you need to know is
    <A HREF="#use">how to use a <TT>vjMatrix</TT></A>.
  </P>

  <P>
    As a representation of mathematical matrices, <TT>vjMatrix</TT>
    implements several common operations performed on matrices to relieve
    the users of the class of some tedious, repetitive effort.  The
    general mathematical operations are:

    <UL>
      <LI>
	Assignment
      </LI>
      <LI>
	Equality/inequality comparison
      </LI>
      <LI>
	Transposing
      </LI>
      <LI>
	Finding the inverse
      </LI>
      <LI>
	Addition
      </LI>
      <LI>
	Subtraction
      </LI>
      <LI>
	Multiplication
      </LI>
      <LI>
	Scaling by a scalar value
      </LI>
    </UL>

    The operations well-suited for use with computer graphics are:

    <UL>
      <LI>
	Creating an identity matrix quickly
      </LI>
      <LI>
	Zeroing a matrix in a single step
      </LI>
      <LI>
	Creating an XYZ, a ZYX or a ZXY Euler rotation matrix
      </LI>
      <LI>
	Constraining rotation about a specific axis or axes
      </LI>
      <LI>
	Making a matrix using direction cosines
      </LI>
      <LI>
	Making a matrix from a <A HREF="${GLOSSARY}#quaternion">quaternion</A>
      </LI>
      <LI>
	Making a rotation transformation matrix about a single axis
      </LI>
      <LI>
	Making a translation transformation matrix
      </LI>
      <LI>
	Making a scale transformation matrix
      </LI>
      <LI>
	Extracting specific transformation information
      </LI>
      <LI>
	Converting to a Performer matrix
      </LI>
    </UL>
  </P>

  <P>
    What is presented here involves some complicated concepts that are
    far beyond the scope of this documentation.  Without an understanding
    of matrix math (linear algebra) and of how transformation matrices work
    in OpenGL, this document will not be very useful.  It is highly
    recommended that you be familiar with these topics before proceeding.
    Otherwise, with this high-level description in mind, you can now
    continue on to learn about the <TT>vjMatrix</TT> class at the C++ level.
  </P>

<A NAME="use"><H4>Using <TT>vjMatrix</TT></H4></A>

  <P>
    Keeping the idea of a normal mathematical matrix in mind, you are now
    ready to look at the C++ use of the <TT>vjMatrix</TT> class.  Most of
    the interface is defined using methods, but there are a scant few cases
    where mathematical operators have been overloaded to make your code
    easier to read.  Before going any further, whenever you use a
    <TT>vjMatrix</TT> in your code, make sure to include
    <TT>Math/vjMatrix.h</TT> first.  The operations presented above are
    now described in detail in the order in which they were first listed.
    We begin with creating the objects and setting their values.
  </P>

<A NAME="creating"><H5>Creating Matrices and Setting Their Values</H5></A>

  <P>
    Before you can do anything with matrices, you will need to create some
    first.  To create a <TT>vjMatrix</TT>, you can use the default which
    initializes the matrix to be an identity matrix:

<PRE>
    vjMatrix mat1;
</PRE>

    After creating this matrix <TT>mat1</TT>, you can assign its 16 elements
    values all at once as follows:

<PRE>
    mat1.set(0.0, 1.0, 2.3, 4.1,
             8.3, 9.0, 2.2, 1.0,
             5.6, 9.9, 9.7, 8.2,
             3.8, 0.9, 2.1, 0.1);
</PRE>

    or with a <TT>float</TT> array:

<PRE>
    float mat_vals[16] = {
        0.0, 8.3, 5.6, 3.8,
        1.0, 9.0, 9.9, 0.9,
        2.3, 2.2, 9.7, 2.1,
        4.1, 1.0, 1.0, 0.1
    };

    mat1.set(mat_vals);
</PRE>

    Note that when using the explicit listing of values to <TT>set()</TT>,
    they are specified in row-major order.  When put into a 16-element
    array of <TT>float</TT>, however, they must be ordered so that they
    can be <I>copied</I> into the <TT>vjMatrix</TT> in column-major order.
    This is the one exception in the interface where access is
    column-major (which probably means that the interface has a bug in it).
    To set all the values in one step, they can be given as arguments when
    you declare the matrix:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1,
                  8.3, 9.0, 2.2, 1.0,
                  5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
</PRE>

    All of the above code has exactly the same results but accomplishes
    those results in different ways.
  </P>

  <P>
    To read the elements in a <TT>vjMatrix</TT> object, you can use
    either the overloaded <TT>[]</TT> operator or the overloaded <TT>()</TT>
    operator.  The overloaded <TT>[]</TT> operator returns the specified
    row of the <TT>vjMatrix</TT>, and an element in that row can then be
    read using <TT>[]</TT> again.  The code looks exactly the same as with
    a normal C++ two-dimensional array:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    float val;

    val = mat1[3][0];
</PRE>

    Here, <TT>val</TT> is assigned the value 3.8.  Using the overloaded
    <TT>()</TT> operator results in code that looks similar to the way
    the matrix element would be referenced in mathematics:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    float val;

    val = mat1(3, 0);
</PRE>

    Again, <TT>val</TT> is assigned the value 3.8.  Both of these operations
    are row-major.
  </P>

<A NAME="assignment"><H5>Assignment</H5></A>

  <P>
    Assigning one <TT>vjMatrix</TT> to another happens using the normal
    <TT>=</TT> operator as follows:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2;

    mat2 = mat1;
</PRE>

    This makes a <I>copy</I> of <TT>mat1</TT> in <TT>mat2</TT> which can
    be a slow operation.
  </P>

<A NAME="equality"><H5>Equality/Inequality Comparison</H5></A>

  <P>
    To compare the equality of two matrices, you have three available
    methods (one is just the complement of the other, though):

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    if ( mat1.equal(mat2) ) {
        // Go here if mat1 and mat2 are equal.
    }
</PRE>

    or

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    if ( mat1 == mat2 ) {
        // Go here if mat1 and mat2 are equal.
    }
</PRE>

    or

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    if ( mat1 != mat2 ) {
        // Go here if mat1 and mat2 are <I>not</I> equal.
    }
</PRE>

    You can use whichever method is most convenient for your needs.
  </P>

<A NAME="transpose"><H5>Transposing</H5></A>

  <P>
    The transpose operation works conceptually as
    matrix1&nbsp;=&nbsp;transpose(matrix2).  The code is then:

<PRE>
    vjMatrix mat1;
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    mat1.transpose(mat2);
</PRE>

    The result is stored in <TT>mat1</TT>.  <TT>mat2</TT> is passed as a
    reference to be efficient.
  </P>

<A NAME="invert"><H5>Finding the Inverse</H5></A>

  <P>
    Finding the inverse works conceptually as
    matrix1&nbsp;=&nbsp;inverse(matrix2).  The code is then:

<PRE>
    vjMatrix mat1;
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    mat1.invert(mat2);
</PRE>

    The result is stored in <TT>mat1</TT>.  <TT>mat2</TT> is passed as a
    reference to be efficient.
  </P>

<A NAME="add"><H5>Addition</H5></A>

  <P>
    For the addition operation, the interface is defined so that the sum
    of two matrices is stored in a third.  There are two ways to do
    addition with <TT>vjMatrix</TT>: using the <TT>add()</TT> method or
    using the overloaded <TT>+</TT> operator.  It is recommended that you
    use the former, but you can use the latter if you prefer that style of
    programming.  Examples of both methods follow.  The first block of
    code only declares the <TT>vjMatrix</TT> objects.

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat3;
</PRE>

    Using the <TT>add()</TT> method:

<PRE>
    mat3.add(mat1, mat2);
</PRE>

    Using the overloaded <TT>+</TT> operator:

<PRE>
    mat3 = mat1 + mat2;
</PRE>

    The result is stored (via a copy) in <TT>mat3</TT>.
  </P>

<A NAME="sub"><H5>Subtraction</H5></A>

  <P>
    For the subtraction operation, the interface is defined so that the
    difference of two matrices is stored in a third.  There are two ways to
    do subtraction with <TT>vjMatrix</TT>: using the <TT>sub()</TT> method
    or using the overloaded <TT>-</TT> operator.  It is recommended that you
    use the former, but you can use the latter if you prefer that style of
    programming.  Examples of both methods follow.  The first block of
    code only declares the <TT>vjMatrix</TT> objects.

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat3;
</PRE>

    Using the <TT>sub()</TT> method:

<PRE>
    mat3.sub(mat1, mat2);
</PRE>

    Using the overloaded <TT>-</TT> operator:

<PRE>
    mat3 = mat1 - mat2;
</PRE>

    The result is stored (via a copy) in <TT>mat3</TT>.
  </P>

<A NAME="mult"><H5>Multiplication</H5></A>

  <P>
    For the multiplication operation, the interface is defined so that the
    product of two matrices is stored in a third.  This is likely to be the
    operation used most often since transformation matrices are constructed
    through multiplication of different transforms.  For normal matrix
    multiplication, there are two ways to do multiplication with
    <TT>vjMatrix</TT>: using the <TT>mult()</TT> method or using the
    overloaded <TT>*</TT> operator.  It is recommended that you use the
    former, but you can use the latter if you prefer that style of
    programming.  Examples of both methods follow.  The first block of code
    only declares the <TT>vjMatrix</TT> objects.

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat3;
</PRE>

    Using the <TT>mult()</TT> method:

<PRE>
    mat3.mult(mat1, mat2);
</PRE>

    Using the overloaded <TT>*</TT> operator:

<PRE>
    mat3 = mat1 * mat2;
</PRE>

    The result is stored (via a copy) in <TT>mat3</TT>.
  </P>

  <P>
    There are two more multiplication operations provided that help in
    handling the order of the matrices when they are multiplied.  These
    two extra operations do post-multiplication and pre-multiplication of
    two matrices.  An example of post-multiplication is:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    mat1.postMult(mat2);
</PRE>

    Conceptually, the operation is
    <TT>mat1&nbsp;=&nbsp;mat1&nbsp;*&nbsp;mat2</TT> so that the second
    matrix (<TT>mat2</TT>) comes as the second factor.  The same result
    can be achieved using the overloaded <TT>*=</TT> operator:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    mat1 *= mat2;
</PRE>
  </P>

  <P>
    An example of pre-multiplication is:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vjMatrix mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    mat1.preMult(mat2);
</PRE>

    Here, the conceptual operation is
    <TT>mat1&nbsp;=&nbsp;mat2&nbsp;*&nbsp;mat1</TT> so that the second
    matrix (<TT>mat2</TT>) comes as the first factor.  In both cases,
    the result of the multiplication is stored in <TT>mat1</TT>.
  </P>

<A NAME="scale"><H5>Scaling by a Scalar Value</H5></A>

  <P>
    Scaling the values of a matrix by a scalar value can be done using
    two different methods: the <TT>scale()</TT> method or the overloaded
    <TT>*</TT> and <TT>/</TT> operators that take a single scalar value
    and returns a <TT>vjMatrix</TT>.  It is recommended that you use the
    former, but you can use the latter if you prefer that style of
    programming.  Examples of both methods follow.  First, using the
    <TT>scale()</TT> method works as:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vJMatrix mat2;

    mat2 = mat1.scale(3.0);
</PRE>

    Using the overloaded <TT>*</TT> operator works as:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vJMatrix mat2;

    mat2 = mat1 * 3.0;
</PRE>

    or

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vJMatrix mat2;

    mat2 = 3.0 * mat1;
</PRE>

    Using the overloaded <TT>/</TT> operator works as:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);
    vJMatrix mat2;

    mat2 = mat1 / 3.0;
</PRE>

    In all cases, the result of the scaling is stored (via a copy) in
    <TT>mat2</TT>.
  </P>

<A NAME="makeIdent"><H5>Creating an Identity Matrix Quickly</H5></A>

  <P>
    In computer graphics, an identity matrix is often needed when doing
    transformations.  Because of this, <TT>vjMatrix</TT> provides a
    method for converting a matrix into an identity matrix in a single
    step (at the user code level anyway):

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    mat1.makeIdent();
</PRE>

    Of course, simply declaring <TT>mat1</TT> with no arguments would
    achive the same result, but that's hardly the point of the example.
  </P>

<A NAME="zero"><H5>Zeroing a Matrix in a Single Step</H5></A>

  <P>
    Before using a matrix, it is often helpful to zero it out to ensure
    that there is no pollution from previous use.  With a <TT>vjMatrix</TT>,
    this can be done in one step:

<PRE>
    vjMatrix mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0, 5.6, 9.9, 9.7, 8.2,
                  3.8, 0.9, 2.1, 0.1);

    mat1.zero();
</PRE>

    The result is that all elements of <TT>mat1</TT> are now 0.0.
  </P>

<A NAME="euler"><H5>Creating an XYZ, a ZYX or a ZXY Euler Rotation
Matrix</H5></A>

  <P>
    All the rotation information for a transform can be contained in a
    single matrix using the methods for making an XYZ, a ZYX or a ZXY
    Euler matrix.  Code for all three follows:

<PRE>
    vjMatrix mat1;
    float x_rot = 0.4, y_rot = 0.541, z_rot = 0.14221;

    mat1.makeXYZEuler(x_rot, y_rot, y_rot);
    mat1.makeZYXEuler(z_rot, y_rot, x_rot);
    mat1.makeZXYEuler(z_rot, x_rot, y_rot);
</PRE>

    In every case, the matrix is first zeroed before the rotation
    transformation is stored.  The result of the above code is that
    <TT>mat1</TT> is a ZXY Euler rotation matrix.  The previous two
    operations are destroyed.  The rotation values can be read from a
    matrix that previously had one of the above operations applied to it.
    This is done as follows;

<PRE>
    float x_rot, y_rot, z_rot

    mat.getXYZEuler(x_rot, y_rot, z_rot);    // mat is an XYZ Euler matrix
    mat.getZYXEuler(x_rot, y_rot, z_rot);    // mat is an ZYX Euler matrix
    mat.getZXYEuler(x_rot, y_rot, z_rot);    // mat is an ZXY Euler matrix
</PRE>

    You would of course only use the call that is appropriate for
    extracting the rotation values from <TT>mat</TT>.  The <TT>float</TT>
    variables are passed by reference to the method so that the rotation
    values can be returned in them.
  </P>

<A NAME="constrain"><H5>Constraining Rotation About a Specific Axis or
Axes</H5></A>

  <P>
    In a matrix that has rotations about more than one axis, it may be
    useful to get a transformation matrix that constrains the rotation
    to certain axes.  A method is provided to do just this.  It is
    called <TT>constrainRotAxis()</TT>, and it is used as follows (assume
    that <TT>old_mat</TT> is already defined as a transformation matrix
    with rotations about all three axes):

<PRE>
    vjMatrix new_mat;

    old_mat.constrainRotAxis(true, false, false, new_mat);
</PRE>

    The result of this is that <TT>new_mat</TT> is a transformation matrix
    with all of <TT>old_mat</TT>'s transformations except that rotation is
    constrained to be about the <I>x</I>-axis alone rather than about all
    three axes.  The first three arguments are Boolean values that specify
    the axis constraints for the <I>x</I>-, <I>y</I>-, and <I>z</I>-axes
    respectively.  <TT>new_mat</TT> is passed by reference, and the result
    of the constrained transformations are stored in it.
  </P>

<A NAME="dircos"><H5>Making a Matrix Using Direction Cosines</H5></A>

  <P>
    Creating a direction cosine matrix is another part of the
    <TT>vjMatrix</TT> interface.  The method requires values for the
    <I>x</I>-, <I>y</I>-, and <I>z</I>-axes of the secondary coordinate
    system in terms of the first.  These must be passed as objects of
    type <TT>vjVec3</TT>.  Use of the method is (assuming that
    <TT>sec_x_axis</TT>, <TT>sec_y_axis</TT>, and <TT>sec_z_axis</TT> are
    already defined and have appropriate values):

<PRE>
    vjMatrix mat;

    mat.makeDirCos(sec_x_axis, sec_y_axis, sec_z_axis);
</PRE>

    The result is that <TT>mat</TT> becomes a direction cosine matrix.
  </P>

<A NAME="makeQuat"><H5>Making a Matrix from a Quaternion</H5></A>

  <P>
    Converting a <A HREF="${GLOSSARY}">quaternion</A> to its corresponding
    matrix is possible with <TT>vjMatrix</TT> objects.  Two methods are
    provided to do this each taking a different type of argument as the
    quaternion to be converted.  The first takes a four-element array of
    <TT>float</TT>s:

<PRE>
    vjMatrix mat;
    float quat[4];

    // Fill in quat...

    mat.makeQuaternion(quat);
</PRE>

    Here, <TT>quat</TT> is assigned its values appropriately.  The other
    version takes a reference to a <TT>vjQuat</TT> object:

<PRE>
    vjMatrix mat;
    vjQuat quat;

    // Fill in quat...

    mat.makeQuaternion(quat);
</PRE>

    The result in both cases is that <TT>mat</TT> is the transformation
    matrix represented by the quaternion.
  </P>

<A NAME="makeRot"><H5>Making a Rotation Transformation Matrix About a
Single Axis</H5></A>

  <P>
    To make a rotation matrix where the rotation is about a single axis,
    a simple method is provided as part of the <TT>vjMatrix</TT>
    interface.  It takes the rotation about the axis in degrees and the
    axis vector as a <TT>vjVec</TT> object.  Its use is as follows:

<PRE>
    vjMatrix mat;
    vjVec3 axis(1.0, 0.0, 0.0);

    mat.makeRot(45.0, axis);
</PRE>

    The <TT>makeRot()</TT> method causes <TT>mat</TT> to become a
    transformation matrix with <I>only</I> the given rotation.  This rather
    boring example therefore illustrates making a transformation matrix
    with only a 45&#176; rotation about the <I>x</I>-axis.
  </P>

  <P>
    You can also go further with the rotations.  Similar to the
    <TT>preMult()</TT> and <TT>postMult()</TT> methods described
    <A HREF="#mult">earlier</A>, you can perform pre-rotations and
    post-rotations in degrees about a given axis on a matrix.  To do a
    pre-rotation, the code would look similar to the following:

<PRE>
    vjMatrix mat1, mat2;
    vjVec3 axis(1.0, 0.0, 0.0):

    // Perform various transformations on mat2...

    mat1.preRot(45.0, axis, mat2);
</PRE>

    where <TT>axis</TT> is passed by reference.  The result is that
    <TT>mat1</TT> is a transformation matrix assigned the value of
    multiplying the given rotation by <TT>mat2</TT> in that order.
    <TT>mat2</TT> is passed by reference to improve efficiency.
  </P>

  <P>
    To do post-rotation, the code is similar:

<PRE>
    vjMatrix mat1, mat2;
    vjVec3 axis(1.0, 0.0, 0.0):

    // Perform various transformations on mat2...

    mat1.postTrans(mat2, 45.0, trans);
</PRE>

    where <TT>trans</TT> is passed by reference.  The result in both cases
    is that <TT>mat1</TT> is a transformation matrix assigned the value of
    multiplying <TT>mat2</TT> the given rotation in that order.
    <TT>mat2</TT> is passed by reference to improve efficiency.  Note that
    for post-rotation, the matrix argument is given before the rotation
    arguments as a reminder that it comes first in the multiplication
    order.
  </P>

<A NAME="makeTrans"><H5>Making a Translation Transformation Matrix</H5></A>

  <P>
    To make a translation matrix, there are two methods with each having
    two different types of arguments that specify the translation.  The
    first makes a matrix with only the given translation (all other
    transformation information is destroyed):

<PRE>
    vjMatrix mat;
    vjVec3 trans(4.0, -4.231, 1.0);

    mat.makeTrans(trans);
</PRE>

    or

<PRE>
    vjMatrix mat;

    mat.makeTrans(4.0, -4.231, 1.0);
</PRE>

    The only difference between these two is that the first takes a
    reference to a <TT>vjVec3</TT> object specifying the translation.
  </P>

  <P>
    If you want to <I>change</I> the translation of a transformation
    matrix without completely obliterate all other transformations, use
    the following instead:

<PRE>
    vjVec3 trans(4.0, -4.231, 1.0);

    mat.setTrans(trans);
</PRE>

    or

<PRE>
    mat.setTrans(4.0, -4.231, 1.0);
</PRE>

    Here, <TT>mat</TT> is assumed to be defined as a <TT>vjMatrix</TT>
    object with other transformations possibly set before this point of
    execution.
  </P>

  <P>
    You can also go further with the translations.  Similar to the
    <TT>preMult()</TT> and <TT>postMult()</TT> methods described
    <A HREF="#mult">earlier</A>, you can perform pre-translations and
    post-translations on a matrix.  To do a pre-translation, the code
    would look similar to the following:

<PRE>
    vjMatrix mat1, mat2;
    vjVec3 trans(4.0, -4.231, 1.0):

    // Perform various transformations on mat2...

    mat1.preTrans(trans, mat2);
</PRE>

    (where <TT>trans</TT> is passed by reference) or

<PRE>
    vjMatrix mat1, mat2;

    // Perform various transformations on mat2...

    mat1.preTrans(4.0, -4.231, 1.0, mat2);
</PRE>

    The result in both cases is that <TT>mat1</TT> is a transformation
    matrix assigned the value of multiplying the given translation by
    <TT>mat2</TT> in that order.  <TT>mat2</TT> is passed by reference to
    both methods to improve efficiency.
  </P>

  <P>
    To do post-translation, the code is similar:

<PRE>
    vjMatrix mat1, mat2;
    vjVec3 trans(4.0, -4.231, 1.0):

    // Perform various transformations on mat2...

    mat1.postTrans(mat2, trans);
</PRE>

    (where <TT>trans</TT> is passed by reference) or

<PRE>
    vjMatrix mat1, mat2;

    // Perform various transformations on mat2...

    mat1.postTrans(mat2, 4.0, -4.231, 1.0);
</PRE>

    The result in both cases is that <TT>mat1</TT> is a transformation
    matrix assigned the value of multiplying <TT>mat2</TT> the given
    translation in that order.  <TT>mat2</TT> is passed by reference to
    both methods to improve efficiency.  Note that for post-translation,
    the matrix argument is given before the translation argument(s) as a
    reminder that it comes first in the multiplication order.
  </P>

<A NAME="makeScale"><H5>Making a Scale Transformation Matrix</H5></A>

  <P>
    To make a transformation matrix that only scales, a simple method is
    provided.  It works as follows:

<PRE>
    vjMatrix mat;

    mat.makeScale(1.5, 1.5, 1.5);
</PRE>

    The result is that <TT>mat</TT> is a transformation matrix that will
    perform a scale operation.  In this case, the scaling happens
    uniformly for <I>x</I>, <I>y</I>, and <I>z</I>.
  </P>

  <P>
    You can also go further with the scaling.  Similar to the
    <TT>preMult()</TT> and <TT>postMult()</TT> methods described
    <A HREF="#mult">earlier</A>, you can perform pre-scale and post-scale
    operations on a matrix.  To do a pre-scale, the code would look
    similar to the following:

<PRE>
    vjMatrix mat1, mat2;

    // Perform various transformations on mat2...

    mat1.preScale(1.5, 1.5, 1.5, mat2);
</PRE>

    The result in both cases is that <TT>mat1</TT> is a transformation
    matrix assigned the value of multiplying the given scaling factors
    by <TT>mat2</TT> in that order.  <TT>mat2</TT> is passed by reference
    to both methods to improve efficiency.
  </P>

  <P>
    To do post-scale, the code is similar:

<PRE>
    vjMatrix mat1, mat2;

    // Perform various transformations on mat2...

    mat1.postScale(mat2, 1.5, 1.5, 1.5);
</PRE>

    The result in both cases is that <TT>mat1</TT> is a transformation
    matrix assigned the value of multiplying <TT>mat2</TT> the given
    scale factors in that order.  <TT>mat2</TT> is passed by reference to
    both methods to improve efficiency.  Note that for post-scaling, the
    matrix argument is given before the scale factor arguments as a
    reminder that it comes first in the multiplication order.
  </P>

<A NAME="extract"><H5>Extracting Specific Transformation Information</H5></A>

  <P>
    Finally, methods are provided for extracting transformations from a
    given transformation matrix.  You can read the individual rotations
    and the translation.  For the following examples, assume that
    <TT>mat</TT> is a <TT>vjMatrix</TT> object representing arbitrary
    translation, rotaiton and scaling transformations.  To get the roll
    information, you can do:

<PRE>
    float roll = mat.getRoll();
</PRE>

    or

<PRE>
    float z_rot = mat.getZRot();
</PRE>

    The value return is in the range -180.0&#176; to 180.0&#176;.  To get
    the pitch information, you can do:

<PRE>
    float pitch = mat.getPitch();
</PRE>

    or

<PRE>
    float x_rot = mat.getXRot();
</PRE>

    Again, the value return is in the range -180.0&#176; to 180.0&#176;.
    To get the yaw information, you can do:

<PRE>
    float yaw = mat.getYaw();
</PRE>

    or

<PRE>
    float y_rot = mat.getYRot();
</PRE>

    Once again, the value return is in the range -180.0&#176; to
    180.0&#176;.
  </P>

  <P>
    Getting translations is even simpler since translations are easily
    collected into a single vector.  There are two forms for getting
    the translation.  The first takes three <TT>float</TT>s by
    reference:

<PRE>
    float x, y, z;

    mat.getTrans(x, y, z);
</PRE>

    After this, the translation in <TT>mat</TT> is stored in <TT>x</TT>,
    <TT>y</TT> and <TT>z</TT>.  The second form returns a copy of a
    <TT>vjVec3</TT> object:

<PRE>
    vjVec3 trans;

    trans = mat.getTrans();
</PRE>

    That's all there is to reading translations.
  </P>

<A NAME="pfMatrix"><H5>Converting to a Performer Matrix</H5></A>

  <P>
    SGI's OpenGL Performer likes to work with its own <TT>pfMatrix</TT>
    class, and to facilitate the use of it with <TT>vjMatrix</TT>, two
    conversion functions are provided for converting a <TT>vjMatrix</TT>
    to a <TT>pfMatrix</TT> and vice versa.  The first works as follows:

<PRE>
    vjMatrix vj_mat;
    pfMatrix pf_mat;

    // Perform operations on vj_mat...

    pf_mat = vjGetPfMatrix(vj_mat);
</PRE>

    where <TT>vj_mat</TT> is passed by reference for efficiency.
    (<TT>pf_mat</TT> gets a copy of a <TT>pfMatrix</TT> which is a slow
    operation.)  To convert a <TT>pfMatrix</TT> to a <TT>vjMatrix</TT>,
    do the following:

<PRE>
    pfMatrix pf_mat;
    vjMatrix vj_mat;

    // Perform operations on pf_mat...

    vj_mat = vjGetVjMatrix(pf_mat);
</PRE>

    Here again, <TT>pf_mat</TT> is passed by reference for efficiency
    and <TT>vj_mat</TT> gets a copy of a <TT>vjMatrix</TT>.  Both of these
    functions are found in the header <TT>Kernel/Pf/vjPfUtil.h</TT>.
  </P>

<A NAME="details"><H4>The Gory Details</H4></A>

  <P>
    Now it's time for the really nasty part.  Reading this could cause
    difficulty in understanding the overwhelming amount of information
    just presented.  Don't read any further unless you absolutely have
    to or you just like to confuse yourself.
  </P>

  <P>
    C, C++ and mathematics use matrices in row-major order.  In other words
    the access indices look like:
  </P>

  <P>
    <TABLE BORDER="1">
      <TR>
	<TD>
	  (0,0)
	</TD>
	<TD>
	  (0,1)
	</TD>
	<TD>
	  (0,2)
	</TD>
	<TD>
	  (0,3)
	</TD>
	<TD>
	  &lt;---&nbsp;Array
	</TD>
      </TR>
      <TR>
	<TD>
	  (1,0)
	</TD>
	<TD>
	  (1,1)
	</TD>
	<TD>
	  (1,2)
	</TD>
	<TD>
	  (1,3)
	</TD>
	<TD>
	  &lt;---&nbsp;Array
	</TD>
      </TR>
      <TR>
	<TD>
	  (2,0)
	</TD>
	<TD>
	  (2,1)
	</TD>
	<TD>
	  (2,2)
	</TD>
	<TD>
	  (2,3)
	</TD>
	<TD>
	  &lt;---&nbsp;Array
	</TD>
      </TR>
      <TR>
	<TD>
	  (3,0)
	</TD>
	<TD>
	  (3,1)
	</TD>
	<TD>
	  (3,2)
	</TD>
	<TD>
	  (3,3)
	</TD>
	<TD>
	  &lt;---&nbsp;Array
	</TD>
      </TR>
    </TABLE>
  </P>

  <P>
    OpenGL ordering specifies that the matrix has to be column major in
    memory, so to provide programmers with a way to pass a transformation
    matrix to OpenGL in one step (via <TT>glMultMatrixf()</TT>), the
    <TT>vjMatrix</TT> class maintains its internal matrix in column-major
    order.  Note that in the following table, the given indices are what
    the cells have to be called in C/C++ notation because we are putting the
    back-to-back.
  </P>

  <P>
    <TABLE BORDER="1">
      <TR>
	<TD>
	  (0,0)
	</TD>
	<TD>
	  (1,0)
	</TD>
	<TD>
	  (2,0)
	</TD>
	<TD>
	  (3,0)
	</TD>
      </TR>
      <TR>
	<TD>
	  (0,1)
	</TD>
	<TD>
	  (1,1)
	</TD>
	<TD>
	  (2,1)
	</TD>
	<TD>
	  (3,1)
	</TD>
      </TR>
      <TR>
	<TD>
	  (0,2)
	</TD>
	<TD>
	  (1,2)
	</TD>
	<TD>
	  (2,2)
	</TD>
	<TD>
	  (3,2)
	</TD>
      </TR>
      <TR>
	<TD>
	  (0,3)
	</TD>
	<TD>
	  (1,3)
	</TD>
	<TD>
	  (2,3)
	</TD>
	<TD>
	  (3,3)
	</TD>
      </TR>
      <TR>
	<TD ALIGN="CENTER">
	    ^<BR>
	    |<BR>
	  Array
	</TD>
	<TD ALIGN="CENTER">
	    ^<BR>
	    |<BR>
	  Array
	</TD>
	<TD ALIGN="CENTER">
	    ^<BR>
	    |<BR>
	  Array
	</TD>
	<TD ALIGN="CENTER">
	    ^<BR>
	    |<BR>
	  Array
	</TD>
      </TR>
    </TABLE>
  </P>

  <P>
    As mentioned, all of this is done so that a given <TT>vjMatrix</TT>
    that acts as a full transformation matrix can be passed to OpenGL
    directly (more or less).  For example, if you have a <TT>vjMatrix</TT>
    object <TT>mat</TT> upon which you have performed painstaking
    transformations to transform a model to exacting parameters, you can
    do the following:

<PRE>
    glMultMatrixf(mat.getFloatPtr());
    // Render model ...
</PRE>

    Wow, isn't that great?  All your efforts have culminated into one
    statement.  The best possible source of information, especially for
    this class, is the header.  Read it, understand it, love it.
  </P>

</BODY>
