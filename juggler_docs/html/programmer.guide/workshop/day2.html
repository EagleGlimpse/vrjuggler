<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7C-SGI [en] (X11; I; IRIX64 6.5 IP30) [Netscape]">
</head>
<body>

<h2>
VRJuggler Workshop Part II</h2>

<ul>
<h3>
Obtaining and using Juggler data from trackers (wand, head, etc.)</h3>

<ul>
<h4>
Using wand position and orientation data (from wand example)</h4>

<ul>
<h5>
Member variable declaration</h5>
vjPosInterface mWand;
<h5>
Initialization</h5>
mWand.init("VJWand");
<h5>
Getting and using positional data</h5>
vjMatrix* wandMatrix;
<br>wandMatrix = mWand->getData();
<br>glPushMatrix();
<br>&nbsp;&nbsp;&nbsp; glMultMatrixf(wandMatrix->getFloatPtr());
<br>&nbsp;&nbsp;&nbsp; glColor3f(1.0f, 0.0f, 1.0f);
<br>&nbsp;&nbsp;&nbsp; glScalef(0.25f, 0.25f, 0.25f);
<br>&nbsp;&nbsp;&nbsp; drawCube();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// draw cube in wand's place
<br>glPopMatrix();</ul>

<h4>
Detecting and Using Button clicks (from cubes example)</h4>

<ul>
<h5>
Member variable declaration</h5>
vjPosInterface&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mWand;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// the Wand
<br>vjDigitalInterface&nbsp;&nbsp; mIncVelocityButton;&nbsp;&nbsp;&nbsp;&nbsp;
// Button for increasing velocity
<br>vjDigitalInterface&nbsp;&nbsp; mDecVelocityButton;&nbsp;&nbsp;&nbsp;
// Button for increasing velocity
<br>vjDigitalInterface&nbsp;&nbsp; mStopButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Button for setting velocity to zero
<h5>
Initialization needed</h5>
mIncVelocityButton.init("VJButton0");
<br>mDecVelocityButton.init("VJButton1");
<br>mStopButton.init("VJButton2");
<h5>
Getting and using button data</h5>
if(mIncVelocityButton->getData())&nbsp;&nbsp;&nbsp;&nbsp; // somewhat similar
to vjDigital::On below
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mCurVelocity += velocity_inc;&nbsp;&nbsp;
// mCurVelocity is just a float variable
<p>When a button is pressed:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(mIncVelocityButton->getData()
== vjDigital::TOGGLE_ON)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "-- Toggle ON --" &lt;&lt; endl;
<br>When a button is released:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(mIncVelocityButton->getData()
== vjDigital::TOGGLE_OFF)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "-- Toggle OFF --" &lt;&lt; endl;
<br>When a button is held down:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(mIncVelocityButton->getData()
== vjDigital::ON)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "-- ON --" &lt;&lt; endl;
<br>When a button is not held down:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(mIncVelocityButton->getData()
== vjDigital::OFF)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "-- OFF --" &lt;&lt; endl;</ul>

<h4>
Creating a navigation matrix (from cube example)</h4>

<ul>
<h5>
Description</h5>
The method used to calculate the navigation matrix in the cube example
uses quaternions.&nbsp; If you don't understand why or how quaternions
are used, read up on them (do a quick internet search) to get a better
idea of what's happening.&nbsp; The basic idea is to use the wand orientation
to generate a rotation matrix.&nbsp; The code is not simple but there are
sufficient comments in the source code to help you along.
<h5>
Is the cubes method sufficient for your navigation?</h5>
Probably not.&nbsp; The cubes example rotates with full six degrees of
freedom.&nbsp; This is okay for simulating things like an airplane which
can fly and rotate in any direction.&nbsp; Many applications will want
the to user to always stand upright relative to the ground, so only one
axis of rotation (the Y-axis) is usually used.&nbsp; See if you can figure
out how to do this.&nbsp; (Hint: you will want to set rotations around
the X and Z axes to zero.</ul>
</ul>

<h3>
Local Coordinates and Global Coordinates</h3>

<ul>
<h4>
Definitions</h4>

<ul>
<h5>
Global Coordinate System</h5>
Assigns the coordinates of all points to a single common origin.
<h5>
Local Coordinate Sytem</h5>
Assigns the coordinates of all points relative to one or more origins.</ul>

<h4>
Their relationship in our applications</h4>

<ul>
<h5>
The coordinate system for our physical environment</h5>
For us, the origin of the global coordinate system is on the floor in middle
of our environment (the C2) floor.&nbsp; This allows the local coordinate
system for the C2 to match the global coordinate system.&nbsp; The type
of data you get from the wand or head trackers will be with respect to
this global origin.
<br>However, the virtual world you create will probably be bigger than
the C2.&nbsp; And, if you want to be able to move outside the physical
limits of the C2, you will need to use a local coordinate system for your
world.
<h5>
The reason for using Local and Global Coordinates</h5>

<ul>You can't physically move the user or his/her VR equipment, so you
need to be able to move around the rest of the world.</ul>

<h5>
When to convert between coordinate systems</h5>

<ul>You should keep track of the difference between global and local coordinates
with a navigation matrix.
<br>In your application, this difference will be the virtual world's position,
relative to the center of the C2.
<br>When you want world coordinates to be drawn correctly from the users
perspective, you just need to move their local origin.
<br>When you have global coordinates (like wand position), you won't need
to convert them before you draw them.</ul>
</ul>

<h4>
Example : How and why to convert between global coordinates and local coordinates.</h4>

<ul>
<h5>
Description</h5>
There is a tree ahead of the user in the distance.&nbsp; You want to move
him/her forward 20 feet, closer to the tree.
<br>(Assume the user starts at position (0,0,0) in world coordinates, where
forwad is -z direction and backward is +z direction).
<br>Since you can't physically move the user 20 feet, you must instead
move the tree towards the user and make is seem as if the user were moving
forward.
<h5>
Details</h5>
If the front of the user is in the negative z direction, you want to move
the tree in the positive z direction like this.
<ul>&nbsp;&nbsp; glPushMatrix();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(0,0,+20);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslate(tree_pos_x,
tree_pos_y, tree_pos_z);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_tree();
<br>&nbsp;&nbsp;&nbsp; glPopMatrix();</ul>
BUT, you probaly want to use a navigation matrix instead (which includes
both position and orientation), like this:
<ul>&nbsp;&nbsp;&nbsp; glPushMatrix();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMultMatrix(nav_matrix);&nbsp;&nbsp;
// you can do this because vjMatrix format is the same format as an OpenGL
matrix.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(tree_pos_x,
tree_pos_y, tree_pos_z);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_tree();
<br>&nbsp;&nbsp;&nbsp; glPopMatrix();</ul>
AND, you will want to use the nav_matrix to draw all your world objects,
like this:
<ul>&nbsp;&nbsp;&nbsp; glPushMatrix();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMultMatrix(nav_matrix);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
glTranslatef(tree_pos_x, tree_pos_y, tree_pos_z);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
draw_tree();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
glMultMatrixf(car_matrix);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
draw_car();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; //&nbsp;
more objects here
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
<br>&nbsp;&nbsp; glPopMatrix();</ul>
</ul>

<h4>
What objects don't require a navigation matrix?</h4>
Remember, the origin of the data from the wand and head is always at the
center of the floor in front of you.&nbsp; Therefore, if you want to draw
things at their positions, you don't need to incorporate the navigation
matrix.
<h4>
Would I ever need to convert global coordinates to my virtual world's local
coordinates?</h4>
You don't "need" to, but if you are testing things such as whether the
wand is intersecting any of a large number objects, it will help.&nbsp;
Instead of transforming each object to your global coordinate system, you
can transform your wand data to your virtual world (just once) and perform
your intersection tests with fewer calculations.
<h4>
How do I do this?</h4>
You can premultiply a wand_matrix by an inverse nav_matrix to get it's
correct location and orientation in your virtual world's local coordinates.
<br>Note the "inverse" nav_matrix -- you can't use the exact same matrix
you used when drawing your world's objects -- you have go in the opposite
direction.
<br>In the tree example used above, if the user and wand are to move closer
to the tree by 20 feet, they need to move in the negative z direction (earlier,
the matrix was used to move the tree in the positive z direction, so we
need to use the inverse).
<h4>
You are using local coordinate systems all the time</h4>
Anytime you use functions like glMultMatrix or glTranslate to modify the
current matrix, you are in effect using a new local coordinate system.
<br>For example, if you want to draw a object on the wand, you are using
the wand as the origin for your object.&nbsp; This is a local coordinate
system with a new origin.
<h4>
Using the head's local coordinate system.</h4>
If you want to add a heads up display (HUD) that presents pictures or words
that are always in front of the user's face, you can use a matrix with
data from the head as a local coordinate system.
<br>Simply multiply the current matrix by a head matrix that you obtain
from Juggler, and then translate a little bit forward.&nbsp; Whatever you
draw next (words or objects) will appear in front of the user's face.&nbsp;
(Be careful with extras like this; it is easy to annoy a user with unnecessary
features).
<h4>
Use this information to help you work on practice exercise #2</h4>
&nbsp;Modify the program you wrote for the practice exercise #1 in the
following way.&nbsp; Place the cube, cone and sphere far away from the
area within the user's reach.&nbsp; Allow users to navigate or fly near
to each object. Once one of the objects is within users' reach, allow users
to grab it with the wand and to navigate and fly around the space holding
the object.&nbsp; Provide capabilities to release the object anywhere in
the space and to have the ability of picking it up later.</ul>

<h3>
Multiple Walls and Synchronizing Animations</h3>

<ul>
<h4>
Running your application with multiple walls</h4>
VR libraries other than Juggler sometime require extra programming to deal
with multiple walls.&nbsp; Juggler does not.&nbsp;&nbsp; It synchronizes
the walls for you, so you don't have to do any extra work when changing
your application from 1 wall to 4 or 6 walls.&nbsp;&nbsp; The only difference
is the config file you use.
<h4>
You don't need to worry about synchronizing processes</h4>
VRJuggler runs on one computer so you don't have to worry about synchronizing
between different processes on different computers.</ul>
</ul>

</body>
</html>
